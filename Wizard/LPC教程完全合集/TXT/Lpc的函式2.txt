2.3 自己動手寫函數 
  用Lpc寫Object的函數，是為了表現這個Object的特性。這個特性的 
函數實際上就是一些代碼按順序排列，排列的順序決定了這個函數。一 
個函數被調用，函數的代碼就按照函數定義中代碼按順序執行。在 
eventPrintValue()中，下面這個語句： 
 
----- 
x = add(2, 2); 
----- 
 
必須在 efun: write() 之前調用，如果你想看到正確的結果。 
 
  為了返回這個函數執行後的值，必須這麼做：使用 "return" 指令和後 
面跟著和這個函數數據類型一樣的一個值。在上面的 add()，這個指令是 
"return ( x + y );"，( x + y )的值就是返回給 eventPrintValue() 
以及賦給 x 的那個值。更進一步的說，"return" 結束當前函數的執行 
並把控制權返回給調用它的那個函數。實際上，return 可以返回跟在 
它後面的一個表達式的值。如果想停止一個類型為void的函數的執行， 
只要簡單使用 "return;"，不返回任何值。強調一點，想要返回的表達 
式的值的數據類型 必須 和函數自己的數據類型一致。 
  那到底如何寫一個函數(lfun)？ 
  一個函數定義通常按次序有下面部分： 
  1) 函數返回數據類型 
  2) 函數名 
  3) 以 ( 開始，以 ) 結束的函數列表 
  4) 一個 { 標誌這個函數從這裡開始執行 
  5) 變量聲明，在這個函數將要使用的變量 
  6) 計算機指令，各種語句，表達式，以及調用別的函數。 
  7) 一個 } 標誌函數代碼部分到次結束。除非這個函數的類型說明成 
     void，在 } 之前必須有個 return 返回和這個函數的數據類型，在 
     return 後繼續執行調用這個函數的那個函數。 
 
舉個平凡的例子： 
 
----- 
int my_function( string target ) 
{ 
    string name; 
    object ppl 
 
    name = "Trill"; 
    if ( ppl = find_player( target ) ) 
    { 
        tell_object( ppl, "hi. My name is " + name + ". \n" ) 
        return 1; 
    } 
    else 
    { 
        tell_object( this_player(), "sorry, i don't find the target : " 
            + name + ".\n" ); 
        return 0; 
    } 
    return 0; 
} 
----- 
 
  這個函數接收一個 string 類型的參數，執行一些指令，返回一個 int 
型的整數。 
 
                    第三節  小結 
  定義了Lpc的Object的文件實際是由一些函數組成的。所有的函數，按 
順序由以下部分組成： 
    1) 函數聲明 
    2) 函數定義(函數體) 
    3) 函數調用 
    3) The call 
  函數聲明通常出現在這個文件的開頭，在任何一個函數定義之前。必 
須做到是，每個函數的被調用之前有函數的聲明。在 XO 中規定嚴格一 
些所有的函數必須有聲明。 
  函數定義可以出現在文件的任何地方，只要在它的聲明之後就可以了。 
有一點要注意，不要在一個函數內部定義另一個函數。在 XO 中規定是 
函數的定義按照一個給定的次序。 
  函數調用通常在別的函數定義的內部，如果你想要你的代碼執行你寫 
的函數的話。當然也可以出現這個函數自己的函數定義內部，但是對於 
一個新的巫師來說，最好別這麼做，因為這樣可能導致無限的循環。 
 
  每個 Driver 有自己一套 efun ，這些函數 Driver 已經替你聲明過了， 
也已經定義好了。efun 通常執行起來要比你自己寫的函數快一些。更進 
一步說，每個 MudLib 有一些特殊的函數看起來非常像 efun，他們也已 
經聲明過了，定義好了。他們被叫做 simul_efun，或者 sefun，或者叫 
做 模擬 efun。對於 efun 的幫助，通常在 /doc/efun，或者 
/help/wizard/efun，等類型的目錄底下。很多 Mud 會提供一個指令，比 
如 "man" 或 "help" 來提供在線幫助。 
 
  注意： 
  有些 Driver 對函數的類型檢查不嚴格，甚至忽略你對函數那些特殊 
的聲明，比如 private 等等。但是不要管這個，你應該這樣一個良好的 
習慣，對函數的類型有嚴格聲明。為什麼？ 
 
    1)對別的人(包括以後你自己)能更容易讀你的程序，更快理解你這 
      部分代碼想描述什麼。這個對調試程序也是很有用的，大部分的 
      程序錯誤(包括 () 和 {} 的丟失)通常是數據類型不匹配。 
    2)因為這個被認為是個好的編程習慣。 