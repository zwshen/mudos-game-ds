                        第三章 Lpc的函數 
                          第一節 序言 
 
  在前面的介紹中，大家應該知道了Lpc的Object包含能處理變量的函數。 
當函數被執行時，它的工作就是處理操作變量，還有是調用(call)別的函 
數。變量在函數中被改變操作。變量必須有個數據類型使得計算機能明白 
它指向的內存中"0"和"1"到底是什麼東西。一個Object的性質通常由它的 
包含的變量確定，但是它的特性的表現卻是依賴於它包含的函數。一個 
Object如果不含有任何一個函數那是不可想像的。那麼：什麼是函數。 
 
                        第二節 函數 
 
2.1 什麼是函數？ 
  和數學的函數一樣，你給Lpc的函數一個值，它能返回一個值。有些語 
言，比如Pascal，會區分過程和函數。Lpc和C/C++一樣，沒有過程，但是 
明白這種區別還是有用的。Pascal叫做過程的東西，Lpc叫做類型是void 
的函數。換句話說，過程就是什麼都不返回的函數。Pascal叫做函數的， 
必須返回一些東西。在Lpc中，最無聊的，最簡單的，但也是正確的函數 
是這樣的： 
 
----- 
void eventDoNothing() {} 
----- 
 
這個函數不接收任何輸入，不執行指令，也不返回任何值。 
 
  每一個Lpc函數都由三部分組成： 
1) 函數聲明 
2) 函數定義 
3) 函數調用 
 
  和變量一樣，函數必須先有個聲明。這樣可以讓Driver知道： 
  1) 這個函數將返回的是哪種數據類型。 
  2) 需要的輸入是什麼，多少。通常把輸入叫做參數。 
  一個函數聲明通常是這樣的： 
類型 函數名(參數1, 參數2, ..., 參數N); 
  下面是一個函數聲明的例子，這個函數叫 DrinkWater，有一個string 
類型的參數，返回的是一個int。 
 
----- 
int eventDrinkWater(string str); 
----- 
 
  在上面的聲明中, str是輸入的參數的變量名，也可以沒有。就是說可以 
像下面這樣聲明 eventDrinkWater() 
 
----- 
int eventDrinkWater(string); 
----- 
 
  函數定義就是代碼，它描述了這個函數對傳人的參數究竟做了些什麼。 
  函數調用就是別的函數在任何地方使用執行了這個函數。一個函數在它 
寫完後永遠不會被調用，那這個函數的存在的唯一意義只能是浪費內存和 
硬盤。一個函數寫出來的目的是為了被調用。 
  下面是兩個函數相互調用的例子，兩個函數是 eventPrintValue() 和 
add(), 
 
----- 
/* 首先是函數聲明，這個通常是在一個Object的開始部分。 
 */ 
 
void eventPrintValue(); 
int add(int x, int y); 
 
/* 其次是函數 write_vals() 的函數定義。我們假定這個函數將被調用 
 * 是為了描述這個Object. 
 */ 
void eventPrintValue() 
{ 
    int x; 
 
    x = add(2, 2); // 我們指定 x 接收調用函數 add() 後返回的值。 
    write(x + "\n"); 
} 
 
/* 最後是函數 add() 的函數定義。 */ 
int add(int x, int y) 
{ 
    return (x + y); 
} 
----- 
 
  有一點是指明的，在XO的編程的風格我們要求所有的函數都必須有聲 
明，這個在我們最開始時候說明過。但是實際上必須有函數聲明的函數 
是那些被調用在函數定義之前的函數。我們規定必須有函數聲明，這個 
只是規定，但是它會給編程帶來好處。 
 
  在這一節我們知道什麼是函數，函數是由什麼組成。要記住，寫一個 
函數的根本目的是為用它，調用它。一個函數永遠不會被調用，那它就 
失去了存在的價值。通常別人使用你寫的函數，通常只關心它能對傳人 
的參數做些什麼加工，就是這個函數的功能是什麼，返回什麼。因此一 
個函數有一個好的函數名，能直接描述這個函數的功能是很重要的。我 
在第一章中說明了XO規定的對函數的命名機制。採用統一的命名方式有 
助於相互合作提高效率。 
 
2.2 Efuns 
  也許你已經聽說過efun這個詞了，他們是外部定義的函數，是 
externally defined function 的縮寫。就是說，他們是由Mud Driver 
定義好的。如果參加過Lpc的編程，或者看過Lpc的代碼，你可能找到這 
樣的一些表達式：this_player(), strcmp(), implode(), filter()， 
等等，看起來像是一個函數，而你找遍整個Object以及這個Object繼承 
的所有Object中都沒有這些函數，這就表明他們是efun。efun存在價值 
是因為他們執行起來要比一般的Object帶有的函數速度快的多，為什麼 
快呢，因為他們是以計算機直接能理解的二進制的形式存在。對於Object 
內部定義的函數，我們通常叫他們是lfun(local function)。一個巫師 
主要工作也就是編寫一些lfun組成的Object。 
  在上面的例子中的 eventPrintValue() 中調用了兩個函數，第一個是 
函數 add(), 這個是有你聲明和定義的，這個就是lfun。第二次調用， 
是調用函數 write() 這個函數通常就是efun。Driver已經替你聲明和定 
義好了。你所要做只是調用它。 
  efun被創立是為了 
  1) 處理一些很常用的，每天都有許多函數會調用的。 
  2) 處理internet socket的輸入輸出。 
  3) 以及一些Lpc很難處理的事，畢竟Lpc是C的很小的子集。 
  efun是用C寫好的，內嵌在Driver裡面的。在Mud起來之前，和Driver 
一起編譯好的，他們執行起來會快的多。但是正和你期望的一樣，他們 
的調用和你寫的函數的調用方法是完全一樣的。總的來說，需要關心的 
和一般函數一樣，它需要傳入什麼參數，它將會返回什麼的東西。 
 
  怎樣得到一些efun的信息，比如傳入參數和返回的類型，通常在一個 
Mud裡面，你可以在類似這樣的 /doc/efun 的目錄底下找到，或者直接 
用 help <efun名> 指令就可以得到幫助。efun及其依賴於你所在的Mud 
的Driver，不同的Driver帶有的efun區別是很大。 
  對於XO，使用的是MudOS，一般的efun，只要用 help 指令就能得到 
幫助，或者你多看看源碼，看看別人是怎樣使用的，當然你如果無論如 
何也不能明白一個efun，你可以問問大巫師，他們通常會很樂意和你探 
討的。但是有一點是指出，能自己解決的問題最好自己解決。 