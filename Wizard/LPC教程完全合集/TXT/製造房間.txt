[如何制作房間]
    一個房間必定繼承了 ROOM (inherit ROOM), 這是在
<mudlib.h中被 #define 好的一個檔案, 它表示一個特別的檔案, 所
有的房間都必須繼承它. 才能擁有屬於房間的一切特性　
    一個房間有三個非常重要的函式: create(), init(), 與 refresh()
這三個函數會在某些特定的時機被系統所呼叫, 並且可以由你自行改寫
, 以達成千變萬化的效果　

 [create 函數]
　 create() 是房間在一被創造出來時必定要呼叫的一個函數, 通常我
們都在裡面做一大堆設定初值的動作　隨便找一個房間來看, 我們可以
發現 create() 函數中總是有一大堆的 set("something", somevalue);
這些 set 的意義在此不詳述, 你可以自己猜,  也可以問問較資深的巫
師　

   有時你的房間並不直接繼承 ROOM　而是繼承了一個有繼承 ROOM 的
特別房間, 像是商店或是公會房間什麼的　這時候你所寫的 create()
函數會覆蓋掉原先繼承來的房間中的 create() 函數, 而導致不能正常
的動作　這時候你最好在你的 create() 函數中加入 ::create();  這
行指令, 它表示要去執行原先繼承來的那個 ROOM 中的 create() 函數

   如果你有寫 refresh() 函數, 那麼在 create()  函數的最後加上
一行 refresh(); 來呼叫它會是個好主意　

[init 函數]
   init() 函數被呼叫的時機在於有生物 (怪物及玩家)  進入這個房
間的時候　這時有個常用的函數 this_player()  會傳回走進房間的這
個人, 或是怪物　this_player() 的概念容後再談, 你現在只要記住這
個函數在每個生物走進來時都會被呼叫一次就可以了　
   在 init() 中最常見的的函數莫過於 add_action("function", "action");
了，它的作用是在進來的生物身上添加上一個指令 (注意, 系統只認指
令的第一個字), 並在玩家下達這個指令時去呼叫 "function"  中所給
定名稱的函數　舉例而言, 如果我們寫了這樣的 init():
init() {
                add_action("do_climb", "climb");
}
當玩家走進這個房間時, 系統會幫他多出 climb 這個指令　當他下達
了 climb tree 這個指令時, 系統會去尋找 do_climb() 這個函數, 並
加以執行　同時, 系統會將玩家所輸入的 "climb"  這個指令後的所有
文字以字串型別的引數傳給 do_climb()　 你可以將 do_climb 這個函
數宣告為 int do_climb(string s)　 這樣一來, 當玩家下達 climb
tree, 或是 climb the red wall 這種指令時, "tree" 或是 "the red
wall" 就會被存進字串變數 s 之中供你處理　

    由 add_action() 所宣告的函數必定要是一個整數型別的函數, 因
為系統會根據這個函數的傳回值採取不同的動作　如果你傳回的是 0,
那麼系統會認定這個命令與你這個處理函數無關, 而對其他也有 climb
命令的函數一個一個嘗試著去執行, 直到所有的 climb 命令都傳回 0
時, 系統會當這個指令不合法, 而丟出一個錯誤訊息(what?) 給玩家　

    若你的函數傳回值為 1, 表示這個指令已經由你所寫的函數處理掉
了, 系統不會再嘗試著往下面繼續尋找其他的 climb 指令　
    在你的函式偵測到玩家輸入的引數有問題時 (例如你要他們 climb
tree, 但他們卻輸入了一些錯誤的指令如 climb three 之類的)　 想
給他們一些特別的錯誤訊息時, 你可以用 notify_fail(string errormsg)
來寫這個訊息, 如 notify_fail("climb what?\n");   notify_fail()
這個函數也是 int 型別, 固定會傳回 0, 所以我們最常用的寫法是:

if (條件不合)
        return notify_fail(錯誤訊息);
if (另一個條件不合)
        return notify_fail(另一個錯誤訊息);
.............................
<所有可能導致錯誤的輸入都過濾光了>
開始真正幹活的部份....
return 1;
  [refresh() 函數]
        refresh 呼叫的時機是系統定時 (約每半個小時一次) 呼叫　主
要的用途在於房間中怪物　物品的再生　如果你改寫了 refresh()
函數, 千萬記得要串接 ::refresh(), 否則可能導致嚴重的後果 (門
一打開就不會自動關上, 怪物打死後也不會再生...

    由於有 set("objects", (["name1" : "file1", "name2" :
"file2",... ]) ); 這種寫法的存在 (在 create() 裡面這麼寫) 所
以 refresh() 被用到的機會不多了　 (因為 set("objects", ) 這
個寫法可以幫你作出自動定時 refresh 怪物　物品)  但是在制作一
些必須定時回復原始狀態的小機關時, 仍然有必要用到這個函數　
有關房間的部份就寫到這裡, 接下來是物品