                   第四章 Lpc的繼承簡介 
 
                        第一節 前言 
  通過上一章的閱讀，你應該知道Lpc的函數的基本工作方式。你應該學 
會如何聲明和調用函數。更進一步，你應該有能力自己寫函數定義，即 
使你是首次接觸Lpc。你知道了函數調用是如何執行的，函數必須有一個 
返回值，除非是 void 類型的。 
  下面我們來看一個例子。看看巫師的工作室，可能幾乎都有類似下面 
的一段代碼。(這個不同的 MudLib 是不一樣的) 
 
----- 
 
void create(); 
 
inherit "/std/room"; 
 
void create() 
{ 
    room::create(); 
 
    set( "short", "巫師工作室"); 
    set( "long", "這是一片未曾開墾的土地，需要巫師的畫筆去描繪。\n" ); 
 
    set( "exits", ([ 
        "trill"     :   "/u/trill/workroom", 
    ]); 
 
    create_door("south", "時空之門", "north", 0); 
    setup(); 
} 
 
----- 
 
  如果你理解了前面的幾章，你應該能立刻指出幾點： 
    1)  create() 是一個函數的定義部分。"void create();" 是它的函數 
        聲明，卻有在 create() 裡面有個 room::create() 沒有聲明。 
    2)  它調用了set(), create_door(), setup()，在代碼中卻沒有聲明。 
    3)  在第三行，既不是變量聲明也不是函數聲明，更不是函數定義。 
  這一章就是回答以下問題的： 
    1)  room::create()是什麼東西？ 
    2)  函數 set()，create_door()，在哪裡聲明、哪裡定義？ 
    3)  第三行是什麼東西？ 
 
                    第二節 面對對像編程(OOP)的繼承 
 
  繼承是面對對像編程的一個基本特性。它使你能寫一些基本的代碼能 
以不同的方式被不同的程序使用。一個 MudLib 做的就是創建一些基本 
的 Object ，在此基礎上你能用他們創建自己特殊的 Object。 
  如果不得不寫那些定義巫師工作室所必須的所有代碼，你可能要寫超 
過 1000 行的代碼，這樣你才可能有這個 room 所需要的所有函數。如果 
每個 room 都必須這麼做的話，首先是浪費硬盤空間；其次，你寫的代 
碼可能根本無法和別人的寫的代碼組合在一起，每個人對 room 擴展的 
特性的各種函數搞出每個人自己的標準。比如，你可能把 room 的長描 
述的接口函數叫做 GetLong()，別的巫師可能喜歡把它命名為 query_long()。 
這個就是各個 MudLib 不兼容的根本問題，因為它們 Object 相互繼承、 
調用上使用不同的協議。 
  OOP 能克服上面的問題。在上面的例子中，你直接使用的函數都定義 
在繼承的叫做 "/std/room.c" 的 Object 裡面了。它有所有那些 room 常 
用的函數的定義。當你寫創建一個特別的 room，你通過繼承得到 room 
的的基本的功能，通過加入你自己寫的函數，這樣就把它變成了一個獨 
特的 room 了。 
  OOP 通過繼承不只是提高了代碼的可重用性，而且它可以是你只關心 
繼承基本的 Object 後，那些特性需要改變的，而不用考慮那些東西是 
需要的，就是說當你看到別人寫好的 Object 時，發現已經很像你心中 
所想的東西，就只有一點點不符合，那你所要做只是繼承原先的 Object， 
然後加入和想的那一點點不同的東西就可以了。 
  OOP 當然不只是繼承，還有別的一些。但是對於我們現在是談論繼承 
的最基本的概念。 
 
                第三節 繼承是如何工作的？ 
 
  還記得最開始提的三個問題嗎？在這一節裡面，將解答這些問題。 
  首先最後一個問題： 
  例子中的第三行： 
----- 
inherit "/std/room"; 
----- 
是做什麼？ 
  我想到了現在，你應該你猜出來這一行確保你寫的巫師工作室繼承了 
標準的 room: "/std/room.c" 的特性。通過繼承獲得標準 room 的功能， 
你就可以使用那些已經在 "/std/room.c" 底下聲明和定義好的所有函數。 
這就是為什麼你可以直接使用 set(), create_door() 這些函數的原因了。 
在你自己寫的函數 create()，你只要設置那些你要的值就可以了。這些 
值使得你的 room 與眾不同，但確保和別的 Object 能相互作用。 
  那 room::create() 是做什麼的？ 
  你可能看到類似的東西比如： ::create()、::init()等。可能現在完全 
理解有些困難。你只要有個印像就可以了。 
  在你繼承的那些 Object 中，可能會有 create() 函數，但是在你寫的 
的 Object 中也有 create() 了，那麼 Driver 將只調用你寫 create() 來 
完成一些初始化工作，一般情況下這是你所希望的。可是，有時候，你 
發現你繼承的 Object，比如 /std/room.c 中的 create()，也是有用的， 
那怎辦？那麼你可以這麼做： 
    在你寫的 room 的 create() 當中加入 
 
----------------- 
    room::create(); 
----------------- 
 
這一行，"::"這個操作符加在一個函數 example() 的前面，那麼它就調 
用它繼承的 Object 中的那個函數，如果 "::"的前面沒有任何限定，那 
麼就調用所有繼承的當前的一級的 Object 中叫做 example() 的函數， 
如果有限定，那麼就只調用給定的 Object 的叫做 example() 的函數， 
在我們的例子就調用 /std/room.c 的 create() 函數。 
  "::"這個操作符，是用於調用繼承的 Object 一個特殊的函數。通常 
把 "::" 操作符叫做 域訪問操作符 。 
  一個對比例子： 
 
----- 
#1 
 
inherit "/std/room"; 
 
void create() 
{ 
    create(); 
} 
 
----- 
 
----- 
#2 
 
inherit "/std/room"; 
 
void create() 
{ 
    room::create(); 
} 
 
----- 
 
  例子 1 的後果是災難性的。當它被裝入內存中，Driver 調用 create()， 
接著 create() 調用 create()，create() 還接著調用 create()，如此往 
復永無窮盡。就是說，create() 持續不斷的調用自己，除非 Driver 發 
現這是一個太深的遞歸，將其強制退出。 
  例子 2 是對的，但是除了浪費內存之外沒有任何作用，因為它和 room.c 
的功能沒有區別。對於這個 Object，Driver 調用它的 create()，在它的 
create() 通過 room::create() 返回去調用 room.c 中的 create()。 
 
  總的來說，每個 MudLib 都是不同的，每個自己有一套標準函數的集 
合，它們對於一些基本的功能都能完成。有些功能特性多有些，有些少 
一些，有些在一些特殊方面完成特殊的工作，比如 Es2 帶了對中文的處 
理。但是如果這個 MudLib 如果比較完善的話，它一般要提供一些標準 
的 Object 的特性和功能的說明。一般可能在 "/doc/build" 底下，可能 
叫做 "room_prop"、"monster_prop" 等。看看這些，你會得到你繼承的 
Object 的有的函數，它們的輸入參數，返回的數據類型，以及能完成 
什麼工作。 
 
                    第四節  小結 
 
  實際上複雜對像的繼承是很複雜的，就這麼簡單解釋是遠遠不夠的。 
這篇簡介只是在你創建一些簡單的 Object 能使用繼承。更全面的討論 
我們將在 Lpc進階 裡面看到。 
  現在你應該知道： 
    1)  每個 MudLib 有自己的一套基本 Object 的庫，有著一些基本的 
        功能，巫師們通過繼承能更容易創建自己的 Object，不同的 
        Object 之間的交互作用也更容易一些。 
    2)  每個 MudLib 有自己一套標準。通常有自己一些文檔說明標準的 
        Object 是什麼，有什麼樣的功能。 
    3)  你可以用這樣繼承別的 Object 的功能： 
 
----- 
inherit "filename"; 
----- 
 
        這裡的 filename 是被繼承的 Object 的文件名。inherit "xxx" 
        要在你的寫的代碼的開頭部分。 