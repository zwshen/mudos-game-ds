通常　我們在PC-game裡會看到一種情況　當主角遇到一個事件時　整個
系統會停下來等候主角　或是遊戲裡的人永遠只有呆呆的站著　直到主角
去啟動他們　或是戰略遊戲中　我方全部攻擊完畢後才等敵方攻擊　很有
趣的是　這種與現實情況脫節的概念不但在遊戲世界大行其道　而且歷久
不衰　

    如果你還記得創世記系列裡的每一個人物　那最大的功臣末過於創世
記系列逼真的即時系統　所謂即時系統就是說　每個人物都會依據自己的
判斷以及對環境的變動做出反應　我們可以理解早期電腦的處理速度遠不
如現在　遊戲的制作技巧不如現在　要真的作出多工並非容易之事　但現
在的電腦設備以及程式技術都已今非昔比　對一個真的想寫出有內涵程式
的設技師來說　實在是頗值的考慮的一件事　

    對PC來說　單單一個 cpu要對動輒數百或數千個人或物作出處理　那
系統分給每一個人物的時間將微乎其微　例如程式要讓甲在吃飯同時　乙
和丙兩人開始戰鬥　如果是單純的將系統對每個人物處理　你會發現甲吃
一口飯之後　乙會打丙一下　丙會做出一點反應　很明顯的　這不是我們
所樂見的　


    另一種情況來說　我們希望看到甲和乙會對同一個事件做出不同反應
　例如甲看到地上有一個垃圾　會把他撿起來看一看　相對於乙　他確會
判別這是一個垃圾　而做出不理會或是將之拿到垃圾筒丟掉的情況出現　
這種情況當然可以用特殊的程式去指定　但對於有上千個這種人物　你將
會怎麼處理　



    我們開始探討這一個問題之前　要先將人物可能具備的一些個性區別
出來　



1.姓名
2.性別
3.年齡
4.編號
5.力量
6.智力
7.知識
8.敏捷度
9.體型或體格
10.狀態
11.情緒
12.影響
..
..
..

還有許多情況並不一一列出　我們只對這些做一個初步了解　

基本資料　
姓名　年齡和性別是各個不同人物(character)的基本資料　在這個部份中還
可以加入人物的肖像或是人物的圖片　如果你是要設計一個中文遊戲　最好是
要再加入英文的檢定ID(identify)　編號則是對人物做個有效管理　避免出現
天下大亂的情況　

先天情況　
有些遊戲會設定人物種族　而有些則設定人物屬性　但不管是什麼　都避免不
了每個人物的個別屬性　這種屬性又分先天後天的不同　有時我們是希望得到
人物的初始值　那這一點就很重要　通常可以考慮的情況有力量　智力　知識
　敏捷和體格(或體型)　其它如種族　人物職業(如果一開始就有不同職業)或
特性也在此類　

後天影響　
當人物得到一些物品或被施法(或是被打的頭昏腦漲)　因而影響了況先天屬性
等都是屬於後天影響　如前述之力量　智力　知識　敏捷和體格　甚至性別等
都可以列入這裡　至於使用的格式容後再敘　

即時情況　
這些資料則不停的變動　我們在處裡人物時也將不停得取得這些資料　例如人
物的清醒程度　進食狀況　情緒影響　目前情況等　取得這些資料可以幫助我
們進一步的處理人物個性　

我們將這些資料整理成一個結構　
struct  char_data
{
    char *              name;                英文鋻別id
    char       cname[MAX_INPUT_LENGTH];      中文名稱
    int                 sex;                 性別
    int         class;                       職業
    int             position;                目前情況
    int                 max_hit;             最大生命點數
    int                 mana;                精神力
    int                 max_mana;            最大精神力
    int                 move;                體力
    int                 max_move;            最大體力
    int                 perm_str;            基本力量
    int         perm_int;                    基本智力
    int         perm_wis;                    基本知識
    int         perm_dex;                    基本敏捷
    int             perm_con;                基本體格
    int             mod_str;                 改變力量
    int             mod_int;                 改變智力
    int             mod_wis;                 改變知識
    int             mod_dex;                 改變敏捷
    int             mod_con;                 改變體格
    int                 gold;                金錢
    int                 exp;                 經驗
    int                 act;                 目前動作
    int         affected_by;                 目前影響
    int                 hungry;              肌餓程度
};


這樣的一個格式當然不能完全表達一個人物的個性　如果真要實作的話
必須要完全仔細的考慮每一個項目　但目前我們只用這一個簡單的格式
來繼續討論下去　

我們要讓系統對每一個人物有同樣的處理(完全均分系統是絕對不智的處
理　這點容後再敘)　所以系統的處理常常是樹狀的　


         ┌人物一
         ├人物二
         ├  •
         ├  •
   系統─┼  •
         ├  •
         ├  •
         ├  •
         └  •

這種處理方法當然不能說不好　但是問題是在於如果有其中一個人物被消滅了　
那系統的處理便難以處理　其次的問題是系統必須記住那麼多資料的位址　如果
是資料固定還好　指標還很容易找到　一旦我們的資料有不定長度　記憶體位址
勢必天下大亂　而且如果人物不斷增長下去　我們該如何定位出一個適當的指標
　所以我們換一個資料處理方法　

　　系統─人物一
            ︱
        　人物二
        　　︱
        　人物三
        　　︱
        　人物四
        　　•
　　　　　　•
        　　•
            •

這種資料處理的方法就是用人物一的指標之一去指向人物二•••

做法是將人物的結構加上
struct  char_data
{
    CHAR        next;      ***將指標指向下一個人物***

    char *              name;                英文鋻別id
    char       cname[MAX_INPUT_LENGTH];      中文名稱
    int                 sex;                 性別
    int         class;                       職業
    int             position;                目前情況
    int                 hit;                 生命點數
    int                 max_hit;             最大生命點數
    int                 mana;                精神力
    .
    .
    .
    .
CHAR 是struct char_data的宣告　我們用這個指標去指向下一個人物　
處理的方法如下　
 CHAR * TempCh;
 for ( TempCh = ch; TempCh != NULL ; TempCh=TempCh->next )
     {
     .................
     .................
     }


這種方法可以讓我們對所有的CHAR都處理一遍　而不會有漏掉　
在新增人物時　則將新人物的next指向第一個CHAR...........
刪除其中一個人物時　則將指向刪除人物的指標指向下一個人物　然後將
記憶體釋放掉即可　
