<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;Ranma&nbsp;(亂馬~~~~~~~無聊中),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Lpc&nbsp;intermediate&nbsp;(3)--Complex&nbsp;Data&nbsp;Types&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Mon&nbsp;Oct&nbsp;20&nbsp;09:14:41&nbsp;1997)&nbsp;<BR>
&nbsp;<BR>
Intermediate&nbsp;LPC&nbsp;<BR>
Descartes&nbsp;of&nbsp;Borg&nbsp;<BR>
November&nbsp;1993&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chapter&nbsp;3:&nbsp;Complex&nbsp;Data&nbsp;Types&nbsp;<BR>
&nbsp;<BR>
3.1&nbsp;Simple&nbsp;Data&nbsp;Types&nbsp;<BR>
In&nbsp;the&nbsp;textbook&nbsp;LPC&nbsp;Basics,&nbsp;you&nbsp;learned&nbsp;about&nbsp;the&nbsp;common,&nbsp;basic&nbsp;LPC&nbsp;<BR>
data&nbsp;types:&nbsp;int,&nbsp;string,&nbsp;object,&nbsp;void.&nbsp;&nbsp;Most&nbsp;important&nbsp;you&nbsp;learned&nbsp;that&nbsp;<BR>
many&nbsp;operations&nbsp;and&nbsp;functions&nbsp;behave&nbsp;differently&nbsp;based&nbsp;on&nbsp;the&nbsp;data&nbsp;type&nbsp;<BR>
of&nbsp;the&nbsp;variables&nbsp;upon&nbsp;which&nbsp;they&nbsp;are&nbsp;operating.&nbsp;&nbsp;Some&nbsp;operators&nbsp;and&nbsp;<BR>
functions&nbsp;will&nbsp;even&nbsp;give&nbsp;errors&nbsp;if&nbsp;you&nbsp;use&nbsp;them&nbsp;with&nbsp;the&nbsp;wrong&nbsp;data&nbsp;<BR>
types.&nbsp;&nbsp;For&nbsp;example,&nbsp;&quot;a&quot;+&quot;b&quot;&nbsp;is&nbsp;handled&nbsp;much&nbsp;differently&nbsp;than&nbsp;1+1.&nbsp;&nbsp;<BR>
When&nbsp;you&nbsp;ass&nbsp;&quot;a&quot;+&quot;b&quot;,&nbsp;you&nbsp;are&nbsp;adding&nbsp;&quot;b&quot;&nbsp;onto&nbsp;the&nbsp;end&nbsp;of&nbsp;&quot;a&quot;&nbsp;to&nbsp;get&nbsp;<BR>
&quot;ab&quot;.&nbsp;&nbsp;On&nbsp;the&nbsp;other&nbsp;hand,&nbsp;when&nbsp;you&nbsp;add&nbsp;1+1,&nbsp;you&nbsp;do&nbsp;not&nbsp;get&nbsp;11,&nbsp;you&nbsp;get&nbsp;<BR>
2&nbsp;as&nbsp;you&nbsp;would&nbsp;expect.&nbsp;<BR>
&nbsp;<BR>
I&nbsp;refer&nbsp;to&nbsp;these&nbsp;data&nbsp;types&nbsp;as&nbsp;simple&nbsp;data&nbsp;types,&nbsp;because&nbsp;they&nbsp;atomic&nbsp;in&nbsp;<BR>
that&nbsp;they&nbsp;cannot&nbsp;be&nbsp;broken&nbsp;down&nbsp;into&nbsp;smaller&nbsp;component&nbsp;data&nbsp;types.&nbsp;&nbsp;<BR>
The&nbsp;object&nbsp;data&nbsp;type&nbsp;is&nbsp;a&nbsp;sort&nbsp;of&nbsp;exception,&nbsp;but&nbsp;you&nbsp;really&nbsp;cannot&nbsp;refer&nbsp;<BR>
individually&nbsp;to&nbsp;the&nbsp;components&nbsp;which&nbsp;make&nbsp;it&nbsp;up,&nbsp;so&nbsp;I&nbsp;refer&nbsp;to&nbsp;it&nbsp;as&nbsp;a&nbsp;<BR>
simple&nbsp;data&nbsp;type.&nbsp;<BR>
&nbsp;<BR>
This&nbsp;chapter&nbsp;introduces&nbsp;the&nbsp;concept&nbsp;of&nbsp;the&nbsp;complex&nbsp;data&nbsp;type,&nbsp;a&nbsp;data&nbsp;type&nbsp;<BR>
which&nbsp;is&nbsp;made&nbsp;up&nbsp;of&nbsp;units&nbsp;of&nbsp;simple&nbsp;data&nbsp;types.&nbsp;&nbsp;LPC&nbsp;has&nbsp;two&nbsp;common&nbsp;<BR>
complex&nbsp;data&nbsp;types,&nbsp;both&nbsp;kinds&nbsp;of&nbsp;arrays.&nbsp;&nbsp;First,&nbsp;there&nbsp;is&nbsp;the&nbsp;traditional&nbsp;<BR>
array&nbsp;which&nbsp;stores&nbsp;values&nbsp;in&nbsp;consecutive&nbsp;elements&nbsp;accessed&nbsp;by&nbsp;a&nbsp;number&nbsp;<BR>
representing&nbsp;which&nbsp;element&nbsp;they&nbsp;are&nbsp;stored&nbsp;in.&nbsp;&nbsp;Second&nbsp;is&nbsp;an&nbsp;associative&nbsp;<BR>
array&nbsp;called&nbsp;a&nbsp;mapping.&nbsp;&nbsp;A&nbsp;mapping&nbsp;associates&nbsp;to&nbsp;values&nbsp;together&nbsp;to&nbsp;<BR>
allow&nbsp;a&nbsp;more&nbsp;natural&nbsp;access&nbsp;to&nbsp;data.&nbsp;<BR>
&nbsp;<BR>
3.2&nbsp;The&nbsp;Values&nbsp;NULL&nbsp;and&nbsp;0&nbsp;<BR>
Before&nbsp;getting&nbsp;fully&nbsp;into&nbsp;arrays,&nbsp;there&nbsp;first&nbsp;should&nbsp;be&nbsp;a&nbsp;full&nbsp;understanding&nbsp;<BR>
of&nbsp;the&nbsp;concept&nbsp;of&nbsp;NULL&nbsp;versus&nbsp;the&nbsp;concept&nbsp;of&nbsp;0.&nbsp;&nbsp;In&nbsp;LPC,&nbsp;a&nbsp;null&nbsp;value&nbsp;is&nbsp;<BR>
represented&nbsp;by&nbsp;the&nbsp;integer&nbsp;0.&nbsp;&nbsp;Although&nbsp;the&nbsp;integer&nbsp;0&nbsp;and&nbsp;NULL&nbsp;are&nbsp;often&nbsp;<BR>
freely&nbsp;interchangeable,&nbsp;this&nbsp;interchangeability&nbsp;often&nbsp;leads&nbsp;to&nbsp;some&nbsp;great&nbsp;<BR>
confusion&nbsp;when&nbsp;you&nbsp;get&nbsp;into&nbsp;the&nbsp;realm&nbsp;of&nbsp;complex&nbsp;data&nbsp;types.&nbsp;&nbsp;You&nbsp;may&nbsp;<BR>
have&nbsp;even&nbsp;encountered&nbsp;such&nbsp;confusion&nbsp;while&nbsp;using&nbsp;strings.&nbsp;<BR>
&nbsp;<BR>
0&nbsp;represents&nbsp;a&nbsp;value&nbsp;which&nbsp;for&nbsp;integers&nbsp;means&nbsp;the&nbsp;value&nbsp;you&nbsp;add&nbsp;to&nbsp;<BR>
another&nbsp;value&nbsp;yet&nbsp;still&nbsp;retain&nbsp;the&nbsp;value&nbsp;added.&nbsp;&nbsp;This&nbsp;for&nbsp;any&nbsp;addition&nbsp;<BR>
operation&nbsp;on&nbsp;any&nbsp;data&nbsp;type,&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;for&nbsp;that&nbsp;data&nbsp;type&nbsp;is&nbsp;the&nbsp;value&nbsp;<BR>
that&nbsp;you&nbsp;can&nbsp;add&nbsp;to&nbsp;any&nbsp;other&nbsp;value&nbsp;and&nbsp;get&nbsp;the&nbsp;original&nbsp;value.&nbsp;&nbsp;Thus:&nbsp;&nbsp;&nbsp;A&nbsp;<BR>
plus&nbsp;ZERO&nbsp;equals&nbsp;A&nbsp;where&nbsp;A&nbsp;is&nbsp;some&nbsp;value&nbsp;of&nbsp;a&nbsp;given&nbsp;data&nbsp;type&nbsp;and&nbsp;<BR>
ZERO&nbsp;is&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;for&nbsp;that&nbsp;data&nbsp;type.&nbsp;&nbsp;This&nbsp;is&nbsp;not&nbsp;any&nbsp;sort&nbsp;of&nbsp;<BR>
official&nbsp;mathematical&nbsp;definition.&nbsp;&nbsp;There&nbsp;exists&nbsp;one,&nbsp;but&nbsp;I&nbsp;am&nbsp;not&nbsp;a&nbsp;<BR>
mathematician,&nbsp;so&nbsp;I&nbsp;have&nbsp;no&nbsp;idea&nbsp;what&nbsp;the&nbsp;term&nbsp;is.&nbsp;&nbsp;Thus&nbsp;for&nbsp;integers,&nbsp;0&nbsp;<BR>
is&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;since&nbsp;1&nbsp;+&nbsp;0&nbsp;equals&nbsp;1.&nbsp;<BR>
&nbsp;<BR>
NULL,&nbsp;on&nbsp;the&nbsp;other&nbsp;hand,&nbsp;is&nbsp;the&nbsp;absence&nbsp;of&nbsp;any&nbsp;value&nbsp;or&nbsp;meaning.&nbsp;&nbsp;The&nbsp;<BR>
LPC&nbsp;driver&nbsp;will&nbsp;interpret&nbsp;NULL&nbsp;as&nbsp;an&nbsp;integer&nbsp;0&nbsp;if&nbsp;it&nbsp;can&nbsp;make&nbsp;sense&nbsp;of&nbsp;it&nbsp;<BR>
in&nbsp;that&nbsp;context.&nbsp;&nbsp;In&nbsp;any&nbsp;context&nbsp;besides&nbsp;integer&nbsp;addition,&nbsp;A&nbsp;plus&nbsp;NULL&nbsp;<BR>
causes&nbsp;an&nbsp;error.&nbsp;&nbsp;NULL&nbsp;causes&nbsp;an&nbsp;error&nbsp;because&nbsp;adding&nbsp;valueless&nbsp;fields&nbsp;<BR>
in&nbsp;other&nbsp;data&nbsp;types&nbsp;to&nbsp;those&nbsp;data&nbsp;types&nbsp;makes&nbsp;no&nbsp;sense.&nbsp;<BR>
&nbsp;<BR>
Looking&nbsp;at&nbsp;this&nbsp;from&nbsp;another&nbsp;point&nbsp;of&nbsp;view,&nbsp;we&nbsp;can&nbsp;get&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;<BR>
for&nbsp;strings&nbsp;by&nbsp;knowing&nbsp;what&nbsp;added&nbsp;to&nbsp;&quot;a&quot;&nbsp;will&nbsp;give&nbsp;us&nbsp;&quot;a&quot;&nbsp;as&nbsp;a&nbsp;result.&nbsp;&nbsp;<BR>
The&nbsp;answer&nbsp;is&nbsp;not&nbsp;0,&nbsp;but&nbsp;instead&nbsp;&quot;&quot;.&nbsp;&nbsp;With&nbsp;integers,&nbsp;interchanging&nbsp;NULL&nbsp;<BR>
and&nbsp;0&nbsp;was&nbsp;acceptable&nbsp;since&nbsp;0&nbsp;represents&nbsp;no&nbsp;value&nbsp;with&nbsp;respect&nbsp;to&nbsp;the&nbsp;<BR>
integer&nbsp;data&nbsp;type.&nbsp;&nbsp;This&nbsp;interchangeability&nbsp;is&nbsp;not&nbsp;true&nbsp;for&nbsp;other&nbsp;data&nbsp;types,&nbsp;<BR>
since&nbsp;their&nbsp;ZERO&nbsp;values&nbsp;do&nbsp;not&nbsp;represent&nbsp;no&nbsp;value.&nbsp;&nbsp;Namely,&nbsp;&quot;&quot;&nbsp;<BR>
represents&nbsp;a&nbsp;string&nbsp;of&nbsp;no&nbsp;length&nbsp;and&nbsp;is&nbsp;very&nbsp;different&nbsp;from&nbsp;0.&nbsp;&nbsp;&nbsp;<BR>
&nbsp;<BR>
When&nbsp;you&nbsp;first&nbsp;declare&nbsp;any&nbsp;variable&nbsp;of&nbsp;any&nbsp;type,&nbsp;it&nbsp;has&nbsp;no&nbsp;value.&nbsp;&nbsp;Any&nbsp;<BR>
data&nbsp;type&nbsp;except&nbsp;integers&nbsp;therefore&nbsp;must&nbsp;be&nbsp;initialized&nbsp;somehow&nbsp;before&nbsp;<BR>
you&nbsp;perform&nbsp;any&nbsp;operation&nbsp;on&nbsp;it.&nbsp;&nbsp;Generally,&nbsp;initialization&nbsp;is&nbsp;done&nbsp;in&nbsp;the&nbsp;<BR>
create()&nbsp;function&nbsp;for&nbsp;global&nbsp;variables,&nbsp;or&nbsp;at&nbsp;the&nbsp;top&nbsp;of&nbsp;the&nbsp;local&nbsp;function&nbsp;<BR>
for&nbsp;local&nbsp;variables&nbsp;by&nbsp;assigning&nbsp;them&nbsp;some&nbsp;value,&nbsp;often&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;<BR>
for&nbsp;that&nbsp;data&nbsp;type.&nbsp;&nbsp;For&nbsp;example,&nbsp;in&nbsp;the&nbsp;following&nbsp;code&nbsp;I&nbsp;want&nbsp;to&nbsp;build&nbsp;a&nbsp;<BR>
string&nbsp;with&nbsp;random&nbsp;words:&nbsp;<BR>
&nbsp;<BR>
string&nbsp;build_nonsense()&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;str;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;&quot;&quot;;&nbsp;/*&nbsp;Here&nbsp;str&nbsp;is&nbsp;initialized&nbsp;to&nbsp;the&nbsp;string&nbsp;<BR>
ZERO&nbsp;value&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;for(i=0;&nbsp;i&lt;6;&nbsp;i++)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(random(3)+1)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:&nbsp;str&nbsp;+=&nbsp;&quot;bing&quot;;&nbsp;break;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:&nbsp;str&nbsp;+=&nbsp;&quot;borg&quot;;&nbsp;break;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;3:&nbsp;str&nbsp;+=&nbsp;&quot;foo&quot;;&nbsp;break;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i==5)&nbsp;str&nbsp;+=&nbsp;&quot;.\n&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;str&nbsp;+=&nbsp;&quot;&nbsp;&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;capitalize(str);&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
If&nbsp;we&nbsp;had&nbsp;not&nbsp;initialized&nbsp;the&nbsp;variable&nbsp;str,&nbsp;an&nbsp;error&nbsp;would&nbsp;have&nbsp;resulted&nbsp;<BR>
from&nbsp;trying&nbsp;to&nbsp;add&nbsp;a&nbsp;string&nbsp;to&nbsp;a&nbsp;NULL&nbsp;value.&nbsp;&nbsp;Instead,&nbsp;this&nbsp;code&nbsp;first&nbsp;<BR>
initializes&nbsp;str&nbsp;to&nbsp;the&nbsp;ZERO&nbsp;value&nbsp;for&nbsp;strings,&nbsp;&quot;&quot;.&nbsp;&nbsp;After&nbsp;that,&nbsp;it&nbsp;enters&nbsp;a&nbsp;<BR>
loop&nbsp;which&nbsp;makes&nbsp;6&nbsp;cycles,&nbsp;each&nbsp;time&nbsp;randomly&nbsp;adding&nbsp;one&nbsp;of&nbsp;three&nbsp;<BR>
possible&nbsp;words&nbsp;to&nbsp;the&nbsp;string.&nbsp;&nbsp;For&nbsp;all&nbsp;words&nbsp;except&nbsp;the&nbsp;last,&nbsp;an&nbsp;additional&nbsp;<BR>
blank&nbsp;character&nbsp;is&nbsp;added.&nbsp;&nbsp;For&nbsp;the&nbsp;last&nbsp;word,&nbsp;a&nbsp;period&nbsp;and&nbsp;a&nbsp;return&nbsp;<BR>
character&nbsp;are&nbsp;added.&nbsp;&nbsp;The&nbsp;function&nbsp;then&nbsp;exits&nbsp;the&nbsp;loop,&nbsp;capitalizes&nbsp;the&nbsp;<BR>
nonsense&nbsp;string,&nbsp;then&nbsp;exits.&nbsp;<BR>
&nbsp;<BR>
3.3&nbsp;Arrays&nbsp;in&nbsp;LPC&nbsp;<BR>
An&nbsp;array&nbsp;is&nbsp;a&nbsp;powerful&nbsp;complex&nbsp;data&nbsp;type&nbsp;of&nbsp;LPC&nbsp;which&nbsp;allows&nbsp;you&nbsp;to&nbsp;<BR>
access&nbsp;multiple&nbsp;values&nbsp;through&nbsp;a&nbsp;single&nbsp;variable.&nbsp;&nbsp;For&nbsp;instance,&nbsp;<BR>
Nightmare&nbsp;has&nbsp;an&nbsp;indefinite&nbsp;number&nbsp;of&nbsp;currencies&nbsp;in&nbsp;which&nbsp;players&nbsp;may&nbsp;<BR>
do&nbsp;business.&nbsp;&nbsp;Only&nbsp;five&nbsp;of&nbsp;those&nbsp;currencies,&nbsp;however,&nbsp;can&nbsp;be&nbsp;considered&nbsp;<BR>
hard&nbsp;currencies.&nbsp;&nbsp;A&nbsp;hard&nbsp;currency&nbsp;for&nbsp;the&nbsp;sake&nbsp;of&nbsp;this&nbsp;example&nbsp;is&nbsp;a&nbsp;<BR>
currency&nbsp;which&nbsp;is&nbsp;readily&nbsp;exchangeable&nbsp;for&nbsp;any&nbsp;other&nbsp;hard&nbsp;currency,&nbsp;<BR>
whereas&nbsp;a&nbsp;soft&nbsp;currency&nbsp;may&nbsp;only&nbsp;be&nbsp;bought,&nbsp;but&nbsp;not&nbsp;sold.&nbsp;&nbsp;In&nbsp;the&nbsp;bank,&nbsp;<BR>
there&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;hard&nbsp;currencies&nbsp;to&nbsp;allow&nbsp;bank&nbsp;keepers&nbsp;to&nbsp;know&nbsp;which&nbsp;<BR>
currencies&nbsp;are&nbsp;in&nbsp;fact&nbsp;hard&nbsp;currencies.&nbsp;&nbsp;With&nbsp;simple&nbsp;data&nbsp;types,&nbsp;we&nbsp;would&nbsp;<BR>
have&nbsp;to&nbsp;perform&nbsp;the&nbsp;following&nbsp;nasty&nbsp;operation&nbsp;for&nbsp;every&nbsp;exchange&nbsp;<BR>
transaction:&nbsp;<BR>
&nbsp;<BR>
int&nbsp;exchange(string&nbsp;str)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;from,&nbsp;to;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;amt;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!str)&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(sscanf(str,&nbsp;&quot;%d&nbsp;%s&nbsp;for&nbsp;%s&quot;,&nbsp;amt,&nbsp;from,&nbsp;to)&nbsp;!=&nbsp;3)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(from&nbsp;!=&nbsp;&quot;platinum&quot;&nbsp;&amp;&amp;&nbsp;from&nbsp;!=&nbsp;&quot;gold&quot;&nbsp;&amp;&amp;&nbsp;from&nbsp;!=&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;silver&quot;&nbsp;&amp;&amp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;!=&nbsp;&quot;electrum&quot;&nbsp;&amp;&amp;&nbsp;from&nbsp;!=&nbsp;&quot;copper&quot;)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify_fail(&quot;We&nbsp;do&nbsp;not&nbsp;buy&nbsp;soft&nbsp;currencies!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
With&nbsp;five&nbsp;hard&nbsp;currencies,&nbsp;we&nbsp;have&nbsp;a&nbsp;rather&nbsp;simple&nbsp;example.&nbsp;&nbsp;After&nbsp;all&nbsp;it&nbsp;<BR>
took&nbsp;only&nbsp;two&nbsp;lines&nbsp;of&nbsp;code&nbsp;to&nbsp;represent&nbsp;the&nbsp;if&nbsp;statement&nbsp;which&nbsp;filtered&nbsp;<BR>
out&nbsp;bad&nbsp;currencies.&nbsp;&nbsp;But&nbsp;what&nbsp;if&nbsp;you&nbsp;had&nbsp;to&nbsp;check&nbsp;against&nbsp;all&nbsp;the&nbsp;names&nbsp;<BR>
which&nbsp;cannot&nbsp;be&nbsp;used&nbsp;to&nbsp;make&nbsp;characters&nbsp;in&nbsp;the&nbsp;game?&nbsp;&nbsp;There&nbsp;might&nbsp;be&nbsp;<BR>
100&nbsp;of&nbsp;those;&nbsp;would&nbsp;you&nbsp;want&nbsp;to&nbsp;write&nbsp;a&nbsp;100&nbsp;part&nbsp;if&nbsp;statement?&nbsp;<BR>
What&nbsp;if&nbsp;you&nbsp;wanted&nbsp;to&nbsp;add&nbsp;a&nbsp;currency&nbsp;to&nbsp;the&nbsp;list&nbsp;of&nbsp;hard&nbsp;currencies?&nbsp;&nbsp;That&nbsp;<BR>
means&nbsp;you&nbsp;would&nbsp;have&nbsp;to&nbsp;change&nbsp;every&nbsp;check&nbsp;in&nbsp;the&nbsp;game&nbsp;for&nbsp;hard&nbsp;<BR>
currencies&nbsp;to&nbsp;add&nbsp;one&nbsp;more&nbsp;part&nbsp;to&nbsp;the&nbsp;if&nbsp;clauses.&nbsp;&nbsp;Arrays&nbsp;allow&nbsp;you&nbsp;<BR>
simple&nbsp;access&nbsp;to&nbsp;groups&nbsp;of&nbsp;related&nbsp;data&nbsp;so&nbsp;that&nbsp;you&nbsp;do&nbsp;not&nbsp;have&nbsp;to&nbsp;deal&nbsp;<BR>
with&nbsp;each&nbsp;individual&nbsp;value&nbsp;every&nbsp;time&nbsp;you&nbsp;want&nbsp;to&nbsp;perform&nbsp;a&nbsp;group&nbsp;<BR>
operation.&nbsp;<BR>
&nbsp;<BR>
As&nbsp;a&nbsp;constant,&nbsp;an&nbsp;array&nbsp;might&nbsp;look&nbsp;like&nbsp;this:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;({&nbsp;&quot;platinum&quot;,&nbsp;&quot;gold&quot;,&nbsp;&quot;silver&quot;,&nbsp;&quot;electrum&quot;,&nbsp;&quot;copper&quot;&nbsp;})&nbsp;<BR>
which&nbsp;is&nbsp;an&nbsp;array&nbsp;of&nbsp;type&nbsp;string.&nbsp;&nbsp;Individual&nbsp;data&nbsp;values&nbsp;in&nbsp;arrays&nbsp;are&nbsp;<BR>
called&nbsp;elements,&nbsp;or&nbsp;sometimes&nbsp;members.&nbsp;&nbsp;In&nbsp;code,&nbsp;just&nbsp;as&nbsp;constant&nbsp;<BR>
strings&nbsp;are&nbsp;represented&nbsp;by&nbsp;surrounding&nbsp;them&nbsp;with&nbsp;&quot;&quot;,&nbsp;constant&nbsp;arrays&nbsp;are&nbsp;<BR>
represented&nbsp;by&nbsp;being&nbsp;surrounded&nbsp;by&nbsp;({&nbsp;}),&nbsp;with&nbsp;individual&nbsp;elements&nbsp;of&nbsp;<BR>
the&nbsp;array&nbsp;being&nbsp;separated&nbsp;by&nbsp;a&nbsp;,.&nbsp;<BR>
&nbsp;<BR>
You&nbsp;may&nbsp;have&nbsp;arrays&nbsp;of&nbsp;any&nbsp;LPC&nbsp;data&nbsp;type,&nbsp;simple&nbsp;or&nbsp;complex.&nbsp;&nbsp;Arrays&nbsp;<BR>
made&nbsp;up&nbsp;of&nbsp;mixes&nbsp;of&nbsp;values&nbsp;are&nbsp;called&nbsp;arrays&nbsp;of&nbsp;mixed&nbsp;type.&nbsp;&nbsp;In&nbsp;most&nbsp;<BR>
LPC&nbsp;drivers,&nbsp;you&nbsp;declare&nbsp;an&nbsp;array&nbsp;using&nbsp;a&nbsp;throw-back&nbsp;to&nbsp;C&nbsp;language&nbsp;<BR>
syntax&nbsp;for&nbsp;arrays.&nbsp;&nbsp;This&nbsp;syntax&nbsp;is&nbsp;often&nbsp;confusing&nbsp;for&nbsp;LPC&nbsp;coders&nbsp;<BR>
because&nbsp;the&nbsp;syntax&nbsp;has&nbsp;a&nbsp;meaning&nbsp;in&nbsp;C&nbsp;that&nbsp;simply&nbsp;does&nbsp;not&nbsp;translate&nbsp;into&nbsp;<BR>
LPC.&nbsp;&nbsp;Nevertheless,&nbsp;if&nbsp;we&nbsp;wanted&nbsp;an&nbsp;array&nbsp;of&nbsp;type&nbsp;string,&nbsp;we&nbsp;would&nbsp;<BR>
declare&nbsp;it&nbsp;in&nbsp;the&nbsp;following&nbsp;manner:&nbsp;<BR>
&nbsp;<BR>
string&nbsp;*arr;&nbsp;<BR>
&nbsp;<BR>
In&nbsp;other&nbsp;words,&nbsp;the&nbsp;data&nbsp;type&nbsp;of&nbsp;the&nbsp;elements&nbsp;it&nbsp;will&nbsp;contain&nbsp;followed&nbsp;by&nbsp;<BR>
a&nbsp;space&nbsp;and&nbsp;an&nbsp;asterisk.&nbsp;&nbsp;Remember,&nbsp;however,&nbsp;that&nbsp;this&nbsp;newly&nbsp;declared&nbsp;<BR>
string&nbsp;array&nbsp;has&nbsp;a&nbsp;NULL&nbsp;value&nbsp;in&nbsp;it&nbsp;at&nbsp;the&nbsp;time&nbsp;of&nbsp;declaration.&nbsp;<BR>
&nbsp;<BR>
3.4&nbsp;Using&nbsp;Arrays&nbsp;<BR>
You&nbsp;now&nbsp;should&nbsp;understand&nbsp;how&nbsp;to&nbsp;declare&nbsp;and&nbsp;recognize&nbsp;an&nbsp;array&nbsp;in&nbsp;<BR>
code.&nbsp;&nbsp;In&nbsp;order&nbsp;to&nbsp;understand&nbsp;how&nbsp;they&nbsp;work&nbsp;in&nbsp;code,&nbsp;let's&nbsp;review&nbsp;the&nbsp;<BR>
bank&nbsp;code,&nbsp;this&nbsp;time&nbsp;using&nbsp;arrays:&nbsp;<BR>
&nbsp;<BR>
string&nbsp;*hard_currencies;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;exchange(string&nbsp;str)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;from,&nbsp;to;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;amt;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!str)&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(sscanf(str,&nbsp;&quot;%d&nbsp;%s&nbsp;for&nbsp;%s&quot;,&nbsp;amt,&nbsp;from,&nbsp;to)&nbsp;!=&nbsp;3)&nbsp;<BR>
return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(member_array(from,&nbsp;hard_currencies)&nbsp;==&nbsp;-1)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notify_fail(&quot;We&nbsp;do&nbsp;not&nbsp;buy&nbsp;soft&nbsp;currencies!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
This&nbsp;code&nbsp;assumes&nbsp;hard_currencies&nbsp;is&nbsp;a&nbsp;global&nbsp;variable&nbsp;and&nbsp;is&nbsp;initialized&nbsp;<BR>
in&nbsp;create()&nbsp;as:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hard_currencies&nbsp;=&nbsp;({&nbsp;&quot;platinum&quot;,&nbsp;&quot;gold&quot;,&nbsp;&quot;electrum&quot;,&nbsp;&quot;silver&quot;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&quot;copper&quot;&nbsp;});&nbsp;<BR>
Ideally,&nbsp;you&nbsp;would&nbsp;have&nbsp;hard&nbsp;currencies&nbsp;as&nbsp;a&nbsp;#define&nbsp;in&nbsp;a&nbsp;header&nbsp;file&nbsp;for&nbsp;<BR>
all&nbsp;objects&nbsp;to&nbsp;use,&nbsp;but&nbsp;#define&nbsp;is&nbsp;a&nbsp;topic&nbsp;for&nbsp;a&nbsp;later&nbsp;chapter.&nbsp;<BR>
&nbsp;<BR>
Once&nbsp;you&nbsp;know&nbsp;what&nbsp;the&nbsp;member_array()&nbsp;efun&nbsp;does,&nbsp;this&nbsp;method&nbsp;<BR>
certainly&nbsp;is&nbsp;much&nbsp;easier&nbsp;to&nbsp;read&nbsp;as&nbsp;well&nbsp;as&nbsp;is&nbsp;much&nbsp;more&nbsp;efficient&nbsp;and&nbsp;<BR>
easier&nbsp;to&nbsp;code.&nbsp;&nbsp;In&nbsp;fact,&nbsp;you&nbsp;can&nbsp;probably&nbsp;guess&nbsp;what&nbsp;the&nbsp;<BR>
member_array()&nbsp;efun&nbsp;does:&nbsp;&nbsp;It&nbsp;tells&nbsp;you&nbsp;if&nbsp;a&nbsp;given&nbsp;value&nbsp;is&nbsp;a&nbsp;member&nbsp;of&nbsp;<BR>
the&nbsp;array&nbsp;in&nbsp;question.&nbsp;&nbsp;Specifically&nbsp;here,&nbsp;we&nbsp;want&nbsp;to&nbsp;know&nbsp;if&nbsp;the&nbsp;currency&nbsp;<BR>
the&nbsp;player&nbsp;is&nbsp;trying&nbsp;to&nbsp;sell&nbsp;is&nbsp;an&nbsp;element&nbsp;in&nbsp;the&nbsp;hard_curencies&nbsp;array.&nbsp;&nbsp;<BR>
What&nbsp;might&nbsp;be&nbsp;confusing&nbsp;to&nbsp;you&nbsp;is,&nbsp;not&nbsp;only&nbsp;does&nbsp;member_array()&nbsp;tell&nbsp;us&nbsp;<BR>
if&nbsp;the&nbsp;value&nbsp;is&nbsp;an&nbsp;element&nbsp;in&nbsp;the&nbsp;array,&nbsp;but&nbsp;it&nbsp;in&nbsp;fact&nbsp;tells&nbsp;us&nbsp;which&nbsp;element&nbsp;<BR>
of&nbsp;the&nbsp;array&nbsp;the&nbsp;value&nbsp;is.&nbsp;<BR>
&nbsp;<BR>
How&nbsp;does&nbsp;it&nbsp;tell&nbsp;you&nbsp;which&nbsp;element?&nbsp;&nbsp;It&nbsp;is&nbsp;easier&nbsp;to&nbsp;understand&nbsp;arrays&nbsp;if&nbsp;<BR>
you&nbsp;think&nbsp;of&nbsp;the&nbsp;array&nbsp;variable&nbsp;as&nbsp;holding&nbsp;a&nbsp;number.&nbsp;&nbsp;In&nbsp;the&nbsp;value&nbsp;above,&nbsp;<BR>
for&nbsp;the&nbsp;sake&nbsp;of&nbsp;argument,&nbsp;we&nbsp;will&nbsp;say&nbsp;that&nbsp;hard_currencies&nbsp;holds&nbsp;the&nbsp;<BR>
value&nbsp;179000.&nbsp;&nbsp;This&nbsp;value&nbsp;tells&nbsp;the&nbsp;driver&nbsp;where&nbsp;to&nbsp;look&nbsp;for&nbsp;the&nbsp;array&nbsp;<BR>
hard_currencies&nbsp;represents.&nbsp;&nbsp;Thus,&nbsp;hard_currencies&nbsp;points&nbsp;to&nbsp;a&nbsp;place&nbsp;<BR>
where&nbsp;the&nbsp;array&nbsp;values&nbsp;may&nbsp;be&nbsp;found.&nbsp;&nbsp;When&nbsp;someone&nbsp;is&nbsp;talking&nbsp;about&nbsp;<BR>
the&nbsp;first&nbsp;element&nbsp;of&nbsp;the&nbsp;array,&nbsp;they&nbsp;want&nbsp;the&nbsp;element&nbsp;located&nbsp;at&nbsp;179000.&nbsp;&nbsp;<BR>
When&nbsp;the&nbsp;object&nbsp;needs&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;second&nbsp;element&nbsp;of&nbsp;the&nbsp;array,&nbsp;it&nbsp;<BR>
looks&nbsp;at&nbsp;179000&nbsp;+&nbsp;one&nbsp;value,&nbsp;then&nbsp;179000&nbsp;plus&nbsp;two&nbsp;values&nbsp;for&nbsp;the&nbsp;third,&nbsp;<BR>
and&nbsp;so&nbsp;on.&nbsp;&nbsp;We&nbsp;can&nbsp;therefore&nbsp;access&nbsp;individual&nbsp;elements&nbsp;of&nbsp;an&nbsp;array&nbsp;by&nbsp;<BR>
their&nbsp;index,&nbsp;which&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;values&nbsp;beyond&nbsp;the&nbsp;starting&nbsp;point&nbsp;of&nbsp;<BR>
the&nbsp;array&nbsp;we&nbsp;need&nbsp;to&nbsp;look&nbsp;to&nbsp;find&nbsp;the&nbsp;value.&nbsp;&nbsp;For&nbsp;the&nbsp;array&nbsp;<BR>
hard_currencies&nbsp;array:&nbsp;<BR>
&quot;platinum&quot;&nbsp;has&nbsp;an&nbsp;index&nbsp;of&nbsp;0.&nbsp;<BR>
&quot;gold&quot;&nbsp;has&nbsp;an&nbsp;index&nbsp;of&nbsp;1.&nbsp;<BR>
&quot;electrum&quot;&nbsp;has&nbsp;an&nbsp;index&nbsp;of&nbsp;2.&nbsp;<BR>
&quot;silver&quot;&nbsp;has&nbsp;an&nbsp;index&nbsp;of&nbsp;3.&nbsp;<BR>
&quot;copper&quot;&nbsp;has&nbsp;an&nbsp;index&nbsp;of&nbsp;4.&nbsp;<BR>
&nbsp;<BR>
The&nbsp;efun&nbsp;member_array()&nbsp;thus&nbsp;returns&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;element&nbsp;being&nbsp;<BR>
tested&nbsp;if&nbsp;it&nbsp;is&nbsp;in&nbsp;the&nbsp;array,&nbsp;or&nbsp;-1&nbsp;if&nbsp;it&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;array.&nbsp;&nbsp;In&nbsp;order&nbsp;to&nbsp;<BR>
reference&nbsp;an&nbsp;individual&nbsp;element&nbsp;in&nbsp;an&nbsp;array,&nbsp;you&nbsp;use&nbsp;its&nbsp;index&nbsp;number&nbsp;in&nbsp;<BR>
the&nbsp;following&nbsp;manner:&nbsp;<BR>
array_name[index_no]&nbsp;<BR>
Example:&nbsp;<BR>
hard_currencies[3]&nbsp;<BR>
where&nbsp;hard_currencies[3]&nbsp;would&nbsp;refer&nbsp;to&nbsp;&quot;silver&quot;.&nbsp;<BR>
&nbsp;<BR>
So,&nbsp;you&nbsp;now&nbsp;should&nbsp;now&nbsp;several&nbsp;ways&nbsp;in&nbsp;which&nbsp;arrays&nbsp;appear&nbsp;either&nbsp;as&nbsp;<BR>
a&nbsp;whole&nbsp;or&nbsp;as&nbsp;individual&nbsp;elements.&nbsp;&nbsp;As&nbsp;a&nbsp;whole,&nbsp;you&nbsp;refer&nbsp;to&nbsp;an&nbsp;array&nbsp;<BR>
variable&nbsp;by&nbsp;its&nbsp;name&nbsp;and&nbsp;an&nbsp;array&nbsp;constant&nbsp;by&nbsp;enclosing&nbsp;the&nbsp;array&nbsp;in&nbsp;({&nbsp;})&nbsp;<BR>
and&nbsp;separating&nbsp;elements&nbsp;by&nbsp;,.&nbsp;&nbsp;Individually,&nbsp;you&nbsp;refer&nbsp;to&nbsp;array&nbsp;variables&nbsp;<BR>
by&nbsp;the&nbsp;array&nbsp;name&nbsp;followed&nbsp;by&nbsp;the&nbsp;element's&nbsp;index&nbsp;number&nbsp;enclosed&nbsp;in&nbsp;<BR>
[],&nbsp;and&nbsp;to&nbsp;array&nbsp;constants&nbsp;in&nbsp;the&nbsp;same&nbsp;way&nbsp;you&nbsp;would&nbsp;refer&nbsp;to&nbsp;simple&nbsp;data&nbsp;<BR>
types&nbsp;of&nbsp;the&nbsp;same&nbsp;type&nbsp;as&nbsp;the&nbsp;constant.&nbsp;&nbsp;Examples:&nbsp;<BR>
&nbsp;<BR>
Whole&nbsp;arrays:&nbsp;<BR>
variable:&nbsp;&nbsp;arr&nbsp;<BR>
constant:&nbsp;({&nbsp;&quot;platinum&quot;,&nbsp;&quot;gold&quot;,&nbsp;&quot;electrum&quot;,&nbsp;&quot;silver&quot;,&nbsp;&quot;copper&quot;&nbsp;})&nbsp;<BR>
&nbsp;<BR>
Individual&nbsp;members&nbsp;of&nbsp;arrays:&nbsp;<BR>
variable:&nbsp;arr[2]&nbsp;<BR>
constant:&nbsp;&quot;electrum&quot;&nbsp;<BR>
&nbsp;<BR>
You&nbsp;can&nbsp;use&nbsp;these&nbsp;means&nbsp;of&nbsp;reference&nbsp;to&nbsp;do&nbsp;all&nbsp;the&nbsp;things&nbsp;you&nbsp;are&nbsp;used&nbsp;to&nbsp;<BR>
doing&nbsp;with&nbsp;other&nbsp;data&nbsp;types.&nbsp;&nbsp;You&nbsp;can&nbsp;assign&nbsp;values,&nbsp;use&nbsp;the&nbsp;values&nbsp;in&nbsp;<BR>
operations,&nbsp;pass&nbsp;the&nbsp;values&nbsp;as&nbsp;parameters&nbsp;to&nbsp;functions,&nbsp;and&nbsp;use&nbsp;the&nbsp;<BR>
values&nbsp;as&nbsp;return&nbsp;types.&nbsp;&nbsp;It&nbsp;is&nbsp;important&nbsp;to&nbsp;remember&nbsp;that&nbsp;when&nbsp;you&nbsp;are&nbsp;<BR>
treating&nbsp;an&nbsp;element&nbsp;alone&nbsp;as&nbsp;an&nbsp;individual,&nbsp;the&nbsp;individual&nbsp;element&nbsp;is&nbsp;not&nbsp;<BR>
itself&nbsp;an&nbsp;array&nbsp;(unless&nbsp;you&nbsp;are&nbsp;dealing&nbsp;with&nbsp;an&nbsp;array&nbsp;of&nbsp;arrays).&nbsp;&nbsp;In&nbsp;the&nbsp;<BR>
example&nbsp;above,&nbsp;the&nbsp;individual&nbsp;elements&nbsp;are&nbsp;strings.&nbsp;&nbsp;So&nbsp;that:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;arr[3]&nbsp;+&nbsp;&quot;&nbsp;and&nbsp;&quot;&nbsp;+&nbsp;arr[1];&nbsp;<BR>
will&nbsp;create&nbsp;str&nbsp;to&nbsp;equal&nbsp;&quot;silver&nbsp;and&nbsp;gold&quot;.&nbsp;&nbsp;Although&nbsp;this&nbsp;seems&nbsp;simple&nbsp;<BR>
enough,&nbsp;many&nbsp;people&nbsp;new&nbsp;to&nbsp;arrays&nbsp;start&nbsp;to&nbsp;run&nbsp;into&nbsp;trouble&nbsp;when&nbsp;trying&nbsp;<BR>
to&nbsp;add&nbsp;elements&nbsp;to&nbsp;an&nbsp;array.&nbsp;&nbsp;When&nbsp;you&nbsp;are&nbsp;treating&nbsp;an&nbsp;array&nbsp;as&nbsp;a&nbsp;whole&nbsp;<BR>
and&nbsp;you&nbsp;wish&nbsp;to&nbsp;add&nbsp;a&nbsp;new&nbsp;element&nbsp;to&nbsp;it,&nbsp;you&nbsp;must&nbsp;do&nbsp;it&nbsp;by&nbsp;adding&nbsp;<BR>
another&nbsp;array.&nbsp;<BR>
&nbsp;<BR>
Note&nbsp;the&nbsp;following&nbsp;example:&nbsp;<BR>
string&nbsp;str1,&nbsp;str2;&nbsp;<BR>
string&nbsp;*arr;&nbsp;<BR>
&nbsp;<BR>
str1&nbsp;=&nbsp;&quot;hi&quot;;&nbsp;<BR>
str2&nbsp;=&nbsp;&quot;bye&quot;;&nbsp;<BR>
/*&nbsp;str1&nbsp;+&nbsp;str2&nbsp;equals&nbsp;&quot;hibye&quot;&nbsp;*/&nbsp;<BR>
arr&nbsp;=&nbsp;({&nbsp;str1&nbsp;})&nbsp;+&nbsp;({&nbsp;str2&nbsp;});&nbsp;<BR>
/*&nbsp;arr&nbsp;is&nbsp;equal&nbsp;to&nbsp;({&nbsp;str1,&nbsp;str2&nbsp;})&nbsp;*/&nbsp;<BR>
Before&nbsp;going&nbsp;any&nbsp;further,&nbsp;I&nbsp;have&nbsp;to&nbsp;note&nbsp;that&nbsp;this&nbsp;example&nbsp;gives&nbsp;an&nbsp;<BR>
extremely&nbsp;horrible&nbsp;way&nbsp;of&nbsp;building&nbsp;an&nbsp;array.&nbsp;&nbsp;You&nbsp;should&nbsp;set&nbsp;it:&nbsp;arr&nbsp;=&nbsp;({&nbsp;<BR>
str1,&nbsp;str2&nbsp;}).&nbsp;&nbsp;The&nbsp;point&nbsp;of&nbsp;the&nbsp;example,&nbsp;however,&nbsp;is&nbsp;that&nbsp;you&nbsp;must&nbsp;add&nbsp;<BR>
like&nbsp;types&nbsp;together.&nbsp;&nbsp;If&nbsp;you&nbsp;try&nbsp;adding&nbsp;an&nbsp;element&nbsp;to&nbsp;an&nbsp;array&nbsp;as&nbsp;the&nbsp;data&nbsp;<BR>
type&nbsp;it&nbsp;is,&nbsp;you&nbsp;will&nbsp;get&nbsp;an&nbsp;error.&nbsp;&nbsp;Instead&nbsp;you&nbsp;have&nbsp;to&nbsp;treat&nbsp;it&nbsp;as&nbsp;an&nbsp;array&nbsp;of&nbsp;<BR>
a&nbsp;single&nbsp;element.&nbsp;<BR>
&nbsp;<BR>
3.5&nbsp;Mappings&nbsp;<BR>
One&nbsp;of&nbsp;the&nbsp;major&nbsp;advances&nbsp;made&nbsp;in&nbsp;LPMuds&nbsp;since&nbsp;they&nbsp;were&nbsp;created&nbsp;is&nbsp;<BR>
the&nbsp;mapping&nbsp;data&nbsp;type.&nbsp;&nbsp;People&nbsp;alternately&nbsp;refer&nbsp;to&nbsp;them&nbsp;as&nbsp;associative&nbsp;<BR>
arrays.&nbsp;&nbsp;Practically&nbsp;speaking,&nbsp;a&nbsp;mapping&nbsp;allows&nbsp;you&nbsp;freedom&nbsp;from&nbsp;the&nbsp;<BR>
association&nbsp;of&nbsp;a&nbsp;numerical&nbsp;index&nbsp;to&nbsp;a&nbsp;value&nbsp;which&nbsp;arrays&nbsp;require.&nbsp;&nbsp;<BR>
Instead,&nbsp;mappings&nbsp;allow&nbsp;you&nbsp;to&nbsp;associate&nbsp;values&nbsp;with&nbsp;indices&nbsp;which&nbsp;<BR>
actually&nbsp;have&nbsp;meaning&nbsp;to&nbsp;you,&nbsp;much&nbsp;like&nbsp;a&nbsp;relational&nbsp;database.&nbsp;<BR>
&nbsp;<BR>
In&nbsp;an&nbsp;array&nbsp;of&nbsp;5&nbsp;elements,&nbsp;you&nbsp;access&nbsp;those&nbsp;values&nbsp;solely&nbsp;by&nbsp;their&nbsp;integer&nbsp;<BR>
indices&nbsp;which&nbsp;cover&nbsp;the&nbsp;range&nbsp;0&nbsp;to&nbsp;4.&nbsp;&nbsp;Imagine&nbsp;going&nbsp;back&nbsp;to&nbsp;the&nbsp;example&nbsp;<BR>
of&nbsp;money&nbsp;again.&nbsp;&nbsp;Players&nbsp;have&nbsp;money&nbsp;of&nbsp;different&nbsp;amounts&nbsp;and&nbsp;different&nbsp;<BR>
types.&nbsp;&nbsp;In&nbsp;the&nbsp;player&nbsp;object,&nbsp;you&nbsp;need&nbsp;a&nbsp;way&nbsp;to&nbsp;store&nbsp;the&nbsp;types&nbsp;of&nbsp;money&nbsp;<BR>
that&nbsp;exist&nbsp;as&nbsp;well&nbsp;as&nbsp;relate&nbsp;them&nbsp;to&nbsp;the&nbsp;amount&nbsp;of&nbsp;that&nbsp;currency&nbsp;type&nbsp;the&nbsp;<BR>
player&nbsp;has.&nbsp;&nbsp;The&nbsp;best&nbsp;way&nbsp;to&nbsp;do&nbsp;this&nbsp;with&nbsp;arrays&nbsp;would&nbsp;have&nbsp;been&nbsp;to&nbsp;<BR>
store&nbsp;an&nbsp;array&nbsp;of&nbsp;strings&nbsp;representing&nbsp;money&nbsp;types&nbsp;and&nbsp;an&nbsp;array&nbsp;of&nbsp;<BR>
integers&nbsp;representing&nbsp;values&nbsp;in&nbsp;the&nbsp;player&nbsp;object.&nbsp;&nbsp;This&nbsp;would&nbsp;result&nbsp;in&nbsp;<BR>
CPU-eating&nbsp;ugly&nbsp;code&nbsp;like&nbsp;this:&nbsp;<BR>
&nbsp;<BR>
int&nbsp;query_money(string&nbsp;type)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;member_array(type,&nbsp;currencies);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(i&gt;-1&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;&nbsp;sizeof(amounts))&nbsp;&nbsp;/*&nbsp;sizeof&nbsp;efun&nbsp;<BR>
returns&nbsp;#&nbsp;of&nbsp;elements&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;amounts[i];&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;0;&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
And&nbsp;that&nbsp;is&nbsp;a&nbsp;simple&nbsp;query&nbsp;function.&nbsp;&nbsp;Look&nbsp;at&nbsp;an&nbsp;add&nbsp;function:&nbsp;<BR>
&nbsp;<BR>
void&nbsp;add_money(string&nbsp;type,&nbsp;int&nbsp;amt)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*tmp1;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*&nbsp;tmp2;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;x,&nbsp;j,&nbsp;maxj;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;member_array(type,&nbsp;currencies);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(i&nbsp;&gt;=&nbsp;sizeof(amounts))&nbsp;/*&nbsp;&nbsp;corrupt&nbsp;data,&nbsp;we&nbsp;are&nbsp;in&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;bad&nbsp;way&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(i==&nbsp;-1)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currencies&nbsp;+=&nbsp;({&nbsp;type&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amounts&nbsp;+=&nbsp;({&nbsp;amt&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amounts[i]&nbsp;+=&nbsp;amt;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(amounts[i]&nbsp;&lt;&nbsp;1)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp1&nbsp;=&nbsp;allocate(sizeof(currencies)-1);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2&nbsp;=&nbsp;allocate(sizeof(amounts)-1);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(j=0,&nbsp;x&nbsp;=0,&nbsp;maxj=sizeof(tmp1);&nbsp;j&nbsp;&lt;&nbsp;maxj;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j++)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(j==i)&nbsp;x&nbsp;=&nbsp;1;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp1[j]&nbsp;=&nbsp;currencies[j+x];&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2[j]&nbsp;=&nbsp;amounts[j+x];&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currencies&nbsp;=&nbsp;tmp1;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amounts&nbsp;=&nbsp;tmp2;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
That&nbsp;is&nbsp;really&nbsp;some&nbsp;nasty&nbsp;code&nbsp;to&nbsp;perform&nbsp;the&nbsp;rather&nbsp;simple&nbsp;concept&nbsp;of&nbsp;<BR>
adding&nbsp;some&nbsp;money.&nbsp;&nbsp;First,&nbsp;we&nbsp;figure&nbsp;out&nbsp;if&nbsp;the&nbsp;player&nbsp;has&nbsp;any&nbsp;of&nbsp;that&nbsp;<BR>
kind&nbsp;of&nbsp;money,&nbsp;and&nbsp;if&nbsp;so,&nbsp;which&nbsp;element&nbsp;of&nbsp;the&nbsp;currencies&nbsp;array&nbsp;it&nbsp;is.&nbsp;&nbsp;<BR>
After&nbsp;that,&nbsp;we&nbsp;have&nbsp;to&nbsp;check&nbsp;to&nbsp;see&nbsp;that&nbsp;the&nbsp;integrity&nbsp;of&nbsp;the&nbsp;currency&nbsp;data&nbsp;<BR>
has&nbsp;been&nbsp;maintained.&nbsp;&nbsp;If&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;type&nbsp;in&nbsp;the&nbsp;currencies&nbsp;array&nbsp;is&nbsp;<BR>
greater&nbsp;than&nbsp;the&nbsp;highest&nbsp;index&nbsp;of&nbsp;the&nbsp;amounts&nbsp;array,&nbsp;then&nbsp;we&nbsp;have&nbsp;a&nbsp;<BR>
problem&nbsp;since&nbsp;the&nbsp;indices&nbsp;are&nbsp;our&nbsp;only&nbsp;way&nbsp;of&nbsp;relating&nbsp;the&nbsp;two&nbsp;arrays.&nbsp;&nbsp;<BR>
Once&nbsp;we&nbsp;know&nbsp;our&nbsp;data&nbsp;is&nbsp;in&nbsp;tact,&nbsp;if&nbsp;the&nbsp;currency&nbsp;type&nbsp;is&nbsp;not&nbsp;currently&nbsp;<BR>
held&nbsp;by&nbsp;the&nbsp;player,&nbsp;we&nbsp;simply&nbsp;tack&nbsp;on&nbsp;the&nbsp;type&nbsp;as&nbsp;a&nbsp;new&nbsp;element&nbsp;to&nbsp;the&nbsp;<BR>
currencies&nbsp;array&nbsp;and&nbsp;the&nbsp;amount&nbsp;as&nbsp;a&nbsp;new&nbsp;element&nbsp;to&nbsp;the&nbsp;amounts&nbsp;array.&nbsp;&nbsp;<BR>
Finally,&nbsp;if&nbsp;it&nbsp;is&nbsp;a&nbsp;currency&nbsp;the&nbsp;player&nbsp;currently&nbsp;has,&nbsp;we&nbsp;just&nbsp;add&nbsp;the&nbsp;<BR>
amount&nbsp;to&nbsp;the&nbsp;corresponding&nbsp;index&nbsp;in&nbsp;the&nbsp;amounts&nbsp;array.&nbsp;&nbsp;If&nbsp;the&nbsp;money&nbsp;<BR>
gets&nbsp;below&nbsp;1,&nbsp;meaning&nbsp;having&nbsp;no&nbsp;money&nbsp;of&nbsp;that&nbsp;type,&nbsp;we&nbsp;want&nbsp;to&nbsp;clear&nbsp;<BR>
the&nbsp;currency&nbsp;out&nbsp;of&nbsp;memory.&nbsp;<BR>
&nbsp;<BR>
Subtracting&nbsp;an&nbsp;element&nbsp;from&nbsp;an&nbsp;array&nbsp;is&nbsp;no&nbsp;simple&nbsp;matter.&nbsp;&nbsp;Take,&nbsp;for&nbsp;<BR>
example,&nbsp;the&nbsp;result&nbsp;of&nbsp;the&nbsp;following:&nbsp;<BR>
&nbsp;<BR>
string&nbsp;*arr;&nbsp;<BR>
&nbsp;<BR>
arr&nbsp;=&nbsp;({&nbsp;&quot;a&quot;,&nbsp;&quot;b&quot;,&nbsp;&quot;a&quot;&nbsp;});&nbsp;<BR>
arr&nbsp;-=&nbsp;({&nbsp;arr[2]&nbsp;});&nbsp;<BR>
&nbsp;<BR>
What&nbsp;do&nbsp;you&nbsp;think&nbsp;the&nbsp;final&nbsp;value&nbsp;of&nbsp;arr&nbsp;is?&nbsp;Well,&nbsp;it&nbsp;is:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;({&nbsp;&quot;b&quot;,&nbsp;&quot;a&quot;&nbsp;})&nbsp;<BR>
Subtracting&nbsp;arr[2]&nbsp;from&nbsp;the&nbsp;original&nbsp;array&nbsp;does&nbsp;not&nbsp;remove&nbsp;the&nbsp;third&nbsp;<BR>
element&nbsp;from&nbsp;the&nbsp;array.&nbsp;&nbsp;Instead,&nbsp;it&nbsp;subtracts&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;third&nbsp;<BR>
element&nbsp;of&nbsp;the&nbsp;array&nbsp;from&nbsp;the&nbsp;array.&nbsp;&nbsp;And&nbsp;array&nbsp;subtraction&nbsp;removes&nbsp;the&nbsp;<BR>
first&nbsp;instance&nbsp;of&nbsp;the&nbsp;value&nbsp;from&nbsp;the&nbsp;array.&nbsp;&nbsp;Since&nbsp;we&nbsp;do&nbsp;not&nbsp;want&nbsp;to&nbsp;be&nbsp;<BR>
forced&nbsp;on&nbsp;counting&nbsp;on&nbsp;the&nbsp;elements&nbsp;of&nbsp;the&nbsp;array&nbsp;as&nbsp;being&nbsp;unique,&nbsp;we&nbsp;are&nbsp;<BR>
forced&nbsp;to&nbsp;go&nbsp;through&nbsp;some&nbsp;somersaults&nbsp;to&nbsp;remove&nbsp;the&nbsp;correct&nbsp;element&nbsp;<BR>
from&nbsp;both&nbsp;arrays&nbsp;in&nbsp;order&nbsp;to&nbsp;maintain&nbsp;the&nbsp;correspondence&nbsp;of&nbsp;the&nbsp;indices&nbsp;<BR>
in&nbsp;the&nbsp;two&nbsp;arrays.&nbsp;<BR>
&nbsp;<BR>
Mappings&nbsp;provide&nbsp;a&nbsp;better&nbsp;way.&nbsp;&nbsp;They&nbsp;allow&nbsp;you&nbsp;to&nbsp;directly&nbsp;associate&nbsp;the&nbsp;<BR>
money&nbsp;type&nbsp;with&nbsp;its&nbsp;value.&nbsp;&nbsp;Some&nbsp;people&nbsp;think&nbsp;of&nbsp;mappings&nbsp;as&nbsp;arrays&nbsp;<BR>
where&nbsp;you&nbsp;are&nbsp;not&nbsp;restricted&nbsp;to&nbsp;integers&nbsp;as&nbsp;indices.&nbsp;&nbsp;Truth&nbsp;is,&nbsp;mappings&nbsp;<BR>
are&nbsp;an&nbsp;entirely&nbsp;different&nbsp;concept&nbsp;in&nbsp;storing&nbsp;aggregate&nbsp;information.&nbsp;&nbsp;Arrays&nbsp;<BR>
force&nbsp;you&nbsp;to&nbsp;choose&nbsp;an&nbsp;index&nbsp;which&nbsp;is&nbsp;meaningful&nbsp;to&nbsp;the&nbsp;machine&nbsp;for&nbsp;<BR>
locating&nbsp;the&nbsp;appropriate&nbsp;data.&nbsp;&nbsp;The&nbsp;indices&nbsp;tell&nbsp;the&nbsp;machine&nbsp;how&nbsp;many&nbsp;<BR>
elements&nbsp;beyond&nbsp;the&nbsp;first&nbsp;value&nbsp;the&nbsp;value&nbsp;you&nbsp;desire&nbsp;can&nbsp;be&nbsp;found.&nbsp;&nbsp;With&nbsp;<BR>
mappings,&nbsp;you&nbsp;choose&nbsp;indices&nbsp;which&nbsp;are&nbsp;meaningful&nbsp;to&nbsp;you&nbsp;without&nbsp;<BR>
worrying&nbsp;about&nbsp;how&nbsp;that&nbsp;machine&nbsp;locates&nbsp;and&nbsp;stores&nbsp;it.&nbsp;<BR>
&nbsp;<BR>
You&nbsp;may&nbsp;recognize&nbsp;mappings&nbsp;in&nbsp;the&nbsp;following&nbsp;forms:&nbsp;<BR>
&nbsp;<BR>
constant&nbsp;values:&nbsp;<BR>
whole:&nbsp;([&nbsp;index:value,&nbsp;index:value&nbsp;])&nbsp;Ex:&nbsp;([&nbsp;&quot;gold&quot;:10,&nbsp;&quot;silver&quot;:20&nbsp;])&nbsp;<BR>
element:&nbsp;&nbsp;10&nbsp;<BR>
&nbsp;<BR>
variable&nbsp;values:&nbsp;<BR>
whole:&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;&nbsp;&nbsp;(where&nbsp;map&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;a&nbsp;mapping&nbsp;variable)&nbsp;<BR>
element:&nbsp;map[&quot;gold&quot;]&nbsp;<BR>
&nbsp;<BR>
So&nbsp;now&nbsp;my&nbsp;monetary&nbsp;functions&nbsp;would&nbsp;look&nbsp;like:&nbsp;<BR>
&nbsp;<BR>
int&nbsp;query_money(string&nbsp;type)&nbsp;{&nbsp;return&nbsp;money[type];&nbsp;}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;add_money(string&nbsp;type,&nbsp;int&nbsp;amt)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!money[type])&nbsp;money[type]&nbsp;=&nbsp;amt;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;money[type]&nbsp;+=&nbsp;amt;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(money[type]&nbsp;&lt;&nbsp;1)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map_delete(money,&nbsp;type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;this&nbsp;is&nbsp;for&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MudOS&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...OR...&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;money&nbsp;=&nbsp;m_delete(money,&nbsp;type)&nbsp;&nbsp;/*&nbsp;for&nbsp;some&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LPMud&nbsp;3.*&nbsp;varieties&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;OR...&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_delete(money,&nbsp;type);&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;other&nbsp;LPMud&nbsp;3.*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;varieties&nbsp;*/&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
Please&nbsp;notice&nbsp;first&nbsp;that&nbsp;the&nbsp;efuns&nbsp;for&nbsp;clearing&nbsp;a&nbsp;mapping&nbsp;element&nbsp;from&nbsp;the&nbsp;<BR>
mapping&nbsp;vary&nbsp;from&nbsp;driver&nbsp;to&nbsp;driver.&nbsp;&nbsp;Check&nbsp;with&nbsp;your&nbsp;driver's&nbsp;<BR>
documentation&nbsp;for&nbsp;the&nbsp;exact&nbsp;name&nbsp;an&nbsp;syntax&nbsp;of&nbsp;the&nbsp;relevant&nbsp;efun.&nbsp;<BR>
&nbsp;<BR>
As&nbsp;you&nbsp;can&nbsp;see&nbsp;immediately,&nbsp;you&nbsp;do&nbsp;not&nbsp;need&nbsp;to&nbsp;check&nbsp;the&nbsp;integrity&nbsp;of&nbsp;<BR>
your&nbsp;data&nbsp;since&nbsp;the&nbsp;values&nbsp;which&nbsp;interest&nbsp;you&nbsp;are&nbsp;inextricably&nbsp;bound&nbsp;to&nbsp;<BR>
one&nbsp;another&nbsp;in&nbsp;the&nbsp;mapping.&nbsp;&nbsp;Secondly,&nbsp;getting&nbsp;rid&nbsp;of&nbsp;useless&nbsp;values&nbsp;is&nbsp;a&nbsp;<BR>
simple&nbsp;efun&nbsp;call&nbsp;rather&nbsp;than&nbsp;a&nbsp;tricky,&nbsp;CPU-eating&nbsp;loop.&nbsp;&nbsp;Finally,&nbsp;the&nbsp;<BR>
query&nbsp;function&nbsp;is&nbsp;made&nbsp;up&nbsp;solely&nbsp;of&nbsp;a&nbsp;return&nbsp;instruction.&nbsp;&nbsp;<BR>
&nbsp;<BR>
You&nbsp;must&nbsp;declare&nbsp;and&nbsp;initialize&nbsp;any&nbsp;mapping&nbsp;before&nbsp;using&nbsp;it.&nbsp;&nbsp;<BR>
Declarations&nbsp;look&nbsp;like:&nbsp;<BR>
mapping&nbsp;map;&nbsp;<BR>
Whereas&nbsp;common&nbsp;initializations&nbsp;look&nbsp;like:&nbsp;<BR>
map&nbsp;=&nbsp;([]);&nbsp;<BR>
map&nbsp;=&nbsp;allocate_mapping(10)&nbsp;&nbsp;&nbsp;...OR...&nbsp;&nbsp;&nbsp;map&nbsp;=&nbsp;m_allocate(10);&nbsp;<BR>
map&nbsp;=&nbsp;([&nbsp;&quot;gold&quot;:&nbsp;20,&nbsp;&quot;silver&quot;:&nbsp;15&nbsp;]);&nbsp;<BR>
&nbsp;<BR>
As&nbsp;with&nbsp;other&nbsp;data&nbsp;types,&nbsp;there&nbsp;are&nbsp;rules&nbsp;defining&nbsp;how&nbsp;they&nbsp;work&nbsp;in&nbsp;<BR>
common&nbsp;operations&nbsp;like&nbsp;addition&nbsp;and&nbsp;subtraction:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;([&nbsp;&quot;gold&quot;:20,&nbsp;&quot;silver&quot;:30&nbsp;])&nbsp;+&nbsp;([&nbsp;&quot;electrum&quot;:5&nbsp;])&nbsp;&nbsp;<BR>
gives:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;([&quot;gold&quot;:20,&nbsp;&quot;silver&quot;:30,&nbsp;&quot;electrum&quot;:5])&nbsp;&nbsp;&nbsp;&nbsp;<BR>
Although&nbsp;my&nbsp;demonstration&nbsp;shows&nbsp;a&nbsp;continuity&nbsp;of&nbsp;order,&nbsp;there&nbsp;is&nbsp;in&nbsp;fact&nbsp;<BR>
no&nbsp;guarantee&nbsp;of&nbsp;the&nbsp;order&nbsp;in&nbsp;which&nbsp;elements&nbsp;of&nbsp;mappings&nbsp;will&nbsp;stored.&nbsp;&nbsp;<BR>
Equivalence&nbsp;tests&nbsp;among&nbsp;mappings&nbsp;are&nbsp;therefore&nbsp;not&nbsp;a&nbsp;good&nbsp;thing.&nbsp;<BR>
&nbsp;<BR>
3.6&nbsp;Summary&nbsp;<BR>
Mappings&nbsp;and&nbsp;arrays&nbsp;can&nbsp;be&nbsp;built&nbsp;as&nbsp;complex&nbsp;as&nbsp;you&nbsp;need&nbsp;them&nbsp;to&nbsp;be.&nbsp;&nbsp;<BR>
You&nbsp;can&nbsp;have&nbsp;an&nbsp;array&nbsp;of&nbsp;mappings&nbsp;of&nbsp;arrays.&nbsp;&nbsp;Such&nbsp;a&nbsp;thing&nbsp;would&nbsp;be&nbsp;<BR>
declared&nbsp;like&nbsp;this:&nbsp;<BR>
&nbsp;<BR>
mapping&nbsp;*map_of_arrs;&nbsp;<BR>
which&nbsp;might&nbsp;look&nbsp;like:&nbsp;<BR>
({&nbsp;([&nbsp;ind1:&nbsp;({&nbsp;valA1,&nbsp;valA2}),&nbsp;ind2:&nbsp;({valB1,&nbsp;valB2})&nbsp;]),&nbsp;([&nbsp;indX:&nbsp;<BR>
({valX1,valX2})&nbsp;])&nbsp;})&nbsp;<BR>
&nbsp;<BR>
Mappings&nbsp;may&nbsp;use&nbsp;any&nbsp;data&nbsp;type&nbsp;as&nbsp;an&nbsp;index,&nbsp;including&nbsp;objects.&nbsp;&nbsp;<BR>
Mapping&nbsp;indices&nbsp;are&nbsp;often&nbsp;referred&nbsp;to&nbsp;as&nbsp;keys&nbsp;as&nbsp;well,&nbsp;a&nbsp;term&nbsp;from&nbsp;<BR>
databases.&nbsp;&nbsp;Always&nbsp;keep&nbsp;in&nbsp;mind&nbsp;that&nbsp;with&nbsp;any&nbsp;non-integer&nbsp;data&nbsp;type,&nbsp;<BR>
you&nbsp;must&nbsp;first&nbsp;initialize&nbsp;a&nbsp;variable&nbsp;before&nbsp;making&nbsp;use&nbsp;of&nbsp;it&nbsp;in&nbsp;common&nbsp;<BR>
operations&nbsp;such&nbsp;as&nbsp;addition&nbsp;and&nbsp;subtraction.&nbsp;&nbsp;In&nbsp;spite&nbsp;of&nbsp;the&nbsp;ease&nbsp;and&nbsp;<BR>
dynamics&nbsp;added&nbsp;to&nbsp;LPC&nbsp;coding&nbsp;by&nbsp;mappings&nbsp;and&nbsp;arrays,&nbsp;errors&nbsp;caused&nbsp;<BR>
by&nbsp;failing&nbsp;to&nbsp;initialize&nbsp;their&nbsp;values&nbsp;can&nbsp;be&nbsp;the&nbsp;most&nbsp;maddening&nbsp;experience&nbsp;<BR>
for&nbsp;people&nbsp;new&nbsp;to&nbsp;these&nbsp;data&nbsp;types.&nbsp;&nbsp;I&nbsp;would&nbsp;venture&nbsp;that&nbsp;a&nbsp;very&nbsp;high&nbsp;<BR>
percentage&nbsp;of&nbsp;all&nbsp;errors&nbsp;people&nbsp;experimenting&nbsp;with&nbsp;mappings&nbsp;and&nbsp;arrays&nbsp;<BR>
for&nbsp;the&nbsp;first&nbsp;time&nbsp;encounter&nbsp;are&nbsp;one&nbsp;of&nbsp;three&nbsp;error&nbsp;messages:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indexing&nbsp;on&nbsp;illegal&nbsp;type.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Illegal&nbsp;index.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bad&nbsp;argument&nbsp;1&nbsp;to&nbsp;(+&nbsp;+=&nbsp;-&nbsp;-=)&nbsp;/*&nbsp;insert&nbsp;your&nbsp;favourite&nbsp;operator&nbsp;*/&nbsp;<BR>
Error&nbsp;messages&nbsp;1&nbsp;and&nbsp;3&nbsp;are&nbsp;darn&nbsp;near&nbsp;almost&nbsp;always&nbsp;caused&nbsp;by&nbsp;a&nbsp;failure&nbsp;<BR>
to&nbsp;initialize&nbsp;the&nbsp;array&nbsp;or&nbsp;mapping&nbsp;in&nbsp;question.&nbsp;&nbsp;Error&nbsp;message&nbsp;2&nbsp;is&nbsp;caused&nbsp;<BR>
generally&nbsp;when&nbsp;you&nbsp;are&nbsp;trying&nbsp;to&nbsp;use&nbsp;an&nbsp;index&nbsp;in&nbsp;an&nbsp;initialized&nbsp;array&nbsp;<BR>
which&nbsp;does&nbsp;not&nbsp;exist.&nbsp;&nbsp;Also,&nbsp;for&nbsp;arrays,&nbsp;often&nbsp;people&nbsp;new&nbsp;to&nbsp;arrays&nbsp;will&nbsp;<BR>
get&nbsp;error&nbsp;message&nbsp;3&nbsp;because&nbsp;they&nbsp;try&nbsp;to&nbsp;add&nbsp;a&nbsp;single&nbsp;element&nbsp;to&nbsp;an&nbsp;array&nbsp;<BR>
by&nbsp;adding&nbsp;the&nbsp;initial&nbsp;array&nbsp;to&nbsp;the&nbsp;single&nbsp;element&nbsp;value&nbsp;instead&nbsp;of&nbsp;adding&nbsp;<BR>
an&nbsp;array&nbsp;of&nbsp;the&nbsp;single&nbsp;element&nbsp;to&nbsp;the&nbsp;initial&nbsp;array.&nbsp;&nbsp;Remember,&nbsp;add&nbsp;only&nbsp;<BR>
arrays&nbsp;to&nbsp;arrays.&nbsp;<BR>
&nbsp;<BR>
At&nbsp;this&nbsp;point,&nbsp;you&nbsp;should&nbsp;feel&nbsp;comfortable&nbsp;enough&nbsp;with&nbsp;mappings&nbsp;and&nbsp;<BR>
arrays&nbsp;to&nbsp;play&nbsp;with&nbsp;them.&nbsp;&nbsp;Expect&nbsp;to&nbsp;encounter&nbsp;the&nbsp;above&nbsp;error&nbsp;messages&nbsp;<BR>
a&nbsp;lot&nbsp;when&nbsp;first&nbsp;playing&nbsp;with&nbsp;these.&nbsp;&nbsp;The&nbsp;key&nbsp;to&nbsp;success&nbsp;with&nbsp;mappings&nbsp;is&nbsp;<BR>
in&nbsp;debugging&nbsp;all&nbsp;of&nbsp;these&nbsp;errors&nbsp;and&nbsp;seeing&nbsp;exactly&nbsp;what&nbsp;causes&nbsp;wholes&nbsp;<BR>
in&nbsp;your&nbsp;programming&nbsp;which&nbsp;allow&nbsp;you&nbsp;to&nbsp;try&nbsp;to&nbsp;work&nbsp;with&nbsp;uninitialized&nbsp;<BR>
mappings&nbsp;and&nbsp;arrays.&nbsp;&nbsp;Finally,&nbsp;go&nbsp;back&nbsp;through&nbsp;the&nbsp;basic&nbsp;room&nbsp;code&nbsp;and&nbsp;<BR>
look&nbsp;at&nbsp;things&nbsp;like&nbsp;the&nbsp;set_exits()&nbsp;(or&nbsp;the&nbsp;equivalent&nbsp;on&nbsp;your&nbsp;mudlib)&nbsp;<BR>
function.&nbsp;&nbsp;Chances&nbsp;are&nbsp;it&nbsp;makes&nbsp;use&nbsp;of&nbsp;mappings.&nbsp;&nbsp;In&nbsp;some&nbsp;instances,&nbsp;it&nbsp;<BR>
will&nbsp;use&nbsp;arrays&nbsp;as&nbsp;well&nbsp;for&nbsp;compatibility&nbsp;with&nbsp;mudlib.n.&nbsp;<BR>
&nbsp;<BR>
Copyright&nbsp;(c)&nbsp;George&nbsp;Reese&nbsp;1993&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
小樓一夜聽秋雨&nbsp;<BR>
--&nbsp;<BR>
佇倚危樓風細細&nbsp;望極春愁&nbsp;黯黯生天際&nbsp;&nbsp;草色煙光殘照裡&nbsp;無言誰會憑欄意[0&nbsp;<BR>
擬把疏狂圖一醉&nbsp;對酒當歌&nbsp;強樂還無味&nbsp;&nbsp;衣帶漸寬終不悔&nbsp;為伊消得人憔悴&nbsp;<BR>
&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;166.111.5.25]&nbsp;<BR>
<A HREF="00000013.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000015.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>