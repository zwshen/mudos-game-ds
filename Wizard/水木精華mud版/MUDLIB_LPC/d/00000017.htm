<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;Ranma&nbsp;(亂馬~~~~~~~無聊中),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Lpc&nbsp;intermediate&nbsp;(6)--Intermediate&nbsp;Inheritance&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Mon&nbsp;Oct&nbsp;20&nbsp;09:22:34&nbsp;1997)&nbsp;<BR>
&nbsp;<BR>
Intermediate&nbsp;LPC&nbsp;<BR>
Descartes&nbsp;of&nbsp;Borg&nbsp;<BR>
November&nbsp;1993&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Chapter&nbsp;6:&nbsp;Intermediate&nbsp;Inheritance&nbsp;<BR>
&nbsp;<BR>
6.1&nbsp;Basics&nbsp;of&nbsp;Inheritance&nbsp;<BR>
In&nbsp;the&nbsp;textbook&nbsp;LPC&nbsp;Basics,&nbsp;you&nbsp;learned&nbsp;how&nbsp;it&nbsp;is&nbsp;the&nbsp;mudlib&nbsp;maintains&nbsp;<BR>
consistency&nbsp;amoung&nbsp;mud&nbsp;objects&nbsp;through&nbsp;inheritance.&nbsp;&nbsp;Inheritance&nbsp;<BR>
allows&nbsp;the&nbsp;mud&nbsp;administrators&nbsp;to&nbsp;code&nbsp;the&nbsp;basic&nbsp;functions&nbsp;and&nbsp;such&nbsp;that&nbsp;<BR>
all&nbsp;mudlib&nbsp;objects,&nbsp;or&nbsp;all&nbsp;mudlib&nbsp;objects&nbsp;of&nbsp;a&nbsp;certain&nbsp;type&nbsp;must&nbsp;have&nbsp;so&nbsp;<BR>
that&nbsp;you&nbsp;can&nbsp;concentrate&nbsp;on&nbsp;creating&nbsp;the&nbsp;functions&nbsp;which&nbsp;make&nbsp;these&nbsp;<BR>
objects&nbsp;different.&nbsp;&nbsp;When&nbsp;you&nbsp;build&nbsp;a&nbsp;room,&nbsp;or&nbsp;a&nbsp;weapon,&nbsp;or&nbsp;a&nbsp;monster,&nbsp;<BR>
you&nbsp;are&nbsp;taking&nbsp;a&nbsp;set&nbsp;of&nbsp;functions&nbsp;already&nbsp;written&nbsp;for&nbsp;you&nbsp;and&nbsp;inheriting&nbsp;<BR>
them&nbsp;into&nbsp;your&nbsp;object.&nbsp;&nbsp;In&nbsp;this&nbsp;way,&nbsp;all&nbsp;objects&nbsp;on&nbsp;the&nbsp;mud&nbsp;can&nbsp;count&nbsp;on&nbsp;<BR>
other&nbsp;objects&nbsp;to&nbsp;behave&nbsp;in&nbsp;a&nbsp;certain&nbsp;manner.&nbsp;&nbsp;For&nbsp;instance,&nbsp;player&nbsp;objects&nbsp;<BR>
can&nbsp;rely&nbsp;on&nbsp;the&nbsp;fact&nbsp;that&nbsp;all&nbsp;room&nbsp;objects&nbsp;will&nbsp;have&nbsp;a&nbsp;function&nbsp;in&nbsp;them&nbsp;<BR>
called&nbsp;query_long()&nbsp;which&nbsp;describes&nbsp;the&nbsp;room.&nbsp;&nbsp;Inheritance&nbsp;thus&nbsp;keeps&nbsp;<BR>
you&nbsp;from&nbsp;having&nbsp;to&nbsp;worry&nbsp;about&nbsp;what&nbsp;the&nbsp;function&nbsp;query_long()&nbsp;should&nbsp;<BR>
look&nbsp;like.&nbsp;<BR>
&nbsp;<BR>
Naturally,&nbsp;this&nbsp;textbook&nbsp;tries&nbsp;to&nbsp;go&nbsp;beyond&nbsp;this&nbsp;fundamental&nbsp;knowledge&nbsp;<BR>
of&nbsp;inheritance&nbsp;to&nbsp;give&nbsp;the&nbsp;coder&nbsp;a&nbsp;better&nbsp;undertstanding&nbsp;of&nbsp;how&nbsp;<BR>
inheritance&nbsp;works&nbsp;in&nbsp;LPC&nbsp;programming.&nbsp;&nbsp;Without&nbsp;getting&nbsp;into&nbsp;detail&nbsp;that&nbsp;<BR>
the&nbsp;advanced&nbsp;domain&nbsp;coder/beginner&nbsp;mudlib&nbsp;coder&nbsp;simply&nbsp;does&nbsp;not&nbsp;yet&nbsp;<BR>
need,&nbsp;this&nbsp;chapter&nbsp;will&nbsp;try&nbsp;to&nbsp;explain&nbsp;exactly&nbsp;what&nbsp;happens&nbsp;when&nbsp;you&nbsp;<BR>
inherit&nbsp;an&nbsp;object.&nbsp;<BR>
&nbsp;<BR>
6.2&nbsp;Cloning&nbsp;and&nbsp;Inheritance&nbsp;<BR>
Whenever&nbsp;a&nbsp;file&nbsp;is&nbsp;referenced&nbsp;for&nbsp;the&nbsp;first&nbsp;time&nbsp;as&nbsp;an&nbsp;object&nbsp;(as&nbsp;opposed&nbsp;<BR>
to&nbsp;reading&nbsp;the&nbsp;contents&nbsp;of&nbsp;the&nbsp;file),&nbsp;the&nbsp;game&nbsp;tries&nbsp;to&nbsp;load&nbsp;the&nbsp;file&nbsp;into&nbsp;<BR>
memory&nbsp;and&nbsp;create&nbsp;an&nbsp;object.&nbsp;&nbsp;If&nbsp;the&nbsp;object&nbsp;is&nbsp;successfully&nbsp;loaded&nbsp;into&nbsp;<BR>
memory,&nbsp;it&nbsp;becomes&nbsp;as&nbsp;master&nbsp;copy.&nbsp;&nbsp;Master&nbsp;copies&nbsp;of&nbsp;objects&nbsp;may&nbsp;be&nbsp;<BR>
cloned&nbsp;but&nbsp;not&nbsp;used&nbsp;as&nbsp;actual&nbsp;game&nbsp;objects.&nbsp;&nbsp;The&nbsp;master&nbsp;copy&nbsp;is&nbsp;used&nbsp;to&nbsp;<BR>
support&nbsp;any&nbsp;clone&nbsp;objects&nbsp;in&nbsp;the&nbsp;game.&nbsp;<BR>
&nbsp;<BR>
The&nbsp;master&nbsp;copy&nbsp;is&nbsp;the&nbsp;source&nbsp;of&nbsp;one&nbsp;of&nbsp;the&nbsp;controversies&nbsp;of&nbsp;mud&nbsp;LPC&nbsp;<BR>
coding,&nbsp;that&nbsp;is&nbsp;whether&nbsp;to&nbsp;clone&nbsp;or&nbsp;inherit.&nbsp;&nbsp;With&nbsp;rooms,&nbsp;there&nbsp;is&nbsp;no&nbsp;<BR>
question&nbsp;of&nbsp;what&nbsp;you&nbsp;wish&nbsp;to&nbsp;do,&nbsp;since&nbsp;there&nbsp;should&nbsp;only&nbsp;be&nbsp;one&nbsp;instance&nbsp;<BR>
of&nbsp;each&nbsp;room&nbsp;object&nbsp;in&nbsp;the&nbsp;game.&nbsp;&nbsp;So&nbsp;you&nbsp;generally&nbsp;use&nbsp;inheritance&nbsp;in&nbsp;<BR>
creating&nbsp;rooms.&nbsp;&nbsp;Many&nbsp;mud&nbsp;administrators,&nbsp;including&nbsp;myself,&nbsp;however&nbsp;<BR>
encourage&nbsp;creators&nbsp;to&nbsp;clone&nbsp;the&nbsp;standard&nbsp;monster&nbsp;object&nbsp;and&nbsp;configure&nbsp;it&nbsp;<BR>
from&nbsp;inside&nbsp;room&nbsp;objects&nbsp;instead&nbsp;of&nbsp;keeping&nbsp;monsters&nbsp;in&nbsp;separate&nbsp;files&nbsp;<BR>
which&nbsp;inherit&nbsp;the&nbsp;standard&nbsp;monster&nbsp;object.&nbsp;<BR>
&nbsp;<BR>
As&nbsp;I&nbsp;stated&nbsp;above,&nbsp;each&nbsp;time&nbsp;a&nbsp;file&nbsp;is&nbsp;referenced&nbsp;to&nbsp;create&nbsp;an&nbsp;object,&nbsp;a&nbsp;<BR>
master&nbsp;copy&nbsp;is&nbsp;loaded&nbsp;into&nbsp;memory.&nbsp;&nbsp;When&nbsp;you&nbsp;do&nbsp;something&nbsp;like:&nbsp;<BR>
void&nbsp;reset()&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;ob;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ob&nbsp;=&nbsp;new(&quot;/std/monster&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;clone_object(&quot;/std/monster&quot;)&nbsp;some&nbsp;places&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ob-&gt;set_name(&quot;foo&nbsp;monster&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;rest&nbsp;of&nbsp;monster&nbsp;config&nbsp;code&nbsp;followed&nbsp;by&nbsp;moving&nbsp;<BR>
it&nbsp;to&nbsp;the&nbsp;room&nbsp;...&nbsp;<BR>
}&nbsp;<BR>
the&nbsp;driver&nbsp;searches&nbsp;to&nbsp;see&nbsp;if&nbsp;their&nbsp;is&nbsp;a&nbsp;master&nbsp;object&nbsp;called&nbsp;&quot;/std/monster&quot;.&nbsp;&nbsp;<BR>
If&nbsp;not,&nbsp;it&nbsp;creates&nbsp;one.&nbsp;&nbsp;If&nbsp;it&nbsp;does&nbsp;exist,&nbsp;or&nbsp;after&nbsp;it&nbsp;has&nbsp;been&nbsp;created,&nbsp;the&nbsp;<BR>
driver&nbsp;then&nbsp;creates&nbsp;a&nbsp;clone&nbsp;object&nbsp;called&nbsp;&quot;/std/monster#&lt;number&gt;&quot;.&nbsp;&nbsp;If&nbsp;<BR>
this&nbsp;is&nbsp;the&nbsp;first&nbsp;time&nbsp;&quot;/std/monster&quot;&nbsp;is&nbsp;being&nbsp;referenced,&nbsp;in&nbsp;effect,&nbsp;two&nbsp;<BR>
objects&nbsp;are&nbsp;being&nbsp;created:&nbsp;the&nbsp;master&nbsp;object&nbsp;and&nbsp;the&nbsp;cloned&nbsp;instance.&nbsp;<BR>
&nbsp;<BR>
On&nbsp;the&nbsp;other&nbsp;hand,&nbsp;let's&nbsp;say&nbsp;you&nbsp;did&nbsp;all&nbsp;your&nbsp;configuring&nbsp;in&nbsp;the&nbsp;create()&nbsp;<BR>
of&nbsp;a&nbsp;special&nbsp;monster&nbsp;file&nbsp;which&nbsp;inherits&nbsp;&quot;/std/monster&quot;.&nbsp;&nbsp;Instead&nbsp;of&nbsp;<BR>
cloning&nbsp;the&nbsp;standard&nbsp;monster&nbsp;object&nbsp;from&nbsp;your&nbsp;room,&nbsp;you&nbsp;clone&nbsp;your&nbsp;<BR>
monster&nbsp;file.&nbsp;&nbsp;If&nbsp;the&nbsp;standard&nbsp;monster&nbsp;has&nbsp;not&nbsp;been&nbsp;loaded,&nbsp;it&nbsp;gets&nbsp;loaded&nbsp;<BR>
since&nbsp;your&nbsp;monster&nbsp;inherits&nbsp;it.&nbsp;&nbsp;In&nbsp;addition,&nbsp;a&nbsp;master&nbsp;copy&nbsp;of&nbsp;your&nbsp;file&nbsp;<BR>
gets&nbsp;loaded&nbsp;into&nbsp;memory.&nbsp;&nbsp;Finally,&nbsp;a&nbsp;clone&nbsp;of&nbsp;your&nbsp;monster&nbsp;is&nbsp;created&nbsp;<BR>
and&nbsp;moved&nbsp;into&nbsp;the&nbsp;room,&nbsp;for&nbsp;a&nbsp;total&nbsp;of&nbsp;three&nbsp;objects&nbsp;added&nbsp;to&nbsp;the&nbsp;game.&nbsp;&nbsp;<BR>
Note&nbsp;that&nbsp;you&nbsp;cannot&nbsp;make&nbsp;use&nbsp;of&nbsp;the&nbsp;master&nbsp;copy&nbsp;easily&nbsp;to&nbsp;get&nbsp;around&nbsp;<BR>
this.&nbsp;&nbsp;If,&nbsp;for&nbsp;example,&nbsp;you&nbsp;were&nbsp;to&nbsp;do:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;/wizards/descartes/my_monster&quot;-&gt;move(this_object());&nbsp;<BR>
instead&nbsp;of&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;new(&quot;/wizards/descartes/my_monster&quot;)-&gt;move(this_object());&nbsp;<BR>
you&nbsp;would&nbsp;not&nbsp;be&nbsp;able&nbsp;to&nbsp;modify&nbsp;the&nbsp;file&nbsp;&quot;my_monster.c&quot;&nbsp;and&nbsp;update&nbsp;it,&nbsp;<BR>
since&nbsp;the&nbsp;update&nbsp;command&nbsp;destroys&nbsp;the&nbsp;current&nbsp;master&nbsp;version&nbsp;of&nbsp;an&nbsp;<BR>
object.&nbsp;&nbsp;On&nbsp;some&nbsp;mudlibs&nbsp;it&nbsp;also&nbsp;loads&nbsp;the&nbsp;new&nbsp;version&nbsp;into&nbsp;memory.&nbsp;&nbsp;<BR>
Imagine&nbsp;the&nbsp;look&nbsp;on&nbsp;a&nbsp;player's&nbsp;face&nbsp;when&nbsp;their&nbsp;monster&nbsp;disappears&nbsp;in&nbsp;<BR>
mid-combat&nbsp;cause&nbsp;you&nbsp;updated&nbsp;the&nbsp;file!&nbsp;<BR>
&nbsp;<BR>
Cloning&nbsp;is&nbsp;therefore&nbsp;a&nbsp;useful&nbsp;too&nbsp;when&nbsp;you&nbsp;plan&nbsp;on&nbsp;doing&nbsp;just&nbsp;that-&nbsp;<BR>
cloning.&nbsp;&nbsp;If&nbsp;you&nbsp;are&nbsp;doing&nbsp;nothing&nbsp;special&nbsp;to&nbsp;a&nbsp;monster&nbsp;which&nbsp;cannot&nbsp;be&nbsp;<BR>
done&nbsp;through&nbsp;a&nbsp;few&nbsp;call&nbsp;others,&nbsp;then&nbsp;you&nbsp;will&nbsp;save&nbsp;the&nbsp;mud&nbsp;from&nbsp;getting&nbsp;<BR>
loaded&nbsp;with&nbsp;useless&nbsp;master&nbsp;copies.&nbsp;&nbsp;Inheritance,&nbsp;however,&nbsp;is&nbsp;useful&nbsp;if&nbsp;<BR>
you&nbsp;plan&nbsp;to&nbsp;add&nbsp;functionality&nbsp;to&nbsp;an&nbsp;object&nbsp;(write&nbsp;your&nbsp;own&nbsp;functions)&nbsp;or&nbsp;<BR>
if&nbsp;you&nbsp;have&nbsp;a&nbsp;single&nbsp;configuration&nbsp;that&nbsp;gets&nbsp;used&nbsp;over&nbsp;and&nbsp;over&nbsp;again&nbsp;<BR>
(you&nbsp;have&nbsp;an&nbsp;army&nbsp;of&nbsp;orc&nbsp;guards&nbsp;all&nbsp;the&nbsp;same,&nbsp;so&nbsp;you&nbsp;write&nbsp;a&nbsp;special&nbsp;orc&nbsp;<BR>
file&nbsp;and&nbsp;clone&nbsp;it).&nbsp;<BR>
&nbsp;<BR>
6.3&nbsp;Inside&nbsp;Inheritance&nbsp;<BR>
When&nbsp;objects&nbsp;A&nbsp;and&nbsp;B&nbsp;inherit&nbsp;object&nbsp;C,&nbsp;all&nbsp;three&nbsp;objects&nbsp;have&nbsp;their&nbsp;own&nbsp;<BR>
set&nbsp;of&nbsp;data&nbsp;sharing&nbsp;one&nbsp;set&nbsp;of&nbsp;function&nbsp;definitions&nbsp;from&nbsp;object&nbsp;C.&nbsp;&nbsp;In&nbsp;<BR>
addition,&nbsp;A&nbsp;and&nbsp;B&nbsp;will&nbsp;have&nbsp;separate&nbsp;functions&nbsp;definitions&nbsp;which&nbsp;were&nbsp;<BR>
entered&nbsp;separately&nbsp;into&nbsp;their&nbsp;code.&nbsp;&nbsp;For&nbsp;the&nbsp;sake&nbsp;of&nbsp;example&nbsp;throughout&nbsp;<BR>
the&nbsp;rest&nbsp;of&nbsp;the&nbsp;chapter,&nbsp;we&nbsp;will&nbsp;use&nbsp;the&nbsp;following&nbsp;code.&nbsp;&nbsp;Do&nbsp;not&nbsp;be&nbsp;<BR>
disturbed&nbsp;if,&nbsp;at&nbsp;this&nbsp;point,&nbsp;some&nbsp;of&nbsp;the&nbsp;code&nbsp;makes&nbsp;no&nbsp;sense:&nbsp;<BR>
&nbsp;<BR>
OBJECT&nbsp;C&nbsp;<BR>
private&nbsp;string&nbsp;name,&nbsp;cap_name,&nbsp;short,&nbsp;long;&nbsp;<BR>
private&nbsp;int&nbsp;setup;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_name(string&nbsp;str)&nbsp;<BR>
nomask&nbsp;string&nbsp;query_name();&nbsp;<BR>
private&nbsp;int&nbsp;query_setup();&nbsp;<BR>
static&nbsp;void&nbsp;unsetup();&nbsp;<BR>
void&nbsp;set_short(string&nbsp;str);&nbsp;<BR>
string&nbsp;query_short();&nbsp;<BR>
void&nbsp;set_long(string&nbsp;str);&nbsp;<BR>
string&nbsp;query_long();&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_name(string&nbsp;str)&nbsp;{&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!query_setup())&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;str;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setup&nbsp;=&nbsp;1;&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
nomask&nbsp;string&nbsp;query_name()&nbsp;{&nbsp;return&nbsp;name;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
private&nbsp;query_setup()&nbsp;{&nbsp;return&nbsp;setup;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
static&nbsp;void&nbsp;unsetup()&nbsp;{&nbsp;setup&nbsp;=&nbsp;0;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
string&nbsp;query_cap_name()&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(name&nbsp;?&nbsp;capitalize(name)&nbsp;:&nbsp;&quot;&quot;);&nbsp;}&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_short(string&nbsp;str)&nbsp;{&nbsp;short&nbsp;=&nbsp;str;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
string&nbsp;query_short()&nbsp;{&nbsp;return&nbsp;short;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_long(string&nbsp;str)&nbsp;{&nbsp;long&nbsp;=&nbsp;str;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
string&nbsp;query_long()&nbsp;{&nbsp;return&nbsp;str;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;{&nbsp;seteuid(getuid());&nbsp;}&nbsp;<BR>
&nbsp;<BR>
OBJECT&nbsp;B&nbsp;<BR>
inherit&nbsp;&quot;/std/objectc&quot;;&nbsp;<BR>
&nbsp;<BR>
private&nbsp;int&nbsp;wc;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_wc(int&nbsp;wc);&nbsp;<BR>
int&nbsp;query_wc();&nbsp;<BR>
int&nbsp;wieldweapon(string&nbsp;str);&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;{&nbsp;::create();&nbsp;}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;init()&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(environment(this_object())&nbsp;==&nbsp;this_player())&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add_action(&quot;wieldweapon&quot;,&nbsp;&quot;wield&quot;);&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_wc(int&nbsp;x)&nbsp;{&nbsp;wc&nbsp;=&nbsp;x;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
int&nbsp;query_wc()&nbsp;{&nbsp;return&nbsp;wc;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
int&nbsp;wieldweapon(string&nbsp;str)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;code&nbsp;for&nbsp;wielding&nbsp;the&nbsp;weapon&nbsp;...&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
OBJECT&nbsp;A&nbsp;<BR>
inherit&nbsp;&quot;/std/objectc&quot;;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;ghost;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;{&nbsp;::create();&nbsp;}&nbsp;<BR>
&nbsp;<BR>
void&nbsp;change_name(string&nbsp;str)&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!((int)this_object()-&gt;is_player()))&nbsp;unsetup();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_name(str);&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
string&nbsp;query_cap_name()&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(ghost)&nbsp;return&nbsp;&quot;A&nbsp;ghost&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;return&nbsp;::query_cap_name();&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
As&nbsp;you&nbsp;can&nbsp;see,&nbsp;object&nbsp;C&nbsp;is&nbsp;inherited&nbsp;both&nbsp;by&nbsp;object&nbsp;A&nbsp;and&nbsp;object&nbsp;B.&nbsp;&nbsp;<BR>
Object&nbsp;C&nbsp;is&nbsp;a&nbsp;representation&nbsp;of&nbsp;a&nbsp;much&nbsp;oversimplified&nbsp;base&nbsp;object,&nbsp;with&nbsp;B&nbsp;<BR>
being&nbsp;an&nbsp;equally&nbsp;oversimplified&nbsp;weapon&nbsp;and&nbsp;A&nbsp;being&nbsp;an&nbsp;equally&nbsp;<BR>
simplified&nbsp;living&nbsp;object.&nbsp;&nbsp;Only&nbsp;one&nbsp;copy&nbsp;of&nbsp;each&nbsp;function&nbsp;is&nbsp;retained&nbsp;in&nbsp;<BR>
memory,&nbsp;even&nbsp;though&nbsp;we&nbsp;have&nbsp;here&nbsp;three&nbsp;objects&nbsp;using&nbsp;the&nbsp;functions.&nbsp;&nbsp;<BR>
There&nbsp;are&nbsp;of&nbsp;course,&nbsp;three&nbsp;instances&nbsp;of&nbsp;the&nbsp;variables&nbsp;from&nbsp;Object&nbsp;C&nbsp;in&nbsp;<BR>
memory,&nbsp;with&nbsp;one&nbsp;instance&nbsp;of&nbsp;the&nbsp;variables&nbsp;of&nbsp;Object&nbsp;A&nbsp;and&nbsp;Object&nbsp;B&nbsp;in&nbsp;<BR>
memory.&nbsp;&nbsp;Each&nbsp;object&nbsp;thus&nbsp;gets&nbsp;its&nbsp;own&nbsp;data.&nbsp;&nbsp;&nbsp;<BR>
&nbsp;<BR>
6.4&nbsp;Function&nbsp;and&nbsp;Variable&nbsp;Labels&nbsp;<BR>
Notice&nbsp;that&nbsp;many&nbsp;of&nbsp;the&nbsp;functions&nbsp;above&nbsp;are&nbsp;proceeded&nbsp;with&nbsp;labels&nbsp;which&nbsp;<BR>
have&nbsp;not&nbsp;yet&nbsp;appeared&nbsp;in&nbsp;either&nbsp;this&nbsp;text&nbsp;or&nbsp;the&nbsp;beginner&nbsp;text,&nbsp;the&nbsp;labels&nbsp;<BR>
static,&nbsp;private,&nbsp;and&nbsp;nomask.&nbsp;&nbsp;These&nbsp;labels&nbsp;define&nbsp;special&nbsp;priveledges&nbsp;<BR>
which&nbsp;an&nbsp;object&nbsp;may&nbsp;have&nbsp;to&nbsp;its&nbsp;data&nbsp;and&nbsp;member&nbsp;functions.&nbsp;&nbsp;Functions&nbsp;<BR>
you&nbsp;have&nbsp;used&nbsp;up&nbsp;to&nbsp;this&nbsp;point&nbsp;have&nbsp;the&nbsp;default&nbsp;label&nbsp;public.&nbsp;&nbsp;This&nbsp;is&nbsp;<BR>
default&nbsp;to&nbsp;such&nbsp;a&nbsp;degree,&nbsp;some&nbsp;drivers&nbsp;do&nbsp;not&nbsp;support&nbsp;the&nbsp;labeling.&nbsp;<BR>
&nbsp;<BR>
A&nbsp;public&nbsp;variable&nbsp;is&nbsp;available&nbsp;to&nbsp;any&nbsp;object&nbsp;down&nbsp;the&nbsp;inheritance&nbsp;tree&nbsp;<BR>
from&nbsp;the&nbsp;object&nbsp;in&nbsp;which&nbsp;the&nbsp;variable&nbsp;is&nbsp;declared.&nbsp;&nbsp;Public&nbsp;variables&nbsp;in&nbsp;<BR>
object&nbsp;C&nbsp;may&nbsp;be&nbsp;accessed&nbsp;by&nbsp;both&nbsp;objects&nbsp;A&nbsp;and&nbsp;B.&nbsp;&nbsp;Similarly,&nbsp;public&nbsp;<BR>
functions&nbsp;may&nbsp;be&nbsp;called&nbsp;by&nbsp;any&nbsp;object&nbsp;down&nbsp;the&nbsp;inheritance&nbsp;tree&nbsp;from&nbsp;the&nbsp;<BR>
object&nbsp;in&nbsp;which&nbsp;they&nbsp;are&nbsp;declared.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;opposite&nbsp;of&nbsp;public&nbsp;is&nbsp;of&nbsp;course&nbsp;private.&nbsp;&nbsp;A&nbsp;private&nbsp;variable&nbsp;or&nbsp;<BR>
function&nbsp;may&nbsp;only&nbsp;be&nbsp;referenced&nbsp;from&nbsp;inside&nbsp;the&nbsp;object&nbsp;which&nbsp;declares&nbsp;it.&nbsp;&nbsp;<BR>
If&nbsp;object&nbsp;A&nbsp;or&nbsp;B&nbsp;tried&nbsp;to&nbsp;make&nbsp;any&nbsp;reference&nbsp;to&nbsp;any&nbsp;of&nbsp;the&nbsp;variables&nbsp;in&nbsp;<BR>
object&nbsp;C,&nbsp;an&nbsp;error&nbsp;would&nbsp;result,&nbsp;since&nbsp;the&nbsp;variables&nbsp;are&nbsp;said&nbsp;to&nbsp;be&nbsp;out&nbsp;of&nbsp;<BR>
scope,&nbsp;or&nbsp;not&nbsp;available&nbsp;to&nbsp;inheriting&nbsp;classes&nbsp;due&nbsp;to&nbsp;their&nbsp;private&nbsp;labels.&nbsp;&nbsp;<BR>
Functions,&nbsp;however,&nbsp;provide&nbsp;a&nbsp;unique&nbsp;challenge&nbsp;which&nbsp;variables&nbsp;do&nbsp;not.&nbsp;&nbsp;<BR>
External&nbsp;objects&nbsp;in&nbsp;LPC&nbsp;have&nbsp;the&nbsp;ability&nbsp;to&nbsp;call&nbsp;functions&nbsp;in&nbsp;other&nbsp;objects&nbsp;<BR>
through&nbsp;call&nbsp;others.&nbsp;&nbsp;The&nbsp;private&nbsp;label&nbsp;does&nbsp;not&nbsp;protect&nbsp;against&nbsp;call&nbsp;<BR>
others.&nbsp;<BR>
&nbsp;<BR>
To&nbsp;protect&nbsp;against&nbsp;call&nbsp;others,&nbsp;functions&nbsp;use&nbsp;the&nbsp;label&nbsp;static.&nbsp;&nbsp;A&nbsp;function&nbsp;<BR>
which&nbsp;is&nbsp;static&nbsp;may&nbsp;only&nbsp;be&nbsp;called&nbsp;from&nbsp;inside&nbsp;the&nbsp;complete&nbsp;object&nbsp;or&nbsp;<BR>
from&nbsp;the&nbsp;game&nbsp;driver.&nbsp;&nbsp;By&nbsp;complete&nbsp;object,&nbsp;I&nbsp;mean&nbsp;object&nbsp;A&nbsp;can&nbsp;call&nbsp;<BR>
static&nbsp;functions&nbsp;in&nbsp;the&nbsp;object&nbsp;C&nbsp;it&nbsp;inherits.&nbsp;&nbsp;The&nbsp;static&nbsp;only&nbsp;protects&nbsp;against&nbsp;<BR>
external&nbsp;call&nbsp;others.&nbsp;&nbsp;In&nbsp;addition,&nbsp;this_object()-&gt;foo()&nbsp;is&nbsp;considered&nbsp;an&nbsp;<BR>
internal&nbsp;call&nbsp;as&nbsp;far&nbsp;as&nbsp;the&nbsp;static&nbsp;label&nbsp;goes.&nbsp;<BR>
&nbsp;<BR>
Since&nbsp;variables&nbsp;cannot&nbsp;be&nbsp;referenced&nbsp;externally,&nbsp;there&nbsp;is&nbsp;no&nbsp;need&nbsp;for&nbsp;an&nbsp;<BR>
equivalent&nbsp;label&nbsp;for&nbsp;them.&nbsp;&nbsp;Somewhere&nbsp;along&nbsp;the&nbsp;line,&nbsp;someone&nbsp;decided&nbsp;<BR>
to&nbsp;muddy&nbsp;up&nbsp;the&nbsp;waters&nbsp;and&nbsp;use&nbsp;the&nbsp;static&nbsp;label&nbsp;with&nbsp;variables&nbsp;to&nbsp;have&nbsp;a&nbsp;<BR>
completely&nbsp;separate&nbsp;meaning.&nbsp;&nbsp;What&nbsp;is&nbsp;even&nbsp;more&nbsp;maddening&nbsp;is&nbsp;that&nbsp;this&nbsp;<BR>
label&nbsp;has&nbsp;nothing&nbsp;to&nbsp;do&nbsp;with&nbsp;what&nbsp;it&nbsp;means&nbsp;in&nbsp;the&nbsp;C&nbsp;programming&nbsp;<BR>
language.&nbsp;&nbsp;A&nbsp;static&nbsp;variable&nbsp;is&nbsp;simply&nbsp;a&nbsp;variable&nbsp;that&nbsp;does&nbsp;not&nbsp;get&nbsp;saved&nbsp;to&nbsp;<BR>
file&nbsp;through&nbsp;the&nbsp;efun&nbsp;save_object()&nbsp;and&nbsp;does&nbsp;not&nbsp;get&nbsp;restored&nbsp;through&nbsp;<BR>
restore_object().&nbsp;&nbsp;Go&nbsp;figure.&nbsp;<BR>
&nbsp;<BR>
In&nbsp;general,&nbsp;it&nbsp;is&nbsp;good&nbsp;practice&nbsp;to&nbsp;have&nbsp;private&nbsp;variables&nbsp;with&nbsp;public&nbsp;<BR>
functions,&nbsp;using&nbsp;query_*()&nbsp;functions&nbsp;to&nbsp;access&nbsp;the&nbsp;values&nbsp;of&nbsp;inherited&nbsp;<BR>
variables,&nbsp;and&nbsp;set_*(),&nbsp;add_*(),&nbsp;and&nbsp;other&nbsp;such&nbsp;functions&nbsp;to&nbsp;change&nbsp;<BR>
those&nbsp;values.&nbsp;&nbsp;In&nbsp;realm&nbsp;coding&nbsp;this&nbsp;is&nbsp;not&nbsp;something&nbsp;one&nbsp;really&nbsp;has&nbsp;to&nbsp;<BR>
worry&nbsp;a&nbsp;lot&nbsp;about.&nbsp;&nbsp;As&nbsp;a&nbsp;matter&nbsp;of&nbsp;fact,&nbsp;in&nbsp;realm&nbsp;coding&nbsp;you&nbsp;do&nbsp;not&nbsp;have&nbsp;<BR>
to&nbsp;know&nbsp;much&nbsp;of&nbsp;anything&nbsp;which&nbsp;is&nbsp;in&nbsp;this&nbsp;chapter.&nbsp;&nbsp;To&nbsp;be&nbsp;come&nbsp;a&nbsp;really&nbsp;<BR>
good&nbsp;realm&nbsp;coder,&nbsp;however,&nbsp;you&nbsp;have&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;read&nbsp;the&nbsp;mudlib&nbsp;<BR>
code.&nbsp;&nbsp;And&nbsp;mudlib&nbsp;code&nbsp;is&nbsp;full&nbsp;of&nbsp;these&nbsp;labels.&nbsp;&nbsp;So&nbsp;you&nbsp;should&nbsp;work&nbsp;<BR>
around&nbsp;with&nbsp;these&nbsp;labels&nbsp;until&nbsp;you&nbsp;can&nbsp;read&nbsp;code&nbsp;and&nbsp;understand&nbsp;why&nbsp;it&nbsp;<BR>
is&nbsp;written&nbsp;that&nbsp;way&nbsp;and&nbsp;what&nbsp;it&nbsp;means&nbsp;to&nbsp;objects&nbsp;which&nbsp;inherit&nbsp;the&nbsp;code.&nbsp;<BR>
&nbsp;<BR>
The&nbsp;final&nbsp;label&nbsp;is&nbsp;nomask,&nbsp;and&nbsp;it&nbsp;deals&nbsp;with&nbsp;a&nbsp;property&nbsp;of&nbsp;inheritance&nbsp;<BR>
which&nbsp;allows&nbsp;you&nbsp;to&nbsp;rewrite&nbsp;functions&nbsp;which&nbsp;have&nbsp;already&nbsp;been&nbsp;defined.&nbsp;&nbsp;<BR>
For&nbsp;example,&nbsp;you&nbsp;can&nbsp;see&nbsp;above&nbsp;that&nbsp;object&nbsp;A&nbsp;rewrote&nbsp;the&nbsp;function&nbsp;<BR>
query_cap_name().&nbsp;&nbsp;A&nbsp;rewrite&nbsp;of&nbsp;&nbsp;function&nbsp;is&nbsp;called&nbsp;overriding&nbsp;the&nbsp;<BR>
function.&nbsp;&nbsp;The&nbsp;most&nbsp;common&nbsp;override&nbsp;of&nbsp;a&nbsp;function&nbsp;would&nbsp;be&nbsp;in&nbsp;a&nbsp;case&nbsp;<BR>
like&nbsp;this,&nbsp;where&nbsp;a&nbsp;condition&nbsp;peculiar&nbsp;to&nbsp;our&nbsp;object&nbsp;(object&nbsp;A)&nbsp;needs&nbsp;to&nbsp;<BR>
happen&nbsp;on&nbsp;a&nbsp;call&nbsp;ot&nbsp;the&nbsp;function&nbsp;under&nbsp;certain&nbsp;circumstances.&nbsp;&nbsp;Putting&nbsp;test&nbsp;<BR>
code&nbsp;into&nbsp;object&nbsp;C&nbsp;just&nbsp;so&nbsp;object&nbsp;A&nbsp;can&nbsp;be&nbsp;a&nbsp;ghost&nbsp;is&nbsp;plain&nbsp;silly.&nbsp;&nbsp;So&nbsp;<BR>
instead,&nbsp;we&nbsp;override&nbsp;query_cap_name()&nbsp;in&nbsp;object&nbsp;A,&nbsp;testing&nbsp;to&nbsp;see&nbsp;if&nbsp;the&nbsp;<BR>
object&nbsp;is&nbsp;a&nbsp;ghost.&nbsp;&nbsp;If&nbsp;so,&nbsp;we&nbsp;change&nbsp;what&nbsp;happens&nbsp;when&nbsp;another&nbsp;object&nbsp;<BR>
queries&nbsp;for&nbsp;the&nbsp;cap&nbsp;name.&nbsp;&nbsp;If&nbsp;it&nbsp;is&nbsp;not&nbsp;a&nbsp;ghost,&nbsp;then&nbsp;we&nbsp;want&nbsp;the&nbsp;regular&nbsp;<BR>
object&nbsp;behaviour&nbsp;to&nbsp;happen.&nbsp;&nbsp;We&nbsp;therefore&nbsp;use&nbsp;the&nbsp;scope&nbsp;resolution&nbsp;<BR>
operator&nbsp;(::)&nbsp;to&nbsp;call&nbsp;the&nbsp;inherited&nbsp;version&nbsp;of&nbsp;the&nbsp;query_cap_name()&nbsp;<BR>
function&nbsp;and&nbsp;return&nbsp;its&nbsp;value.&nbsp;<BR>
&nbsp;<BR>
A&nbsp;nomask&nbsp;function&nbsp;is&nbsp;one&nbsp;which&nbsp;cannot&nbsp;be&nbsp;overridden&nbsp;either&nbsp;through&nbsp;<BR>
inheritance&nbsp;or&nbsp;through&nbsp;shadowing.&nbsp;&nbsp;Shadowing&nbsp;is&nbsp;a&nbsp;sort&nbsp;of&nbsp;backwards&nbsp;<BR>
inheritance&nbsp;which&nbsp;will&nbsp;be&nbsp;detailed&nbsp;in&nbsp;the&nbsp;advanced&nbsp;LPC&nbsp;textbook.&nbsp;&nbsp;In&nbsp;the&nbsp;<BR>
example&nbsp;above,&nbsp;neither&nbsp;object&nbsp;A&nbsp;nor&nbsp;object&nbsp;B&nbsp;(nor&nbsp;any&nbsp;other&nbsp;object&nbsp;for&nbsp;<BR>
that&nbsp;matter)&nbsp;can&nbsp;override&nbsp;query_name().&nbsp;&nbsp;Since&nbsp;we&nbsp;want&nbsp;to&nbsp;use&nbsp;<BR>
query_name()&nbsp;as&nbsp;a&nbsp;unique&nbsp;identifier&nbsp;of&nbsp;objects,&nbsp;we&nbsp;don't&nbsp;want&nbsp;people&nbsp;<BR>
faking&nbsp;us&nbsp;through&nbsp;shadowing&nbsp;or&nbsp;inheritance.&nbsp;&nbsp;The&nbsp;function&nbsp;therefore&nbsp;gets&nbsp;<BR>
the&nbsp;nomask&nbsp;label.&nbsp;<BR>
&nbsp;<BR>
6.5&nbsp;Summary&nbsp;<BR>
Through&nbsp;inheritance,&nbsp;a&nbsp;coder&nbsp;may&nbsp;make&nbsp;user&nbsp;of&nbsp;functions&nbsp;defined&nbsp;in&nbsp;<BR>
other&nbsp;objects&nbsp;in&nbsp;order&nbsp;to&nbsp;reduce&nbsp;the&nbsp;tedium&nbsp;of&nbsp;producing&nbsp;masses&nbsp;of&nbsp;<BR>
similar&nbsp;objects&nbsp;and&nbsp;to&nbsp;increase&nbsp;the&nbsp;consistency&nbsp;of&nbsp;object&nbsp;behaviour&nbsp;across&nbsp;<BR>
mudlib&nbsp;objects.&nbsp;&nbsp;LPC&nbsp;inheritance&nbsp;allows&nbsp;objects&nbsp;maximum&nbsp;priveledges&nbsp;in&nbsp;<BR>
defining&nbsp;how&nbsp;their&nbsp;data&nbsp;can&nbsp;be&nbsp;accessed&nbsp;by&nbsp;external&nbsp;objects&nbsp;as&nbsp;well&nbsp;as&nbsp;<BR>
objects&nbsp;inheriting&nbsp;them.&nbsp;&nbsp;This&nbsp;data&nbsp;security&nbsp;is&nbsp;maintained&nbsp;through&nbsp;the&nbsp;<BR>
keywords,&nbsp;nomask,&nbsp;private,&nbsp;and&nbsp;static.&nbsp;<BR>
&nbsp;<BR>
In&nbsp;addition,&nbsp;a&nbsp;coder&nbsp;is&nbsp;able&nbsp;to&nbsp;change&nbsp;the&nbsp;functionality&nbsp;of&nbsp;non-protected&nbsp;<BR>
functions&nbsp;by&nbsp;overriding&nbsp;them.&nbsp;&nbsp;Even&nbsp;in&nbsp;the&nbsp;process&nbsp;of&nbsp;overriding&nbsp;a&nbsp;<BR>
function,&nbsp;however,&nbsp;an&nbsp;object&nbsp;may&nbsp;access&nbsp;the&nbsp;original&nbsp;function&nbsp;through&nbsp;<BR>
the&nbsp;scope&nbsp;resolution&nbsp;operator.&nbsp;<BR>
&nbsp;<BR>
Copyright&nbsp;(c)&nbsp;George&nbsp;Reese&nbsp;1993&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
小樓一夜聽秋雨&nbsp;<BR>
--&nbsp;<BR>
佇倚危樓風細細&nbsp;望極春愁&nbsp;黯黯生天際&nbsp;&nbsp;草色煙光殘照裡&nbsp;無言誰會憑欄意[0&nbsp;<BR>
擬把疏狂圖一醉&nbsp;對酒當歌&nbsp;強樂還無味&nbsp;&nbsp;衣帶漸寬終不悔&nbsp;為伊消得人憔悴&nbsp;<BR>
&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;166.111.5.25]&nbsp;<BR>
<A HREF="00000016.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000018.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>