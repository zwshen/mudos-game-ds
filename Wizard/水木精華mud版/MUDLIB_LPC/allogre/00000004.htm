<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;sorceress&nbsp;(李大善人~~~以德服人),&nbsp;信區:&nbsp;Mud_Builder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Allegro&nbsp;遊戲程序庫&nbsp;（時鐘例程）&nbsp;(轉載)&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Mon&nbsp;Jun&nbsp;12&nbsp;20:41:33&nbsp;2000)&nbsp;<BR>
&nbsp;<BR>
【&nbsp;以下文字轉載自&nbsp;GAME_Designer&nbsp;討論區&nbsp;】&nbsp;<BR>
【&nbsp;原文由&nbsp;cloudwu&nbsp;所發表&nbsp;】&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______&nbsp;&nbsp;&nbsp;___&nbsp;&nbsp;&nbsp;&nbsp;___&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/\&nbsp;&nbsp;_&nbsp;&nbsp;\&nbsp;/\_&nbsp;\&nbsp;&nbsp;/\_&nbsp;\&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;\&nbsp;\L\&nbsp;\\//\&nbsp;\&nbsp;\//\&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__&nbsp;&nbsp;&nbsp;_&nbsp;__&nbsp;&nbsp;&nbsp;___&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;\&nbsp;&nbsp;__&nbsp;\&nbsp;\&nbsp;\&nbsp;\&nbsp;&nbsp;\&nbsp;\&nbsp;\&nbsp;&nbsp;&nbsp;/'__`\&nbsp;/'_&nbsp;`\/\`'__\/&nbsp;__`\&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;\&nbsp;\/\&nbsp;\&nbsp;\_\&nbsp;\_&nbsp;\_\&nbsp;\_/\&nbsp;&nbsp;__//\&nbsp;\L\&nbsp;\&nbsp;\&nbsp;\//\&nbsp;\L\&nbsp;\&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;\_\&nbsp;\_\/\____\/\____\&nbsp;\____\&nbsp;\____&nbsp;\&nbsp;\_\\&nbsp;\____/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/_/\/_/\/____/\/____/\/____/\/___L\&nbsp;\/_/&nbsp;\/___/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\____/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\_/__/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.0&nbsp;版&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一個遊戲程序庫&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By&nbsp;Shawn&nbsp;Hargreaves,&nbsp;1994/97&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;雲風&nbsp;譯&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="http://www.nease.net/~cloudwu">http://www.nease.net/~cloudwu</A>&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E-mail:<A HREF="mailto:cloudwu@nease.net">cloudwu@nease.net</A>&nbsp;<BR>
&nbsp;<BR>
========================================&nbsp;<BR>
============&nbsp;&nbsp;&nbsp;&nbsp;時鐘例程&nbsp;&nbsp;&nbsp;&nbsp;============&nbsp;<BR>
========================================&nbsp;<BR>
基本的&nbsp;PC&nbsp;時鐘只能是每秒觸發&nbsp;18.2&nbsp;次,&nbsp;這對於快節奏的動作遊戲不&nbsp;<BR>
是很適用.&nbsp;Allegro&nbsp;可以用重新設置過的一個時鐘例程來代替系統原來&nbsp;<BR>
的,這個重編程過的時鐘有更高的觸發頻率,但是仍然以以前的速度調用&nbsp;<BR>
BIOS&nbsp;處理程序.你可以設置幾個你自己的虛擬時鐘,&nbsp;每個可以以不同的&nbsp;<BR>
速度運行,&nbsp;Allegro&nbsp;將不斷的重編程時鐘使它們在正確的時間被調用.&nbsp;<BR>
因為&nbsp;Allegro&nbsp;改變了&nbsp;PIT&nbsp;始終芯片的設置,&nbsp;它不能和&nbsp;djgpp&nbsp;的&nbsp;libc&nbsp;<BR>
裡的&nbsp;uclock()&nbsp;函數一起使用.&nbsp;<BR>
&nbsp;<BR>
int&nbsp;install_timer();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;加載&nbsp;Allegro&nbsp;時鐘中斷處理程序.&nbsp;你必須在加載任何用戶時鐘例程&nbsp;<BR>
&nbsp;&nbsp;&nbsp;之前,&nbsp;和在顯示鼠標,&nbsp;播放&nbsp;FLI&nbsp;動畫或者&nbsp;MIDI&nbsp;音樂,使用其它的&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;GUI&nbsp;例程之前執行它.&nbsp;<BR>
&nbsp;<BR>
void&nbsp;remove_timer();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;卸載&nbsp;Allegro&nbsp;時鐘處理程序並且將時鐘的控制權交還&nbsp;BIOS.你不必&nbsp;<BR>
&nbsp;&nbsp;&nbsp;明顯的調用它,因為&nbsp;allegro_exit()&nbsp;將為你做這些.&nbsp;<BR>
&nbsp;<BR>
int&nbsp;install_int(void&nbsp;(*proc)(),&nbsp;int&nbsp;speed);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;加載用戶始終處理程序,&nbsp;參數&nbsp;speed&nbsp;的單位為萬分之一秒.&nbsp;它和&nbsp;<BR>
&nbsp;&nbsp;&nbsp;install_int_ex(proc,&nbsp;MSEC_TO_TIMER(speed))&nbsp;作用相同.&nbsp;<BR>
&nbsp;<BR>
int&nbsp;install_int_ex(void&nbsp;(*proc)(),&nbsp;int&nbsp;speed);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;在用戶時鐘處理程序列表上加一個函數,&nbsp;如果這個函數已經被加載,&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;則調整它的速度.&nbsp;spped&nbsp;的單位為硬件時鐘單位,&nbsp;即&nbsp;1193181&nbsp;分之&nbsp;<BR>
&nbsp;&nbsp;&nbsp;一秒.&nbsp;你可以利用以下的宏將其它時間單位轉換到這個單位上:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SECS_TO_TIMER(secs)&nbsp;&nbsp;-&nbsp;給出兩次觸發間的秒數&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MSEC_TO_TIMER(msec)&nbsp;&nbsp;-&nbsp;給出兩次觸發間的萬分之一秒數&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BPS_TO_TIMER(bps)&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;給出每秒觸發多少次&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BPM_TO_TIMER(bpm)&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;給出每分鐘觸發多少次&nbsp;<BR>
&nbsp;&nbsp;&nbsp;如果沒有空間再增加新的用戶時鐘程序,&nbsp;install_int_ex()&nbsp;將返回&nbsp;<BR>
&nbsp;&nbsp;&nbsp;一個負值,&nbsp;否則返回零.&nbsp;同時只能有&nbsp;16&nbsp;個時鐘程序在使用,&nbsp;&nbsp;並且&nbsp;<BR>
&nbsp;&nbsp;&nbsp;Allegro&nbsp;的其它部分&nbsp;(GUI&nbsp;代碼,鼠標顯示例程,&nbsp;rest(),&nbsp;FLI&nbsp;播放&nbsp;<BR>
&nbsp;&nbsp;&nbsp;程序,&nbsp;和&nbsp;MIDI&nbsp;播放程序)需要加載它們自己的處理程序,&nbsp;因此你要&nbsp;<BR>
&nbsp;&nbsp;&nbsp;避免同時使用它過多.&nbsp;你的函數將被&nbsp;Allegro&nbsp;中斷處理程序調用而&nbsp;<BR>
&nbsp;&nbsp;&nbsp;不是被處理器直接調用,&nbsp;所以它能夠按正常的&nbsp;C&nbsp;函數來寫而不需要&nbsp;<BR>
&nbsp;&nbsp;&nbsp;特別的包裝.&nbsp;然而,&nbsp;你必須知道,它將在一個中斷中被調用,&nbsp;而這給&nbsp;<BR>
&nbsp;&nbsp;&nbsp;你希望在函數中做的事增加了許多約束.&nbsp;它不能使用大數量的堆棧,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;不能調用任何&nbsp;DOS&nbsp;例程和使用調用了&nbsp;DOS&nbsp;例程的&nbsp;C&nbsp;庫函數,&nbsp;而且&nbsp;<BR>
&nbsp;&nbsp;&nbsp;它必須被很快的執行.不要在時鐘處理程序裡寫太多的複雜代碼:&nbsp;一&nbsp;<BR>
&nbsp;&nbsp;&nbsp;個基本的規則是&nbsp;你應該設置一些標誌然後在你的主控制循環裡來回&nbsp;<BR>
&nbsp;&nbsp;&nbsp;應它們.&nbsp;如果你正在用&nbsp;C++&nbsp;編程,&nbsp;在使用&nbsp;install_int()&nbsp;或者&nbsp;<BR>
&nbsp;&nbsp;&nbsp;install_int_ex()&nbsp;的地方你將發現&nbsp;gcc&nbsp;的出錯信息.為了避免這個,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;你必須按變量數目可變的方式說明你的函數,&nbsp;像這樣:&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;my_timer_handler(...);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;在像&nbsp;djgpp&nbsp;這樣的保護模式環境裡,&nbsp;內存被虛擬化並可以向磁盤交&nbsp;<BR>
&nbsp;&nbsp;&nbsp;換.由於&nbsp;DOS&nbsp;的不可重入,&nbsp;如果磁盤交換發生在中斷處理程序內部,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;系統將痛苦的死機,所以你需要確認你鎖住了所有時鐘例程中觸及的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;所有內存(包括代碼和數據).&nbsp;Allegro&nbsp;將鎖住它用的所有東西,但是&nbsp;<BR>
&nbsp;&nbsp;&nbsp;你有責任鎖住你自己處理程序的.&nbsp;宏&nbsp;LOCK_VARIABLE(變量),&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;END_OF_FUNCTION(函數名),和&nbsp;LOCK_FUNCTION(函數名)&nbsp;可以被用來&nbsp;<BR>
&nbsp;&nbsp;&nbsp;簡化這項任務.例如,&nbsp;你想用一個中斷處理程序來增加一個記數變量,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;就應該這樣寫:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;int&nbsp;counter;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;my_timer_handler()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END_OF_FUNCTION(my_timer_handler);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;在你的初始化代碼裡,應該鎖住內存:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK_VARIABLE(counter);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOCK_FUNCTION(my_timer_handler);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;很明顯,如果你使用了複雜的數據結構並且在這個處理程序中調用了其&nbsp;<BR>
&nbsp;&nbsp;&nbsp;它的函數,這就顯得很笨拙,所以你應該使你的中斷處理程序盡量簡潔.&nbsp;<BR>
&nbsp;<BR>
void&nbsp;remove_int(void&nbsp;(*proc)());&nbsp;<BR>
&nbsp;&nbsp;&nbsp;從用戶中斷例程列表中卸載一個函數.在程序的結束處,allegro_exit()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;會自動運行它.&nbsp;<BR>
&nbsp;<BR>
extern&nbsp;int&nbsp;i_love_bill;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;如果被設為&nbsp;TRUE,&nbsp;打開專門的&nbsp;'windows&nbsp;friendly'(對瘟都死友好)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;時鐘模式,這將硬件時鐘中斷鎖在&nbsp;200&nbsp;次每秒的速度,而不是對它動&nbsp;<BR>
&nbsp;&nbsp;&nbsp;態重編程.這個模式減少了時鐘的精確性&nbsp;(例如,&nbsp;rest()&nbsp;將延時長度&nbsp;<BR>
&nbsp;&nbsp;&nbsp;誤差在&nbsp;5&nbsp;個百萬分之一秒左右),並且阻止了垂直回掃模擬器的工作&nbsp;<BR>
&nbsp;&nbsp;&nbsp;(&nbsp;在這個模式下對&nbsp;timer_simulate_retrace()&nbsp;的調用被忽略).&nbsp;然&nbsp;<BR>
&nbsp;&nbsp;&nbsp;而,&nbsp;它帶來的好處是,&nbsp;使得&nbsp;Allegro&nbsp;程序可以工作在&nbsp;windows&nbsp;3.1&nbsp;<BR>
&nbsp;&nbsp;&nbsp;下,而且使在&nbsp;win95&nbsp;的&nbsp;DOS&nbsp;模式下運行而沒有出錯信息.&nbsp;這個標記&nbsp;<BR>
&nbsp;&nbsp;&nbsp;應該在你加載始終模塊前被設置,&nbsp;而且在時鐘在激活時不能改變它.&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;缺省狀態下,&nbsp;allegro_init()&nbsp;如果檢測到&nbsp;windows&nbsp;的存在,將打開&nbsp;<BR>
&nbsp;&nbsp;&nbsp;這個模式.&nbsp;<BR>
&nbsp;<BR>
void&nbsp;timer_simulate_retrace(int&nbsp;enable);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;時鐘處理程序可以被用來模擬垂直回掃中斷.回掃中斷在處理平滑動&nbsp;<BR>
&nbsp;&nbsp;&nbsp;畫時極其有用,&nbsp;而且是三緩衝(triple&nbsp;buffering)所必不可少的,但&nbsp;<BR>
&nbsp;&nbsp;&nbsp;不幸的是,VGA&nbsp;硬件不支持它.&nbsp;EGA&nbsp;有,一些&nbsp;SVGA&nbsp;卡也有,但著不夠,&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;那些方法不夠標準,來使其變的有用.&nbsp;Allegro&nbsp;使這些運作起來依靠&nbsp;<BR>
&nbsp;&nbsp;&nbsp;的是對時鐘編程使其成為一個普通的中斷,當它認為下一次回掃將要&nbsp;<BR>
&nbsp;&nbsp;&nbsp;發生時在中斷處理程序裡輪詢(polling)&nbsp;VGA&nbsp;確認處於顯示器刷新&nbsp;<BR>
&nbsp;&nbsp;&nbsp;時的&nbsp;sync(垂直回掃同步)中.這些在一些情況下工作的非常好,但是&nbsp;<BR>
&nbsp;&nbsp;&nbsp;它有一大堆限制:&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;-&nbsp;在&nbsp;SVGA&nbsp;模式下不要在任何時候都用回掃模擬器.它只能在某些芯&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;片上用,而在其它的芯片上不行,&nbsp;並且它和所有的&nbsp;VESA&nbsp;提供工具&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有衝突.回掃模擬器僅僅在&nbsp;VGA&nbsp;13h&nbsp;模式和&nbsp;mode-X&nbsp;下可信.&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;-&nbsp;回掃模擬器不能工作在&nbsp;win95&nbsp;下,&nbsp;因為&nbsp;win95&nbsp;在我試著從&nbsp;PIT&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;裡讀取逝去的時間時返回的是一些垃圾.如果有人知道我應該怎麼&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做這些,請告訴我!&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;-&nbsp;回掃模擬器在時鐘處理程序裡關掉了中斷造成了許多的等待.這將&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使你的整個系統慢下來,還可能在用&nbsp;SB&nbsp;1.0&nbsp;聲卡播放聲音時造成&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;無聲&nbsp;(因為它們不支持自動初始化&nbsp;DMA:&nbsp;SB&nbsp;2.0&nbsp;及以上版本沒有&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;問題).&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;由於要忍受這麼多的問題,&nbsp;我強烈建議你不要依賴於回掃模擬器.如&nbsp;<BR>
&nbsp;&nbsp;&nbsp;果你在&nbsp;mode-X&nbsp;下編程,而且不在乎你的程序能否在&nbsp;win95&nbsp;下使用,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;它好極了&nbsp;,但交給用戶一個可以關掉它的開關卻是個好主意.回掃模&nbsp;<BR>
&nbsp;&nbsp;&nbsp;擬器在你使用三緩衝&nbsp;request_modex-scroll()&nbsp;函數前必須被打開.&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;它也可以被用在簡單的回掃檢測上,&nbsp;因為輪詢&nbsp;vsync()&nbsp;函數在聲卡&nbsp;<BR>
&nbsp;&nbsp;&nbsp;或時鐘中斷正好發生在回掃的同時時,偶爾會丟失回掃.&nbsp;當回掃中斷&nbsp;<BR>
&nbsp;&nbsp;&nbsp;模擬器打開,&nbsp;vsync()&nbsp;將檢查&nbsp;retrace_count(回掃計數器)&nbsp;變量而&nbsp;<BR>
&nbsp;&nbsp;&nbsp;不是輪詢&nbsp;VGA,&nbsp;因此只有在它們被其它中斷屏蔽時才會丟失回掃.&nbsp;<BR>
&nbsp;<BR>
extern&nbsp;volatile&nbsp;int&nbsp;retrace_count;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;如果回掃模擬器被加載,這個會隨著每次垂直回掃而遞增,&nbsp;否則它將&nbsp;<BR>
&nbsp;&nbsp;&nbsp;每秒遞增&nbsp;70&nbsp;次&nbsp;(忽略回掃).&nbsp;這提供了一個避開加載用戶時鐘中斷&nbsp;<BR>
&nbsp;&nbsp;&nbsp;函數的麻煩而控制你的程序速度的有效方法.回掃變量的速度依賴於&nbsp;<BR>
&nbsp;&nbsp;&nbsp;圖形模式.&nbsp;在&nbsp;13h&nbsp;模式和&nbsp;200/400&nbsp;行的&nbsp;mode-X&nbsp;分辨率下是每秒&nbsp;<BR>
&nbsp;&nbsp;&nbsp;70&nbsp;次&nbsp;回掃,在&nbsp;240/480&nbsp;行模式下是&nbsp;60&nbsp;次.&nbsp;它可以被慢到&nbsp;50&nbsp;次&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;(在&nbsp;376x282&nbsp;模式下)&nbsp;也可能高到&nbsp;92&nbsp;次&nbsp;(在&nbsp;400x300&nbsp;模式下).&nbsp;<BR>
&nbsp;<BR>
extern&nbsp;void&nbsp;(*retrace_proc)();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;如果回掃模擬器被加載,&nbsp;這個函數將在每次垂直回掃時被調用,否則&nbsp;<BR>
&nbsp;&nbsp;&nbsp;將被每秒調用&nbsp;70&nbsp;次&nbsp;(忽略回掃).將其設置為&nbsp;NULL&nbsp;可以關掉回叫.&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;這個函數必須遵守和中斷函數相同的規則&nbsp;(即,&nbsp;它必須被鎖住,不能&nbsp;<BR>
&nbsp;&nbsp;&nbsp;調用&nbsp;DOS&nbsp;或&nbsp;libc&nbsp;函數)&nbsp;而且更甚的是:&nbsp;它必須被&nbsp;_非常_&nbsp;快的執&nbsp;<BR>
&nbsp;&nbsp;&nbsp;行,&nbsp;否則回對時鐘同步造成混亂.我能想到的唯一作用是用來對調色&nbsp;<BR>
&nbsp;&nbsp;&nbsp;板做一些巧妙的處理,而三緩衝能夠用&nbsp;request_modex_scroll()&nbsp;函&nbsp;<BR>
&nbsp;&nbsp;&nbsp;數來實現,&nbsp;且&nbsp;retrace_count&nbsp;變量可以用來對你的代碼記時.&nbsp;如果&nbsp;<BR>
&nbsp;&nbsp;&nbsp;你希望在&nbsp;retrace_proc&nbsp;裡來改變調色板,則應該使用&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;inline&nbsp;_set_color()&nbsp;函數而不是常規的&nbsp;set_color()&nbsp;或&nbsp;<BR>
&nbsp;&nbsp;&nbsp;set_palette(),&nbsp;而且你不要去嘗試在一次回掃中改變二或三個以上&nbsp;<BR>
&nbsp;&nbsp;&nbsp;的調色板入口.&nbsp;<BR>
&nbsp;<BR>
void&nbsp;rest(long&nbsp;time);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;Allegro&nbsp;一度接管了時鐘,&nbsp;基本的&nbsp;delay()&nbsp;函數將不能再工作,&nbsp;所&nbsp;<BR>
&nbsp;&nbsp;&nbsp;以你必須使用這個例程來代替.&nbsp;時間的單位是百萬分之一秒.&nbsp;<BR>
&nbsp;<BR>
void&nbsp;rest_callback(long&nbsp;time,&nbsp;void&nbsp;(*callback)())&nbsp;<BR>
&nbsp;&nbsp;&nbsp;有點像&nbsp;rest(),&nbsp;不過它在等待所需的離開時間的同時將不停的調用&nbsp;<BR>
&nbsp;&nbsp;&nbsp;指定的函數.&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
<A HREF="http://www.nease.net/~cloudwu">http://www.nease.net/~cloudwu</A>&nbsp;<BR>
<A HREF="http://computer.igd.edu.cn/~cloud">http://computer.igd.edu.cn/~cloud</A>&nbsp;<BR>
E-mail:&nbsp;<A HREF="mailto:cloudwu@163.net">cloudwu@163.net</A>&nbsp;<BR>
&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;202.197.71.21]&nbsp;<BR>
<A HREF="00000003.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000005.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>