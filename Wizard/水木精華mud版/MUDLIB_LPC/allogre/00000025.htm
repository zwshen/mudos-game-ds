<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;sorceress&nbsp;(李大善人~~~以德服人),&nbsp;信區:&nbsp;Mud_Builder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Allegro&nbsp;中譯文檔(圖形模式)&nbsp;(轉載)&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Mon&nbsp;Jun&nbsp;12&nbsp;20:53:16&nbsp;2000)&nbsp;<BR>
&nbsp;<BR>
【&nbsp;以下文字轉載自&nbsp;GAME_Designer&nbsp;討論區&nbsp;】&nbsp;<BR>
【&nbsp;原文由&nbsp;cloudwu&nbsp;所發表&nbsp;】&nbsp;<BR>
圖形模式&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_color_depth&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_gfx_mode&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gfx_capabilities&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scroll_screen&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request_scroll&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poll_scroll&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_video_bitmap&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request_video_bitmap&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request_modex_scroll&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poll_modex_scroll&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split_modex_screen&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_color_depth(int&nbsp;depth);&nbsp;<BR>
設置點的格式來由隨後調用&nbsp;set_gfx_mode()&nbsp;和&nbsp;create_bitmap()&nbsp;時使用.&nbsp;有效的顏色深&nbsp;<BR>
度有&nbsp;8&nbsp;(缺省值),&nbsp;15,&nbsp;16,&nbsp;24,&nbsp;和&nbsp;32&nbsp;位.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
int&nbsp;set_gfx_mode(int&nbsp;card,&nbsp;int&nbsp;w,&nbsp;int&nbsp;h,&nbsp;int&nbsp;v_w,&nbsp;int&nbsp;v_h);&nbsp;<BR>
切換圖形模式.&nbsp;參數&nbsp;card&nbsp;必須是以下值中的一個:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_TEXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;返回文本模式&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_AUTODETECT&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;讓&nbsp;Allegro&nbsp;選擇一個合適的圖形驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VGA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;選擇&nbsp;VGA&nbsp;模式&nbsp;13h&nbsp;(320x200&nbsp;或&nbsp;320x100)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_MODEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;選擇平面扭轉的(plannar&nbsp;tweaked)&nbsp;VGA&nbsp;模式&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VESA1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;VESA&nbsp;1.x&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VESA2B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;VBE&nbsp;2.0&nbsp;分頁模式驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VESA2L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;VBE&nbsp;2.0&nbsp;線形頁面緩衝驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VESA3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;VBE&nbsp;3.0&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VBEAF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;VBE/AF&nbsp;加速器&nbsp;API&nbsp;(未完成)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_XTENDED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用斷鏈式(unchained)&nbsp;640x400&nbsp;模式驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_ATI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;ATI&nbsp;18800/28800&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_MACH64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;ATI&nbsp;mach64&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_CIRRUS64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Cirrus&nbsp;64xx&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_CIRRUS54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Cirrus&nbsp;54xx&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_PARADISE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Paradise&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_S3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;S3&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_TRIDENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Trident&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_ET3000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Tseng&nbsp;ET3000&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_ET4000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Tseng&nbsp;ET4000&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_ET6000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Tseng&nbsp;ET6000&nbsp;驅動程序&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_VIDEO7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;使用&nbsp;Video-7&nbsp;驅動程序&nbsp;<BR>
&nbsp;<BR>
參數&nbsp;w&nbsp;和&nbsp;h&nbsp;指定了你想要的屏幕分辨率.&nbsp;可能的模式有:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;標準&nbsp;256&nbsp;色&nbsp;VGA&nbsp;13h&nbsp;模式,&nbsp;使用&nbsp;GFX_VGA&nbsp;驅動程序.&nbsp;它的正常&nbsp;大小為&nbsp;320x200,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;這個在任何&nbsp;VGA&nbsp;下都能工作,&nbsp;但是不支持大的虛擬屏幕和&nbsp;硬件滾屏.&nbsp;Allegro&nbsp;也提&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;供了&nbsp;一些扭轉(tweaked)&nbsp;變形的可捲屏的模式,&nbsp;大小為&nbsp;320x100&nbsp;(200&nbsp;點高的虛擬屏&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幕),&nbsp;160x120&nbsp;(409&nbsp;點高的虛擬屏幕),&nbsp;和&nbsp;80x80&nbsp;(819&nbsp;點高的虛擬屏幕).&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mode-X,&nbsp;使用&nbsp;GFX_MODEX&nbsp;驅動程序.&nbsp;這個能夠在任何&nbsp;VGA&nbsp;卡上工作,&nbsp;提供了扭轉的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tweaked)&nbsp;分辨率和&nbsp;256&nbsp;種不同的顏色.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;穩定的&nbsp;mode-X&nbsp;分辨率:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正方形外觀的比例:&nbsp;320x240&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;長方形外觀的比例:&nbsp;256x224,&nbsp;256x240,&nbsp;320x200,&nbsp;320x400,&nbsp;320x480,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;320x600,&nbsp;360x200,&nbsp;360x240,&nbsp;360x360,&nbsp;360x400,&nbsp;360x480&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;這些我在所有的顯卡的顯示器上都測試通過了.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不穩定的&nbsp;mode-X&nbsp;分辨率:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正方形外觀的比例:&nbsp;360x270,&nbsp;376x282,&nbsp;400x300&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;長方形外觀的比例:&nbsp;256x200,&nbsp;256x256,&nbsp;320x350,&nbsp;360x600,&nbsp;376x308,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;376x564,&nbsp;400x150,&nbsp;400x600&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;這些只能在部分顯示器上工作.&nbsp;它們可以在我的老&nbsp;機器上工作,&nbsp;但是在我的新&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顯示器上工作的不那麼好.&nbsp;如果你&nbsp;擔心使用這些模式會對你的顯示器可能造成&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;傷害,&nbsp;那麼大可不必.&nbsp;當然我不能向這個提供任何的&nbsp;擔保,&nbsp;也許你的硬件還是&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;燒掉了,&nbsp;但是我相信這一系列&nbsp;tweak&nbsp;模式不會造成任何危險.&nbsp;Robert&nbsp;Schmidt&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;的&nbsp;TWEAK&nbsp;程序文本裡寫道:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;一些時間以前,&nbsp;向顯卡寄存器裡置一些非法或是不被支持的值&nbsp;或組合可能對&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的顯示器和你的健康都是一種冒險.&nbsp;我&nbsp;*從來沒有*&nbsp;聲明如果你使用&nbsp;TWEAK&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不會有什麼壞的事情發生,&nbsp;然而我很樂意相信不會有.&nbsp;我從來沒有聽說&nbsp;在試著&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用&nbsp;TWEAK&nbsp;以外或一般的&nbsp;VGA&nbsp;扭轉(tweaking)&nbsp;時有什麼&nbsp;危險的事情發生.&quot;&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因為複雜的分頁位圖組織方式,&nbsp;所有的&nbsp;mode-x&nbsp;繪圖函數都比&nbsp;13h&nbsp;模式慢,&nbsp;但是整塊&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;的&nbsp;區域填充和平面調整方式的從顯存的一部分到另一部分的移動&nbsp;能夠更快點,&nbsp;尤其&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是在老的硬件上.&nbsp;Mode-X&nbsp;能尋址&nbsp;VGA&nbsp;RAM&nbsp;的整個&nbsp;256k&nbsp;空間,&nbsp;因此硬件滾屏和&nbsp;多頁&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面轉換就辦的到了,&nbsp;它也可以分割開屏幕&nbsp;來實現上部顯示部分的滾動,而下部分卻靜&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;止用來顯示一個&nbsp;狀態條.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;標準&nbsp;SVGA&nbsp;模式,&nbsp;640x480,&nbsp;800x600,&nbsp;和&nbsp;1024x768.&nbsp;這些能夠&nbsp;在任何&nbsp;SVGA&nbsp;卡上使&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用:&nbsp;如果不能用,&nbsp;就搞套&nbsp;SciTech&nbsp;Display&nbsp;Doctor&nbsp;看看能不能修好.&nbsp;顏色的深度依&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;賴於&nbsp;你的硬件.&nbsp;所有的卡都支持&nbsp;15&nbsp;和&nbsp;16&nbsp;位的顏色,&nbsp;但是我建議你盡可能的兩個都&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;去支持&nbsp;(這並不難...)&nbsp;因為有可能只有一種能用.&nbsp;一些卡對&nbsp;24&nbsp;和&nbsp;32&nbsp;位真彩色都提&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;供了,&nbsp;這樣你就有&nbsp;24&nbsp;(節約內存)&nbsp;和&nbsp;32&nbsp;(更快一些)&nbsp;兩種選擇,&nbsp;但是許多老卡沒有&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;位模式而&nbsp;一些新卡不支持&nbsp;24&nbsp;位&nbsp;分辨率.&nbsp;使用&nbsp;VESAINFO&nbsp;測試程序來看看你的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VESA&nbsp;驅動程序提供了哪些模式.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;許多顯卡還支持&nbsp;640x400,&nbsp;1280x1024,&nbsp;和&nbsp;1600x1200,&nbsp;但是這些&nbsp;不是在任何地方都&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能用的,&nbsp;比如&nbsp;S3&nbsp;芯片就沒有&nbsp;640x400&nbsp;模式.&nbsp;其它的奇異的分辨率也有,&nbsp;比如,&nbsp;一些&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tseng&nbsp;板&nbsp;可以實現&nbsp;640x350,&nbsp;還有&nbsp;Avance&nbsp;Logic&nbsp;有&nbsp;512x512&nbsp;模式.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xtended&nbsp;模式,&nbsp;由&nbsp;PCGPE&nbsp;的&nbsp;Mark&nbsp;Feldman&nbsp;描述,&nbsp;大小是&nbsp;640x400&nbsp;(256&nbsp;色)&nbsp;使用&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GFX_XTENDED&nbsp;驅動程序.&nbsp;這個使用&nbsp;VESA&nbsp;來選擇&nbsp;SVGA&nbsp;模式&nbsp;(所以它只能在支持&nbsp;VESA&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;640x400&nbsp;分辨率的卡上工作),&nbsp;然後像&nbsp;mode-X&nbsp;那樣將&nbsp;VGA&nbsp;硬件做斷鏈接處理&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unchain).&nbsp;這使得整個屏幕不需要&nbsp;頁切換尋址,&nbsp;但是硬件&nbsp;滾屏和多頁面轉換辦不&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到.&nbsp;這個驅動程序永遠不會&nbsp;被自動檢測到&nbsp;(取而代之的是正常的&nbsp;VESA&nbsp;640x400&nbsp;模&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;式),&nbsp;因此如果你想使用它就必須明確的向&nbsp;set_gfx_mode()&nbsp;傳入參數&nbsp;GFX_XTENDED.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scitech&nbsp;Display&nbsp;Doctor&nbsp;提供了一個可滾屏的低分辨率不同顏色深度的模式&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(320x200,&nbsp;320x240,&nbsp;320x400,&nbsp;320x480,&nbsp;360x200,&nbsp;360x240,&nbsp;360x400,&nbsp;和&nbsp;360x480&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;都可以在我的&nbsp;ET4000&nbsp;上&nbsp;以&nbsp;8,&nbsp;15,&nbsp;或&nbsp;16&nbsp;位&nbsp;工作).&nbsp;這些很可愛,&nbsp;讓我們不必&nbsp;使&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用複雜的&nbsp;mode-X&nbsp;平面設置就可以實現滾動和多頁面切換.&nbsp;可惜的是它們不是基本模&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;式,&nbsp;所以你需要&nbsp;Display&nbsp;Doctor&nbsp;來使用它們.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBE/AF&nbsp;是&nbsp;VBE&nbsp;2.0&nbsp;基本模式的超集,&nbsp;它提供了一個&nbsp;API&nbsp;來&nbsp;利用硬件加速特性.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBE/AF&nbsp;現在&nbsp;只能由&nbsp;FreeBE/AF&nbsp;工程或&nbsp;SciTech&nbsp;Display&nbsp;Doctor&nbsp;包的一部分來支&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;持,&nbsp;但是當你使用合適的硬件時&nbsp;他們可以使速度有戲劇性的增加.&nbsp;關於&nbsp;硬件加速的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;細節討論在&nbsp;gfx_capabilities&nbsp;標誌的文本中.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBE/AF&nbsp;驅動程序需要近指針(nearptr)&nbsp;控制打開,&nbsp;因此任何錯誤的&nbsp;指針都可能讓你&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;的機器在使用這個驅動程序時死掉.&nbsp;這就是說最好是在調試你的程序時使用&nbsp;VESA,&nbsp;當&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你的代碼工作正常了再切換到&nbsp;VBE/AF.&nbsp;&nbsp;<BR>
&nbsp;<BR>
參數&nbsp;v_w&nbsp;和&nbsp;v_h&nbsp;指定了最小虛擬屏幕的大小,&nbsp;因為&nbsp;你需要一個大的虛擬屏幕來做硬件滾&nbsp;<BR>
屏或多頁面切換.&nbsp;如果你不在乎虛擬屏幕的大小就應該將它們設為零.&nbsp;虛擬屏幕回造成許多&nbsp;<BR>
混亂,&nbsp;但是它們真的&nbsp;很簡單.&nbsp;留神:&nbsp;技術說明來了,&nbsp;所以你&nbsp;可以跳過這一段的剩下部分&nbsp;<BR>
︰<I>-)&nbsp;將顯示內存想像成&nbsp;一張矩形的紙,&nbsp;通過一個上面有一個小洞(你的顯示器)的卡片來看&nbsp;</I><BR>
它.&nbsp;既然紙比洞要大,&nbsp;你在任何時候就只能看見紙的一部分,&nbsp;但是移動卡片&nbsp;你就能改變看&nbsp;<BR>
到的景象.&nbsp;你能將洞放在一個地點而忽略顯示內存其它看不見的部分,&nbsp;但是你可以利用移動&nbsp;<BR>
屏幕窗口來實現許多有用的效果,&nbsp;或者可以在顯存隱藏的部分先畫好圖片然後&nbsp;切換過去來&nbsp;<BR>
顯示它們.&nbsp;&nbsp;<BR>
&nbsp;<BR>
舉個例子,&nbsp;你選擇了一個虛擬屏幕為&nbsp;1024x1024&nbsp;的&nbsp;640x480&nbsp;模式,&nbsp;然後可以在這個大區域&nbsp;<BR>
上移動可視的部分.&nbsp;初始化時,&nbsp;可視部分在&nbsp;顯存的左上角,&nbsp;這個設置看起來像這樣:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0,0)------------(640,0)----(1024,0)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;可視屏幕部分&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0,480)----------(640,480)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顯存的其它部分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0,1024)--------------------(1024,1024)&nbsp;<BR>
&nbsp;<BR>
這是什麼?&nbsp;你正在用相稱的字體來顯示?&nbsp;呵呵.&nbsp;&nbsp;<BR>
&nbsp;<BR>
當你調用&nbsp;set_gfx_mode()&nbsp;時,&nbsp;v_w&nbsp;和&nbsp;v_h&nbsp;參數&nbsp;提供你的程序能夠接受的最小虛擬屏幕的&nbsp;<BR>
大小.&nbsp;大小的範圍通常很受限制,&nbsp;Allegro&nbsp;一般&nbsp;最終會創建一個比你要求要大的多的虛擬&nbsp;<BR>
屏幕.&nbsp;在&nbsp;SVGA&nbsp;卡上一兆的顯存能夠讓你創建&nbsp;1024x1024&nbsp;的虛擬屏幕&nbsp;(256&nbsp;色)&nbsp;或是&nbsp;<BR>
1024x512&nbsp;(15&nbsp;或&nbsp;16&nbsp;bpp),&nbsp;而&nbsp;512k&nbsp;顯存你可以得到&nbsp;1024x512&nbsp;(256&nbsp;色).&nbsp;其它的大小可&nbsp;<BR>
能或不可能得到:&nbsp;不要假定它們能工作.&nbsp;在&nbsp;mode-X&nbsp;下虛擬屏幕的&nbsp;寬度可以是物理屏幕寬&nbsp;<BR>
度的&nbsp;8X&nbsp;倍或是與之相同,&nbsp;於是模擬高度就被相應的設定了&nbsp;(&nbsp;VGA&nbsp;有&nbsp;256K&nbsp;顯存,&nbsp;所以虛&nbsp;<BR>
擬高度將是&nbsp;256*1024/虛擬寬度).&nbsp;&nbsp;<BR>
&nbsp;<BR>
在你選擇一個圖形模式以後,&nbsp;物理的和虛擬的屏幕大小&nbsp;可以用宏&nbsp;SCREEN_W(),&nbsp;<BR>
SCREEN_H(),&nbsp;VIRTUAL_W(),&nbsp;和&nbsp;VIRTUAL_H()&nbsp;來測得.&nbsp;&nbsp;<BR>
&nbsp;<BR>
如果&nbsp;Allegro&nbsp;不能選擇一個合適的模式,&nbsp;set_gfx_mode()&nbsp;將返回一個負數並且將問題的描&nbsp;<BR>
述儲存在&nbsp;allegro_error&nbsp;裡.&nbsp;否則它返回零.&nbsp;&nbsp;<BR>
&nbsp;<BR>
extern&nbsp;int&nbsp;gfx_capabilities;&nbsp;<BR>
描述當前圖形卡驅動程序和顯示硬件的能力的位域.&nbsp;這可以包含下面標誌的任何組合:&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_CAN_SCROLL:&nbsp;<BR>
表示&nbsp;scroll_screen()&nbsp;函數可以被這個驅動程序使用.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_CAN_TRIPLE_BUFFER:&nbsp;<BR>
表示&nbsp;request_scroll()&nbsp;和&nbsp;poll_scroll()&nbsp;函數可以&nbsp;被這個驅動程序使用.&nbsp;作為一個特殊&nbsp;<BR>
的條件,&nbsp;mode-X&nbsp;驅動程序僅僅&nbsp;在回掃模擬器加載後才支持三緩衝,&nbsp;因此在&nbsp;mode-X&nbsp;的分辨&nbsp;<BR>
率下&nbsp;你必須在做任何三緩衝操作前調用&nbsp;timer_simulate_retrace().&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_HW_CURSOR:&nbsp;<BR>
表示硬件鼠標在使用中.&nbsp;當這個標誌設置了,&nbsp;可以不先隱藏鼠標指針而安全的向屏幕上作&nbsp;<BR>
圖.&nbsp;注意不是所有的指針圖形被硬件支持:&nbsp;尤其是&nbsp;VBE/AF&nbsp;只支持&nbsp;2&nbsp;色&nbsp;32x32&nbsp;大小的圖&nbsp;<BR>
片,&nbsp;其中第二個顏色正好是第一個的逆色.&nbsp;這就是說,&nbsp;Allegro&nbsp;可能需要在你的程序執行時&nbsp;<BR>
依據&nbsp;鼠標指針切換硬件和軟件鼠標,&nbsp;因此你不要&nbsp;假定這個標誌會持續保持很長的時間.&nbsp;它&nbsp;<BR>
僅僅告訴你當前時間硬件鼠標是否正在使用,&nbsp;無論何時你隱藏/重顯鼠標指針它都可能改變.&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_HW_HLINE:&nbsp;<BR>
表示普通的&nbsp;hline()&nbsp;不透明版本正在&nbsp;使用硬件加速.&nbsp;這不僅僅提高&nbsp;hline()&nbsp;本身的執行&nbsp;<BR>
效率,&nbsp;還有許多其它使用&nbsp;它的函數,&nbsp;比如&nbsp;circlefill(),&nbsp;triangle(),&nbsp;和&nbsp;floodfill().&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_HLINE_XOR:&nbsp;<BR>
表示&nbsp;hline()的&nbsp;XOR&nbsp;版本,和其它調用它的函數,&nbsp;使用著硬件加速.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_HW_HLINE_SOLID_PATTERN:&nbsp;<BR>
表示&nbsp;hline()&nbsp;函數的實心(solid)&nbsp;和遮掩(mask)&nbsp;方式,及其&nbsp;其它使用它的函數,&nbsp;正在使用&nbsp;<BR>
硬件加速&nbsp;(見下面的注解).&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_HLINE_COPY_PATTERN:&nbsp;<BR>
表示&nbsp;hline()&nbsp;函數的復制方式,&nbsp;及其它&nbsp;使用它的函數,&nbsp;正在使用硬件加速&nbsp;(見下面的注&nbsp;<BR>
解).&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_FILL:&nbsp;<BR>
表示&nbsp;rectfill()&nbsp;函數,&nbsp;clear()&nbsp;例程,&nbsp;clear_to_color()&nbsp;的不透明版本,&nbsp;正在使用硬件&nbsp;<BR>
加速&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_FILL_XOR:&nbsp;<BR>
表示&nbsp;rectfill()&nbsp;函數的&nbsp;XOR&nbsp;版本,&nbsp;正在使用硬件加速&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_FILL_SOLID_PATTERN:&nbsp;<BR>
表示&nbsp;rectfill()&nbsp;函數的實心(solid)&nbsp;和遮掩(mask)&nbsp;花紋方式,&nbsp;正在使用硬件加速&nbsp;(見下&nbsp;<BR>
面的注解).&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_FILL_COPY_PATTERN:&nbsp;<BR>
表示&nbsp;rectfill()&nbsp;函數的復制方式,&nbsp;正在使用硬件加速&nbsp;(見下面的注解).&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_LINE:&nbsp;<BR>
表示&nbsp;line()&nbsp;和&nbsp;vline()&nbsp;函數的不透明版本,&nbsp;正在使用硬件加速&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_LINE_XOR:&nbsp;<BR>
表示&nbsp;line()&nbsp;和&nbsp;vline()&nbsp;函數的&nbsp;XOR&nbsp;版本,&nbsp;正在使用硬件加速&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_TRIANGLE:&nbsp;<BR>
表示&nbsp;triangle()&nbsp;函數的不透明版本,&nbsp;正在使用硬件加速&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_TEXTOUT_FIXED:&nbsp;<BR>
表示單色字符擴大&nbsp;(&nbsp;8x8&nbsp;和&nbsp;8x16&nbsp;定寬字體格式)&nbsp;正在使用硬件加速.&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_TRIANGLE_XOR:&nbsp;<BR>
表示&nbsp;triangle()&nbsp;函數的&nbsp;XOR&nbsp;版本&nbsp;正在使用硬件加速.&nbsp;&nbsp;<BR>
&nbsp;<BR>
GFX_HW_VRAM_BLIT:&nbsp;<BR>
表示從屏幕的一部分到另一部分的&nbsp;blit&nbsp;操作&nbsp;正在使用硬件加速.&nbsp;如果這個標誌被設置,&nbsp;<BR>
顯存裡的&nbsp;blit&nbsp;操作將以最快的可能方式來&nbsp;顯示圖片,&nbsp;因此將最常用的圖形儲存在&nbsp;屏幕以&nbsp;<BR>
外的顯存裡是很值得的.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_HW_VRAM_BLIT_MASKED:&nbsp;<BR>
表示&nbsp;masked_blit()&nbsp;例程能夠在顯存裡復制時被硬件加速,&nbsp;並且&nbsp;draw_sprite()&nbsp;將在源圖&nbsp;<BR>
是屏幕或顯存的子位圖時使用&nbsp;硬件加速.&nbsp;如果這個標誌被設置,&nbsp;顯存裡的&nbsp;blit&nbsp;操作將以&nbsp;<BR>
最快的可能方式來&nbsp;顯示圖片,&nbsp;因此將最常用的精靈儲存在&nbsp;屏幕以外的顯存裡是很值得的.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
警告:&nbsp;如果這個標誌沒有被設置,&nbsp;masked_blit()&nbsp;和&nbsp;draw_sprite()&nbsp;在使用顯存源位圖時&nbsp;<BR>
將不能正常的工作!&nbsp;如果他們被硬件支持,&nbsp;你必須僅僅嘗試使用這些函數來在&nbsp;顯存裡復制.&nbsp;<BR>
&nbsp;<BR>
GFX_HW_MEM_BLIT:&nbsp;<BR>
表示內存位圖向屏幕的&nbsp;blit&nbsp;操作正在被硬件加速.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
GFX_HW_MEM_BLIT_MASKED:&nbsp;<BR>
表示&nbsp;masked_blit()&nbsp;和&nbsp;draw_sprite()&nbsp;函數在&nbsp;源圖是內存位圖而目標位圖是物理屏幕時&nbsp;<BR>
被&nbsp;硬件加速.&nbsp;&nbsp;<BR>
&nbsp;<BR>
註釋:&nbsp;即使是在表示可能的信息說繪圖塊&nbsp;被硬件加速的時候,&nbsp;也不是所有的大小都可以.&nbsp;<BR>
VBE/AF&nbsp;僅僅支持&nbsp;8x8&nbsp;以內的圖案,&nbsp;因此&nbsp;Allegro&nbsp;在你使用的圖案大於這個的時候就使用&nbsp;<BR>
最初的非加速版.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
註釋2:&nbsp;這些硬件加速特性僅僅在你&nbsp;直接向屏幕位圖,&nbsp;顯存位圖,&nbsp;或它們的子位圖作畫的時&nbsp;<BR>
候才發生效果.&nbsp;硬件加速在頁切換&nbsp;或&nbsp;3&nbsp;緩衝設置的時候最有用,&nbsp;而對於&nbsp;經典的&nbsp;&quot;畫在內&nbsp;<BR>
存位圖上,&nbsp;然後&nbsp;blit&nbsp;到&nbsp;屏幕上&quot;&nbsp;的系統毫無效果.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
int&nbsp;scroll_screen(int&nbsp;x,&nbsp;int&nbsp;y);&nbsp;<BR>
嘗試硬件滾動屏幕來顯示虛擬屏幕的不同部分&nbsp;(初始化時位置在&nbsp;0,0,&nbsp;就是左上角).&nbsp;成功&nbsp;<BR>
則返回零:&nbsp;如果圖形驅動程序&nbsp;不能做硬件滾屏或者虛擬屏幕不夠大則它可能出錯.&nbsp;你可以&nbsp;<BR>
使用這個來在一個大的虛擬空間中移動屏幕顯示區間,&nbsp;或者在虛擬屏幕的兩個不重疊的部分&nbsp;<BR>
間進行頁切換.&nbsp;注意在屏幕位圖上超出原始坐標作圖時,&nbsp;你必須改變剪裁矩形:&nbsp;見後.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
Mode-X&nbsp;滾屏是可信的,它可以在任何卡上工作.&nbsp;可惜&nbsp;大多&nbsp;VESA&nbsp;實現程序只能處理&nbsp;水平上&nbsp;<BR>
的&nbsp;4&nbsp;點遞增滾動,&nbsp;所以在&nbsp;SVGA&nbsp;模式下平滑的水平滾動&nbsp;是不可能的.&nbsp;這真是慚愧,&nbsp;但是我&nbsp;<BR>
沒有辦法解決它.&nbsp;大多數&nbsp;VESA&nbsp;實現程序似乎在真彩模式下的滾動都有非常多的&nbsp;bug,&nbsp;因此&nbsp;<BR>
我建議你不要&nbsp;指望這個例程來正確的進行真彩模式下的滾屏,除非你確認&nbsp;SciTech&nbsp;Display&nbsp;<BR>
Doctor&nbsp;已經加載了.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Allegro&nbsp;將在滾動屏幕時進行必要的垂直回掃同步,&nbsp;因此你不必在前面調用&nbsp;vsync().&nbsp;這意&nbsp;<BR>
味著&nbsp;scroll_screen()&nbsp;和&nbsp;vsync()&nbsp;造成的延時時間相同.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;request_scroll(int&nbsp;x,&nbsp;int&nbsp;y);&nbsp;<BR>
這個函數用於三緩衝.&nbsp;它請求硬件滾屏到&nbsp;指定位置,&nbsp;但是馬上返回而不是等待一次回掃.&nbsp;<BR>
這個滾動將在下次垂直回掃中被實現,&nbsp;但是你可以在這段時間執行其它的代碼並&nbsp;使用&nbsp;<BR>
poll_scroll()&nbsp;例程來檢測何時&nbsp;flip(頁切換)&nbsp;完成了&nbsp;(見&nbsp;examples/ex20.c).&nbsp;三緩衝只&nbsp;<BR>
能工作在適當的硬件上:&nbsp;如果時鐘模擬器激活,它可以工作在任何&nbsp;mode-X&nbsp;分辨率下&nbsp;(但是&nbsp;<BR>
不能正確的在&nbsp;win95&nbsp;下工作),&nbsp;增強版&nbsp;可以由&nbsp;VBE&nbsp;3.0&nbsp;和&nbsp;VBE/AF&nbsp;驅動程序支持有限的幾&nbsp;<BR>
種&nbsp;高檔圖形卡.&nbsp;你可以檢查&nbsp;gfx_capabilities&nbsp;標誌的&nbsp;GFX_CAN_TRIPLE_BUFFER&nbsp;位&nbsp;來看&nbsp;<BR>
看在當前的驅動程序下能否工作.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;poll_scroll();&nbsp;<BR>
這個函數在&nbsp;3&nbsp;緩衝時使用.&nbsp;它檢查前面由&nbsp;request_scroll()&nbsp;例程初始化的一個硬件捲屏&nbsp;<BR>
的狀態,&nbsp;如果還在等待發生,&nbsp;則返回非零,&nbsp;如果已經發生則返回零.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
int&nbsp;show_video_bitmap(BITMAP&nbsp;*bitmap);&nbsp;<BR>
嘗試頁切換硬件屏幕來顯示指定的顯存位圖對像,&nbsp;這個位圖必須和物理屏幕有相同的大小,&nbsp;<BR>
並且是由調用&nbsp;create_video_bitmap()&nbsp;函數得到的.&nbsp;成功則返回零.&nbsp;如果圖形卡需要,&nbsp;這&nbsp;<BR>
個函數將等待一次垂直回掃,&nbsp;因此你不必自己調用&nbsp;vsync().&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
int&nbsp;request_video_bitmap(BITMAP&nbsp;*bitmap);&nbsp;<BR>
這個函數為實現&nbsp;3&nbsp;緩衝來使用.&nbsp;它請求一次頁切換&nbsp;來顯示指定的顯存位圖對像,&nbsp;但是立即&nbsp;<BR>
返回而不是&nbsp;等待回掃.&nbsp;回掃將在下次&nbsp;垂直回掃期間發生,&nbsp;但是你可以在這段時間運行其他&nbsp;<BR>
的代碼,&nbsp;使用&nbsp;poll_scroll()&nbsp;例程來檢測何時切換真正&nbsp;發生.&nbsp;3&nbsp;緩衝僅僅只能在合適的硬&nbsp;<BR>
件上實現:&nbsp;見&nbsp;request_scroll()&nbsp;的注解.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;request_modex_scroll(int&nbsp;x,&nbsp;int&nbsp;y);&nbsp;<BR>
int&nbsp;poll_modex_scroll();&nbsp;<BR>
作廢的&nbsp;request_scroll()&nbsp;和&nbsp;poll_scroll()&nbsp;版本,&nbsp;為向以前兼容而保留.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
void&nbsp;split_modex_screen(int&nbsp;line);&nbsp;<BR>
這個函數只在&nbsp;mode-X&nbsp;下有效.&nbsp;它將在指定行將&nbsp;VGA&nbsp;的顯示&nbsp;分成兩個部分.&nbsp;屏幕上面的部&nbsp;<BR>
分可以利用&nbsp;scroll_screen()&nbsp;函數被滾動到&nbsp;顯存的任意部分,&nbsp;而指定行下面的部分將被保&nbsp;<BR>
留並且從&nbsp;屏幕位圖的坐標&nbsp;(0,0)&nbsp;開始顯示.&nbsp;在分割屏幕&nbsp;以後你一般想滾動所以上面的部&nbsp;<BR>
分是從接下來的顯存開始向顯存後面延伸,&nbsp;然後創建兩個子位圖&nbsp;來控制這兩個部分&nbsp;(見&nbsp;<BR>
examples/ex19.c&nbsp;看看&nbsp;這些是如何運作的演示).&nbsp;關掉分割用&nbsp;split_modex_screen(0).&nbsp;&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
<A HREF="http://www.cfido.net/cloud">http://www.cfido.net/cloud</A>&nbsp;<BR>
<A HREF="http://computer.igd.edu.cn/~cloud">http://computer.igd.edu.cn/~cloud</A>&nbsp;<BR>
<A HREF="http://linux.cqi.com.cn/~cloud">http://linux.cqi.com.cn/~cloud</A>&nbsp;<BR>
<A HREF="http://www.nease.net/~cloudwu">http://www.nease.net/~cloudwu</A>&nbsp;(暫時不能更新)&nbsp;<BR>
E-mail:&nbsp;<A HREF="mailto:cloudwu@263.net">cloudwu@263.net</A>&nbsp;<BR>
&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;202.197.71.16]&nbsp;<BR>
<A HREF="00000024.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000026.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>