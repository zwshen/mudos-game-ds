<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;nerd&nbsp;(快樂的感覺永遠一樣),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Lpc的繼承簡介&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Wed&nbsp;Apr&nbsp;&nbsp;8&nbsp;09:42:35&nbsp;1998)&nbsp;<BR>
&nbsp;<BR>
發信人:&nbsp;maht&nbsp;(Trill),&nbsp;信區:&nbsp;creator&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;Lpc的繼承簡介&nbsp;<BR>
發信站:&nbsp;天地創造&nbsp;(Fri&nbsp;Oct&nbsp;31&nbsp;10:30:16&nbsp;1997),&nbsp;轉信&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四章&nbsp;Lpc的繼承簡介&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一節&nbsp;前言&nbsp;<BR>
&nbsp;&nbsp;通過上一章的閱讀，你應該知道Lpc的函數的基本工作方式。你應該學&nbsp;<BR>
會如何聲明和調用函數。更進一步，你應該有能力自己寫函數定義，即&nbsp;<BR>
使你是首次接觸Lpc。你知道了函數調用是如何執行的，函數必須有一個&nbsp;<BR>
返回值，除非是&nbsp;void&nbsp;類型的。&nbsp;<BR>
&nbsp;&nbsp;下面我們來看一個例子。看看巫師的工作室，可能幾乎都有類似下面&nbsp;<BR>
的一段代碼。(這個不同的&nbsp;MudLib&nbsp;是不一樣的)&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create();&nbsp;<BR>
&nbsp;<BR>
inherit&nbsp;&quot;/std/room&quot;;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;<BR>
{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;room::create();&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set(&nbsp;&quot;short&quot;,&nbsp;&quot;巫師工作室&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set(&nbsp;&quot;long&quot;,&nbsp;&quot;這是一片未曾開墾的土地，需要巫師的畫筆去描繪。\n&quot;&nbsp;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set(&nbsp;&quot;exits&quot;,&nbsp;([&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;trill&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&quot;/u/trill/workroom&quot;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;]);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;create_door(&quot;south&quot;,&nbsp;&quot;時空之門&quot;,&nbsp;&quot;north&quot;,&nbsp;0);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setup();&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;如果你理解了前面的幾章，你應該能立刻指出幾點：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;&nbsp;create()&nbsp;是一個函數的定義部分。&quot;void&nbsp;create();&quot;&nbsp;是它的函數&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聲明，卻有在&nbsp;create()&nbsp;裡面有個&nbsp;room::create()&nbsp;沒有聲明。&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;&nbsp;它調用了set(),&nbsp;create_door(),&nbsp;setup()，在代碼中卻沒有聲明。&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;&nbsp;在第三行，既不是變量聲明也不是函數聲明，更不是函數定義。&nbsp;<BR>
&nbsp;&nbsp;這一章就是回答以下問題的：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;&nbsp;room::create()是什麼東西？&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;&nbsp;函數&nbsp;set()，create_door()，在哪裡聲明、哪裡定義？&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;&nbsp;第三行是什麼東西？&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二節&nbsp;面對對像編程(OOP)的繼承&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;繼承是面對對像編程的一個基本特性。它使你能寫一些基本的代碼能&nbsp;<BR>
以不同的方式被不同的程序使用。一個&nbsp;MudLib&nbsp;做的就是創建一些基本&nbsp;<BR>
的&nbsp;Object&nbsp;，在此基礎上你能用他們創建自己特殊的&nbsp;Object。&nbsp;<BR>
&nbsp;&nbsp;如果不得不寫那些定義巫師工作室所必須的所有代碼，你可能要寫超&nbsp;<BR>
過&nbsp;1000&nbsp;行的代碼，這樣你才可能有這個&nbsp;room&nbsp;所需要的所有函數。如果&nbsp;<BR>
每個&nbsp;room&nbsp;都必須這麼做的話，首先是浪費硬盤空間；其次，你寫的代&nbsp;<BR>
碼可能根本無法和別人的寫的代碼組合在一起，每個人對&nbsp;room&nbsp;擴展的&nbsp;<BR>
特性的各種函數搞出每個人自己的標準。比如，你可能把&nbsp;room&nbsp;的長描&nbsp;<BR>
述的接口函數叫做&nbsp;GetLong()，別的巫師可能喜歡把它命名為&nbsp;query_long()。&nbsp;<BR>
這個就是各個&nbsp;MudLib&nbsp;不兼容的根本問題，因為它們&nbsp;Object&nbsp;相互繼承、&nbsp;<BR>
調用上使用不同的協議。&nbsp;<BR>
&nbsp;&nbsp;OOP&nbsp;能克服上面的問題。在上面的例子中，你直接使用的函數都定義&nbsp;<BR>
在繼承的叫做&nbsp;&quot;/std/room.c&quot;&nbsp;的&nbsp;Object&nbsp;裡面了。它有所有那些&nbsp;room&nbsp;常&nbsp;<BR>
用的函數的定義。當你寫創建一個特別的&nbsp;room，你通過繼承得到&nbsp;room&nbsp;<BR>
的的基本的功能，通過加入你自己寫的函數，這樣就把它變成了一個獨&nbsp;<BR>
特的&nbsp;room&nbsp;了。&nbsp;<BR>
&nbsp;&nbsp;OOP&nbsp;通過繼承不只是提高了代碼的可重用性，而且它可以是你只關心&nbsp;<BR>
繼承基本的&nbsp;Object&nbsp;後，那些特性需要改變的，而不用考慮那些東西是&nbsp;<BR>
需要的，就是說當你看到別人寫好的&nbsp;Object&nbsp;時，發現已經很像你心中&nbsp;<BR>
所想的東西，就只有一點點不符合，那你所要做只是繼承原先的&nbsp;Object，&nbsp;<BR>
然後加入和想的那一點點不同的東西就可以了。&nbsp;<BR>
&nbsp;&nbsp;OOP&nbsp;當然不只是繼承，還有別的一些。但是對於我們現在是談論繼承&nbsp;<BR>
的最基本的概念。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三節&nbsp;繼承是如何工作的？&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;還記得最開始提的三個問題嗎？在這一節裡面，將解答這些問題。&nbsp;<BR>
&nbsp;&nbsp;首先最後一個問題：&nbsp;<BR>
&nbsp;&nbsp;例子中的第三行：&nbsp;<BR>
-----&nbsp;<BR>
inherit&nbsp;&quot;/std/room&quot;;&nbsp;<BR>
-----&nbsp;<BR>
是做什麼？&nbsp;<BR>
&nbsp;&nbsp;我想到了現在，你應該你猜出來這一行確保你寫的巫師工作室繼承了&nbsp;<BR>
標準的&nbsp;room:&nbsp;&quot;/std/room.c&quot;&nbsp;的特性。通過繼承獲得標準&nbsp;room&nbsp;的功能，&nbsp;<BR>
你就可以使用那些已經在&nbsp;&quot;/std/room.c&quot;&nbsp;底下聲明和定義好的所有函數。&nbsp;<BR>
這就是為什麼你可以直接使用&nbsp;set(),&nbsp;create_door()&nbsp;這些函數的原因了。&nbsp;<BR>
在你自己寫的函數&nbsp;create()，你只要設置那些你要的值就可以了。這些&nbsp;<BR>
值使得你的&nbsp;room&nbsp;與眾不同，但確保和別的&nbsp;Object&nbsp;能相互作用。&nbsp;<BR>
&nbsp;&nbsp;那&nbsp;room::create()&nbsp;是做什麼的？&nbsp;<BR>
&nbsp;&nbsp;你可能看到類似的東西比如：&nbsp;::create()、::init()等。可能現在完全&nbsp;<BR>
理解有些困難。你只要有個印像就可以了。&nbsp;<BR>
&nbsp;&nbsp;在你繼承的那些&nbsp;Object&nbsp;中，可能會有&nbsp;create()&nbsp;函數，但是在你寫的&nbsp;<BR>
的&nbsp;Object&nbsp;中也有&nbsp;create()&nbsp;了，那麼&nbsp;Driver&nbsp;將只調用你寫&nbsp;create()&nbsp;來&nbsp;<BR>
完成一些初始化工作，一般情況下這是你所希望的。可是，有時候，你&nbsp;<BR>
發現你繼承的&nbsp;Object，比如&nbsp;/std/room.c&nbsp;中的&nbsp;create()，也是有用的，&nbsp;<BR>
那怎辦？那麼你可以這麼做：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;在你寫的&nbsp;room&nbsp;的&nbsp;create()&nbsp;當中加入&nbsp;<BR>
&nbsp;<BR>
-----------------&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;room::create();&nbsp;<BR>
-----------------&nbsp;<BR>
&nbsp;<BR>
這一行，&quot;::&quot;這個操作符加在一個函數&nbsp;example()&nbsp;的前面，那麼它就調&nbsp;<BR>
用它繼承的&nbsp;Object&nbsp;中的那個函數，如果&nbsp;&quot;::&quot;的前面沒有任何限定，那&nbsp;<BR>
麼就調用所有繼承的當前的一級的&nbsp;Object&nbsp;中叫做&nbsp;example()&nbsp;的函數，&nbsp;<BR>
如果有限定，那麼就只調用給定的&nbsp;Object&nbsp;的叫做&nbsp;example()&nbsp;的函數，&nbsp;<BR>
在我們的例子就調用&nbsp;/std/room.c&nbsp;的&nbsp;create()&nbsp;函數。&nbsp;<BR>
&nbsp;&nbsp;&quot;::&quot;這個操作符，是用於調用繼承的&nbsp;Object&nbsp;一個特殊的函數。通常&nbsp;<BR>
把&nbsp;&quot;::&quot;&nbsp;操作符叫做&nbsp;域訪問操作符&nbsp;。&nbsp;<BR>
&nbsp;&nbsp;一個對比例子：&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
#1&nbsp;<BR>
&nbsp;<BR>
inherit&nbsp;&quot;/std/room&quot;;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;<BR>
{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;create();&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
#2&nbsp;<BR>
&nbsp;<BR>
inherit&nbsp;&quot;/std/room&quot;;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;create()&nbsp;<BR>
{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;room::create();&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;例子&nbsp;1&nbsp;的後果是災難性的。當它被裝入內存中，Driver&nbsp;調用&nbsp;create()，&nbsp;<BR>
接著&nbsp;create()&nbsp;調用&nbsp;create()，create()&nbsp;還接著調用&nbsp;create()，如此往&nbsp;<BR>
復永無窮盡。就是說，create()&nbsp;持續不斷的調用自己，除非&nbsp;Driver&nbsp;發&nbsp;<BR>
現這是一個太深的遞歸，將其強制退出。&nbsp;<BR>
&nbsp;&nbsp;例子&nbsp;2&nbsp;是對的，但是除了浪費內存之外沒有任何作用，因為它和&nbsp;room.c&nbsp;<BR>
的功能沒有區別。對於這個&nbsp;Object，Driver&nbsp;調用它的&nbsp;create()，在它的&nbsp;<BR>
create()&nbsp;通過&nbsp;room::create()&nbsp;返回去調用&nbsp;room.c&nbsp;中的&nbsp;create()。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;總的來說，每個&nbsp;MudLib&nbsp;都是不同的，每個自己有一套標準函數的集&nbsp;<BR>
合，它們對於一些基本的功能都能完成。有些功能特性多有些，有些少&nbsp;<BR>
一些，有些在一些特殊方面完成特殊的工作，比如&nbsp;Es2&nbsp;帶了對中文的處&nbsp;<BR>
理。但是如果這個&nbsp;MudLib&nbsp;如果比較完善的話，它一般要提供一些標準&nbsp;<BR>
的&nbsp;Object&nbsp;的特性和功能的說明。一般可能在&nbsp;&quot;/doc/build&quot;&nbsp;底下，可能&nbsp;<BR>
叫做&nbsp;&quot;room_prop&quot;、&quot;monster_prop&quot;&nbsp;等。看看這些，你會得到你繼承的&nbsp;<BR>
Object&nbsp;的有的函數，它們的輸入參數，返回的數據類型，以及能完成&nbsp;<BR>
什麼工作。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四節&nbsp;&nbsp;小結&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;實際上複雜對像的繼承是很複雜的，就這麼簡單解釋是遠遠不夠的。&nbsp;<BR>
這篇簡介只是在你創建一些簡單的&nbsp;Object&nbsp;能使用繼承。更全面的討論&nbsp;<BR>
我們將在&nbsp;Lpc進階&nbsp;裡面看到。&nbsp;<BR>
&nbsp;&nbsp;現在你應該知道：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;&nbsp;每個&nbsp;MudLib&nbsp;有自己的一套基本&nbsp;Object&nbsp;的庫，有著一些基本的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;功能，巫師們通過繼承能更容易創建自己的&nbsp;Object，不同的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;之間的交互作用也更容易一些。&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;&nbsp;每個&nbsp;MudLib&nbsp;有自己一套標準。通常有自己一些文檔說明標準的&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;是什麼，有什麼樣的功能。&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;&nbsp;你可以用這樣繼承別的&nbsp;Object&nbsp;的功能：&nbsp;<BR>
&nbsp;<BR>
-----&nbsp;<BR>
inherit&nbsp;&quot;filename&quot;;&nbsp;<BR>
-----&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;這裡的&nbsp;filename&nbsp;是被繼承的&nbsp;Object&nbsp;的文件名。inherit&nbsp;&quot;xxx&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要在你的寫的代碼的開頭部分。&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回頭望&nbsp;&nbsp;每個人都看這世事無常&nbsp;&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向前闖&nbsp;&nbsp;一顆心比誰都還要堅強&nbsp;&nbsp;&nbsp;<BR>
&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;166.111.5.42]&nbsp;<BR>
<A HREF="00000005.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000007.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>