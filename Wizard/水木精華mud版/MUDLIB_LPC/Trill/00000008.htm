<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<div align="left"> &nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第六章&nbsp;&nbsp;數據類型：object&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一節&nbsp;&nbsp;序言&nbsp;<BR>
  &nbsp;&nbsp;這是&nbsp;Lpc&nbsp;入門的最後一節，到現在，如果前面幾章都讀過了，你應該&nbsp;<BR>
  能寫出一些簡單的&nbsp;object，比如&nbsp;room&nbsp;。而且能給&nbsp;room&nbsp;寫一些簡單的&nbsp;<BR>
  特寫，通過添加一些函數。&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二節&nbsp;作為數據類型的&nbsp;object&nbsp;<BR>
  2.1&nbsp;數據類型&nbsp;object&nbsp;<BR>
  &nbsp;&nbsp;在這一章中，你將了解更複雜一些的數據類型：object。一個&nbsp;object&nbsp;<BR>
  類型的變量是指向一個裝入內存的真正存在的&nbsp;object&nbsp;。像別的數據類&nbsp;<BR>
  型一樣，你用&nbsp;object&nbsp;後面跟一個變量名來聲明：&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;oTest;&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;它有些特殊，它幾乎沒有什麼操作符可以作用&nbsp;object&nbsp;這種數據類型。&nbsp;<BR>
  其實，也是的，讓一個&nbsp;room&nbsp;/&nbsp;npc&nbsp;那是什麼東西？而且一般的&nbsp;efun，&nbsp;<BR>
  比如&nbsp;write(),&nbsp;say()&nbsp;也是不能操作&nbsp;object&nbsp;的，但是你會了解到，對於&nbsp;<BR>
  object&nbsp;這中數據類型，有一些很重要的&nbsp;efun。&nbsp;<BR>
  &nbsp;<BR>
  2.2&nbsp;efun:&nbsp;this_object()&nbsp;<BR>
  &nbsp;&nbsp;這個&nbsp;efun&nbsp;返回一個&nbsp;object，當前被執行的函數所在的那個&nbsp;object。&nbsp;<BR>
  也就是說，在一個文件中，this_object()&nbsp;提交的&nbsp;object&nbsp;是這樣的：&nbsp;<BR>
  如果這個文件寫的&nbsp;object&nbsp;如果自己被復制裝入內存單獨存在，那麼就&nbsp;<BR>
  是這個&nbsp;object，如果這個文件被繼承了，那麼就是繼承的文件進行上一&nbsp;<BR>
  個過程，看它是不是單獨存在，也就是沒有再繼承的文件了。可能有些&nbsp;<BR>
  難也理解，讓我們看這個例子，比如你寫了一個&nbsp;object&nbsp;叫&nbsp;name.c，它&nbsp;<BR>
  被&nbsp;player.c&nbsp;繼承了，那麼&nbsp;this_object()&nbsp;實際返回的是&nbsp;player.c&nbsp;那個&nbsp;<BR>
  object，而不是&nbsp;name.c&nbsp;。我們再來看一個使用&nbsp;this_object()&nbsp;的實例：&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;你想讓一個&nbsp;npc&nbsp;走到一朵花旁邊聞一下，但是條件是那個&nbsp;npc&nbsp;能自&nbsp;<BR>
  由運動，比如：沒有暈倒，沒有在戰鬥。&nbsp;<BR>
  &nbsp;&nbsp;你可以這麼做：&nbsp;<BR>
  &nbsp;<BR>
  void&nbsp;eventSmellFlower()&nbsp;<BR>
  {&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;this_object()-&gt;can_act()&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&nbsp;this_object()-&gt;query(&nbsp;&quot;name&quot;&nbsp;)&nbsp;+&nbsp;&quot;走到花的邊上聞了聞。\n&quot;&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this_object()-&gt;add(&nbsp;&quot;kee&quot;,&nbsp;5&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  }&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;can_act()&nbsp;在&nbsp;npc.c&nbsp;裡面是沒有定義的，而且可能它繼承的任何&nbsp;object&nbsp;<BR>
  中也沒有定義。那麼，如果寫成這樣：&nbsp;if&nbsp;(&nbsp;can_act()&nbsp;)，driver&nbsp;沒有&nbsp;<BR>
  在當前文件和繼承的所有文件裡面找到&nbsp;can_act()，那就會有個編譯錯&nbsp;<BR>
  誤的，但是&nbsp;this_object()-&gt;can_act()&nbsp;就不會出現這樣的錯誤，就算是&nbsp;<BR>
  can_act()&nbsp;根本不存在，那麼結果是返回&nbsp;0&nbsp;，就是&nbsp;if&nbsp;測試的表達式的&nbsp;<BR>
  結果是假的。這樣有人會問：那這個&nbsp;efun&nbsp;有必要存在嗎？driver&nbsp;在&nbsp;<BR>
  編譯是會自動搜索它繼承的所有&nbsp;object，不是自然有&nbsp;this_object&nbsp;了&nbsp;<BR>
  嗎？&nbsp;確實，但是有時，這個&nbsp;object&nbsp;(暫時叫做&nbsp;A&nbsp;)會被別的&nbsp;object&nbsp;(B)&nbsp;<BR>
  繼承的，別的&nbsp;object&nbsp;(B)可能會有這個函數，而且有時候&nbsp;B&nbsp;可能會重載&nbsp;<BR>
  A&nbsp;和&nbsp;A&nbsp;繼承的函數，而你不想讓那些重載的函數失去作用，那麼就採用&nbsp;<BR>
  &nbsp;this_object()-&gt;&nbsp;的形式。&nbsp;<BR>
  &nbsp;<BR>
  2.3&nbsp;調用別的&nbsp;Object&nbsp;裡面的函數&nbsp;<BR>
  &nbsp;&nbsp;這就是我們引入&nbsp;object&nbsp;這種數據類型的最大好處了。它能讓我們調&nbsp;<BR>
  用別的&nbsp;Object&nbsp;裡面的函數。在上面的例子中，我們可以知道當前的&nbsp;<BR>
  Object&nbsp;能不動。下面的例子，你可以增加一個&nbsp;player&nbsp;身上的錢。&nbsp;<BR>
  調用別的&nbsp;object&nbsp;裡面的函數，可以用下面兩種方法：&nbsp;<BR>
  &nbsp;<BR>
  object-&gt;function(parameters)&nbsp;<BR>
  call_other(object,&nbsp;&quot;function&quot;,&nbsp;parameters);&nbsp;<BR>
  &nbsp;<BR>
  example:&nbsp;<BR>
  this_player()-&gt;add_money(&nbsp;&quot;silver&quot;,&nbsp;5&nbsp;);&nbsp;<BR>
  call_other(&nbsp;this_player(),&nbsp;&quot;add_money&quot;,&nbsp;&quot;silver&quot;,&nbsp;5&nbsp;);&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;在某些時候(&nbsp;很不精確的說法&nbsp;)，mud&nbsp;是一個由玩家命令觸發的函數&nbsp;<BR>
  調用的鏈式反應。當一個&nbsp;player&nbsp;觸發了一個函數調用鏈，那麼這個&nbsp;player&nbsp;<BR>
  就是&nbsp;eufn&nbsp;this_player()&nbsp;返回的那個&nbsp;object。就是說，因為&nbsp;this_player()&nbsp;<BR>
  依賴那個觸發事件序列那個&nbsp;player，那麼你應該小心的使用&nbsp;this_player()&nbsp;<BR>
  這個&nbsp;efun，如果你把&nbsp;this_player()&nbsp;放在一些函數，這些函數別調用通&nbsp;<BR>
  常可能是&nbsp;driver&nbsp;來調用的，或者不一定是&nbsp;player&nbsp;來觸發的，那麼使用&nbsp;<BR>
  this_player()&nbsp;最好不要出現在那些函數里面。比如&nbsp;create(),&nbsp;setup()。&nbsp;<BR>
  &nbsp;<BR>
  2.4&nbsp;lfun:&nbsp;init()&nbsp;<BR>
  &nbsp;&nbsp;在任何時候，一個“活的”的&nbsp;object，接近一個&nbsp;object&nbsp;(進入一個新&nbsp;<BR>
  房間，或者另一個&nbsp;object&nbsp;進入同一個&nbsp;room&nbsp;)，init()&nbsp;將自動被調用。&nbsp;<BR>
  利用這個，你可以寫一些自動觸發的效果，比如，你進入一家客棧，小&nbsp;<BR>
  二和你打招呼，看看這樣一個例子：&nbsp;<BR>
  &nbsp;<BR>
  void&nbsp;init()&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;::init();&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;this_object()-&gt;can_act()&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this_object()-&gt;eventGreet(&nbsp;this_player()&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  }&nbsp;<BR>
  &nbsp;<BR>
  eventGreet()&nbsp;可以是下面那樣：&nbsp;<BR>
  &nbsp;<BR>
  void&nbsp;eventGreet(&nbsp;object&nbsp;ob&nbsp;)&nbsp;<BR>
  {&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!ob&nbsp;||&nbsp;environment(&nbsp;ob&nbsp;)&nbsp;!=&nbsp;environment(&nbsp;this_object()&nbsp;)&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;;&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&nbsp;&quot;小二說道：這位客官，您想要點什麼？\n&quot;&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  }&nbsp;<BR>
  &nbsp;<BR>
  efun&nbsp;environment()&nbsp;返回一個&nbsp;object&nbsp;所在的環境，比如一個&nbsp;player&nbsp;所&nbsp;<BR>
  在的&nbsp;room，一把劍所在的&nbsp;player&nbsp;等等。&nbsp;<BR>
  &nbsp;<BR>
  2.5&nbsp;在你的&nbsp;room&nbsp;裡面放入一個&nbsp;object&nbsp;<BR>
  &nbsp;&nbsp;看下面的一個例子，你可以在一個&nbsp;player&nbsp;所在的房間放入一條蛇：&nbsp;<BR>
  &nbsp;<BR>
  void&nbsp;test()&nbsp;<BR>
  {&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;env,&nbsp;snake;&nbsp;<BR>
  &nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;env&nbsp;=&nbsp;environment(&nbsp;this_player()&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;objectp(&nbsp;env&nbsp;)&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snake&nbsp;=&nbsp;clone_object(&nbsp;&quot;/clone/monster/snake&quot;&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;objectp(&nbsp;snake&nbsp;)&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snake-&gt;move(&nbsp;env&nbsp;);&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
  }&nbsp;<BR>
  &nbsp;<BR>
  例子中用到了一個&nbsp;efun&nbsp;objectp&nbsp;，這個&nbsp;efun&nbsp;判斷傳入的參數是不是一&nbsp;<BR>
  個真實的&nbsp;object，如果是就返回真，否則就是假。efun&nbsp;clone_object()&nbsp;<BR>
  則試著把一個文件調入內存，變成一個&nbsp;object。最後一個函數&nbsp;move，&nbsp;<BR>
  這個顯然不是一個&nbsp;efun，但是總的來說，一般會調用&nbsp;efun&nbsp;move_object&nbsp;<BR>
  把一個&nbsp;object&nbsp;放到另一個&nbsp;object&nbsp;的內部。&nbsp;<BR>
  &nbsp;<BR>
  小結&nbsp;(&nbsp;也是&nbsp;lpc&nbsp;入門的小結&nbsp;)&nbsp;<BR>
  &nbsp;&nbsp;在本章，我們了解作為數據類型的&nbsp;object。同時也了解一些&nbsp;efun：&nbsp;<BR>
  this_object(),&nbsp;this_player()&nbsp;environment()&nbsp;clone_object()&nbsp;objectp()&nbsp;<BR>
  的使用。還有&nbsp;init()&nbsp;這個特別的函數的使用。&nbsp;<BR>
  &nbsp;&nbsp;到了現在，你應該有足夠的知識編寫一些漂亮的東西了。當然，我強&nbsp;<BR>
  調過一點，你必須了解你為之開發的&nbsp;mud，了解它的&nbsp;mudlib，它的風格，&nbsp;<BR>
  多多閱讀&nbsp;mud&nbsp;帶的文檔和說明。當然只是了解&nbsp;lpc&nbsp;入門&nbsp;介紹的東西，&nbsp;<BR>
  對&nbsp;lpc&nbsp;的了解是很基礎的，如果你想更進一步，最好的方法是，多讀&nbsp;<BR>
  程序，多寫程序，積累經驗。Lpc&nbsp;只是&nbsp;C&nbsp;的很小的一個子集，有一點點&nbsp;<BR>
  的特殊的東西，是很容易掌握的。&nbsp;<BR>
  &nbsp;<BR>
  maht(&nbsp;trill&nbsp;)&nbsp;<BR>
  11/12/97&nbsp;3:53PM&nbsp;<BR>
  trill@XO&nbsp;(tm)&nbsp; &nbsp;<BR>
</div>
<CENTER>
</CENTER>
</BODY></HTML>