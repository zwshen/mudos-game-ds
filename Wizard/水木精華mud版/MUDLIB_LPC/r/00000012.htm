<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;jameson&nbsp;(阿其),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;LPC&nbsp;Manual&nbsp;-&nbsp;Essential&nbsp;LPC&nbsp;and&nbsp;MUDLIB&nbsp;(2)&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Fri&nbsp;May&nbsp;23&nbsp;18:14:56&nbsp;1997)&nbsp;<BR>
&nbsp;<BR>
LPC&nbsp;revisited&nbsp;<BR>
&nbsp;<BR>
Let's&nbsp;start&nbsp;by&nbsp;ripping&nbsp;off&nbsp;the&nbsp;rest&nbsp;of&nbsp;the&nbsp;LPC&nbsp;that&nbsp;was&nbsp;avoided&nbsp;in&nbsp;the&nbsp;first&nbsp;chapter.&nbsp;We&nbsp;need&nbsp;this&nbsp;in&nbsp;<BR>
order&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;actually&nbsp;create&nbsp;working&nbsp;objects&nbsp;in&nbsp;the&nbsp;game&nbsp;environment.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function&nbsp;calls:&nbsp;Making&nbsp;function&nbsp;calls&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inheritance:&nbsp;Inheriting&nbsp;object&nbsp;classes&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shadows:&nbsp;Masking&nbsp;functions&nbsp;in&nbsp;runtime&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;identification:&nbsp;Determining&nbsp;the&nbsp;type&nbsp;of&nbsp;a&nbsp;variable&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type&nbsp;qualifiers:&nbsp;Further&nbsp;specify&nbsp;the&nbsp;functionality&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function&nbsp;definition&nbsp;(part&nbsp;2):&nbsp;The&nbsp;function&nbsp;type&nbsp;part&nbsp;2&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(part&nbsp;2):&nbsp;switch/case&nbsp;part&nbsp;2&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;catch/throw:&nbsp;Error&nbsp;handling&nbsp;during&nbsp;runtime&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array&nbsp;&amp;&nbsp;Mapping&nbsp;references:&nbsp;Reference&nbsp;by&nbsp;value&nbsp;or&nbsp;pointer&nbsp;&nbsp;<BR>
&nbsp;<BR>
Function&nbsp;calls&nbsp;<BR>
&nbsp;<BR>
There&nbsp;are&nbsp;two&nbsp;kinds&nbsp;of&nbsp;function&nbsp;calls,&nbsp;internal&nbsp;and&nbsp;external.&nbsp;The&nbsp;only&nbsp;kind&nbsp;we&nbsp;have&nbsp;discussed&nbsp;so&nbsp;far&nbsp;is&nbsp;<BR>
the&nbsp;internal&nbsp;one&nbsp;even&nbsp;though&nbsp;the&nbsp;external&nbsp;call&nbsp;has&nbsp;been&nbsp;displayed&nbsp;a&nbsp;few&nbsp;times.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internal&nbsp;calls:&nbsp;Making&nbsp;object-internal&nbsp;function&nbsp;calls&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;External&nbsp;single&nbsp;calls:&nbsp;Making&nbsp;object-external&nbsp;single&nbsp;function&nbsp;calls&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;External&nbsp;multiple&nbsp;calls:&nbsp;Making&nbsp;object-external&nbsp;multiple&nbsp;function&nbsp;calls&nbsp;&nbsp;<BR>
&nbsp;<BR>
Making&nbsp;object-internal&nbsp;function&nbsp;calls&nbsp;<BR>
&nbsp;<BR>
[call_self]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Making&nbsp;an&nbsp;internal&nbsp;function&nbsp;call&nbsp;is&nbsp;as&nbsp;simple&nbsp;as&nbsp;writing&nbsp;the&nbsp;function&nbsp;name&nbsp;and&nbsp;putting&nbsp;any&nbsp;arguments&nbsp;<BR>
within&nbsp;parentheses&nbsp;afterwards.&nbsp;The&nbsp;argument&nbsp;list&nbsp;is&nbsp;simply&nbsp;a&nbsp;list&nbsp;of&nbsp;expressions,&nbsp;or&nbsp;nothing.&nbsp;(A&nbsp;<BR>
function&nbsp;call&nbsp;is&nbsp;naturally&nbsp;an&nbsp;expression&nbsp;as&nbsp;well).&nbsp;&nbsp;<BR>
&nbsp;<BR>
&lt;function&gt;(&lt;argument&nbsp;list&gt;);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;atan(1.0)&nbsp;*&nbsp;4;&nbsp;<BR>
&nbsp;<BR>
There&nbsp;is&nbsp;another&nbsp;way&nbsp;of&nbsp;doing&nbsp;this&nbsp;as&nbsp;well.&nbsp;If&nbsp;you&nbsp;have&nbsp;the&nbsp;function&nbsp;name&nbsp;stored&nbsp;in&nbsp;a&nbsp;string&nbsp;and&nbsp;wish&nbsp;to&nbsp;<BR>
call&nbsp;the&nbsp;function,&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;call_self():&nbsp;&nbsp;<BR>
&nbsp;<BR>
call_self(&lt;&quot;function&nbsp;name&quot;&gt;,&nbsp;&lt;argument&nbsp;list&gt;);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;call_self(&quot;atan&quot;,&nbsp;1.0)&nbsp;*&nbsp;4;&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;use&nbsp;call_self()&nbsp;and&nbsp;specify&nbsp;a&nbsp;function&nbsp;that&nbsp;doesn't&nbsp;exist,&nbsp;you&nbsp;will&nbsp;get&nbsp;an&nbsp;error&nbsp;message&nbsp;and&nbsp;<BR>
the&nbsp;execution&nbsp;of&nbsp;the&nbsp;object&nbsp;will&nbsp;be&nbsp;aborted.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Making&nbsp;single&nbsp;object-external&nbsp;function&nbsp;calls&nbsp;<BR>
&nbsp;<BR>
[call_other]&nbsp;&nbsp;<BR>
&nbsp;<BR>
An&nbsp;external&nbsp;call&nbsp;is&nbsp;a&nbsp;call&nbsp;from&nbsp;one&nbsp;object&nbsp;to&nbsp;another.&nbsp;In&nbsp;order&nbsp;to&nbsp;do&nbsp;that&nbsp;you&nbsp;need&nbsp;an&nbsp;object&nbsp;reference&nbsp;to&nbsp;<BR>
the&nbsp;object&nbsp;you&nbsp;want&nbsp;to&nbsp;call.&nbsp;We&nbsp;haven't&nbsp;discussed&nbsp;exactly&nbsp;how&nbsp;you&nbsp;acquire&nbsp;an&nbsp;object&nbsp;reference&nbsp;yet,&nbsp;but&nbsp;<BR>
assume&nbsp;for&nbsp;the&nbsp;moment&nbsp;that&nbsp;it&nbsp;already&nbsp;is&nbsp;done&nbsp;for&nbsp;you.&nbsp;&nbsp;<BR>
&nbsp;<BR>
mixed&nbsp;&lt;object&nbsp;reference/object&nbsp;path&gt;-&gt;&lt;function&gt;(&lt;argument&nbsp;list&gt;);&nbsp;<BR>
mixed&nbsp;call_other(&lt;ob&nbsp;ref/ob&nbsp;path&gt;,&nbsp;&quot;&lt;function&gt;&quot;,&nbsp;&lt;arg&nbsp;list&gt;);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Assume&nbsp;that&nbsp;I&nbsp;want&nbsp;to&nbsp;call&nbsp;the&nbsp;function&nbsp;'compute_pie'&nbsp;in&nbsp;the&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;object&nbsp;&quot;/d/Mydom/thewiz/math_ob&quot;,&nbsp;and&nbsp;that&nbsp;I&nbsp;also&nbsp;have&nbsp;the&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;proper&nbsp;object&nbsp;pointer&nbsp;to&nbsp;it&nbsp;stored&nbsp;in&nbsp;the&nbsp;variable&nbsp;'math_ob'&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;math_ob-&gt;compute_pie(1.0);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;&quot;/d/Mydom/thewiz/math_ob&quot;-&gt;compute_pie(1.0);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;call_other(math_ob,&nbsp;&quot;compute_pie&quot;,&nbsp;1.0);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pie&nbsp;=&nbsp;call_other(&quot;/d/Mydom/thewiz/math_ob&quot;,&nbsp;&quot;compute_pie&quot;,&nbsp;1.0);&nbsp;<BR>
&nbsp;<BR>
As&nbsp;you&nbsp;can&nbsp;see,&nbsp;the&nbsp;efun&nbsp;call_other()&nbsp;works&nbsp;analogous&nbsp;to&nbsp;call_self().&nbsp;&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;make&nbsp;an&nbsp;external&nbsp;call&nbsp;using&nbsp;the&nbsp;object&nbsp;path,&nbsp;the&nbsp;so&nbsp;called&nbsp;master&nbsp;object&nbsp;will&nbsp;be&nbsp;called.&nbsp;If&nbsp;the&nbsp;<BR>
object&nbsp;you&nbsp;call&nbsp;hasn't&nbsp;been&nbsp;loaded&nbsp;into&nbsp;memory&nbsp;yet,&nbsp;it&nbsp;will&nbsp;be.&nbsp;If&nbsp;an&nbsp;external&nbsp;call&nbsp;is&nbsp;made&nbsp;to&nbsp;a&nbsp;function&nbsp;<BR>
that&nbsp;doesn't&nbsp;exist&nbsp;in&nbsp;the&nbsp;object&nbsp;you&nbsp;call,&nbsp;0&nbsp;will&nbsp;be&nbsp;returned&nbsp;without&nbsp;any&nbsp;error&nbsp;messages.&nbsp;Calls&nbsp;to&nbsp;<BR>
objects&nbsp;that&nbsp;have&nbsp;bugs&nbsp;in&nbsp;the&nbsp;code&nbsp;will&nbsp;result&nbsp;in&nbsp;an&nbsp;error&nbsp;message&nbsp;and&nbsp;the&nbsp;execution&nbsp;of&nbsp;the&nbsp;object&nbsp;that&nbsp;<BR>
made&nbsp;the&nbsp;call&nbsp;is&nbsp;aborted.&nbsp;&nbsp;<BR>
&nbsp;<BR>
What's&nbsp;the&nbsp;big&nbsp;deal&nbsp;with&nbsp;call_self()&nbsp;then?&nbsp;Why&nbsp;can't&nbsp;you&nbsp;just&nbsp;use&nbsp;call_other()&nbsp;all&nbsp;the&nbsp;time&nbsp;<BR>
with&nbsp;the&nbsp;same&nbsp;result?&nbsp;Well,&nbsp;it&nbsp;has&nbsp;to&nbsp;do&nbsp;with&nbsp;access&nbsp;to&nbsp;functions&nbsp;in&nbsp;an&nbsp;object,&nbsp;a&nbsp;part&nbsp;of&nbsp;LPC&nbsp;that&nbsp;I&nbsp;<BR>
haven't&nbsp;gotten&nbsp;around&nbsp;to&nbsp;explaining&nbsp;yet.&nbsp;However,&nbsp;the&nbsp;difference&nbsp;is&nbsp;that&nbsp;call_self&nbsp;really&nbsp;works&nbsp;just&nbsp;<BR>
like&nbsp;any&nbsp;internal&nbsp;call&nbsp;in&nbsp;regard&nbsp;to&nbsp;function&nbsp;modifiers&nbsp;and&nbsp;function&nbsp;access,&nbsp;while&nbsp;call_other()&nbsp;is&nbsp;a&nbsp;<BR>
pure&nbsp;external&nbsp;call.&nbsp;Remember&nbsp;this&nbsp;for&nbsp;the&nbsp;future&nbsp;when&nbsp;differences&nbsp;between&nbsp;internal&nbsp;and&nbsp;external&nbsp;<BR>
access&nbsp;to&nbsp;functions&nbsp;are&nbsp;discussed.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Making&nbsp;multiple&nbsp;object-external&nbsp;function&nbsp;calls&nbsp;<BR>
&nbsp;<BR>
You&nbsp;can&nbsp;call&nbsp;several&nbsp;objects&nbsp;at&nbsp;once&nbsp;just&nbsp;as&nbsp;easily&nbsp;as&nbsp;a&nbsp;single&nbsp;one.&nbsp;If&nbsp;you&nbsp;have&nbsp;an&nbsp;array&nbsp;of&nbsp;path&nbsp;strings&nbsp;<BR>
or&nbsp;object&nbsp;pointers,&nbsp;or&nbsp;a&nbsp;mapping&nbsp;where&nbsp;the&nbsp;value&nbsp;part&nbsp;are&nbsp;path&nbsp;strings&nbsp;or&nbsp;object&nbsp;pointers&nbsp;you&nbsp;can&nbsp;call&nbsp;<BR>
all&nbsp;the&nbsp;referenced&nbsp;objects&nbsp;in&nbsp;one&nbsp;statement.&nbsp;The&nbsp;result&nbsp;will&nbsp;be&nbsp;an&nbsp;array&nbsp;with&nbsp;the&nbsp;return&nbsp;values&nbsp;if&nbsp;you&nbsp;<BR>
call&nbsp;using&nbsp;an&nbsp;array&nbsp;and&nbsp;a&nbsp;mapping&nbsp;with&nbsp;the&nbsp;same&nbsp;index&nbsp;values&nbsp;as&nbsp;the&nbsp;calling&nbsp;mapping&nbsp;if&nbsp;you&nbsp;give&nbsp;a&nbsp;<BR>
mapping.&nbsp;&nbsp;<BR>
&nbsp;<BR>
(array/mapping)&nbsp;&lt;array/mapping&gt;-&gt;&lt;function&gt;(&lt;argument&nbsp;list&gt;);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;I&nbsp;want&nbsp;a&nbsp;mapping&nbsp;where&nbsp;the&nbsp;indices&nbsp;are&nbsp;the&nbsp;names&nbsp;of&nbsp;the&nbsp;players&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;the&nbsp;game,&nbsp;and&nbsp;the&nbsp;values&nbsp;are&nbsp;their&nbsp;hitpoints.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;*people,&nbsp;*names;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;hp_map;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;a&nbsp;list&nbsp;of&nbsp;all&nbsp;players.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;people&nbsp;=&nbsp;users();&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;their&nbsp;names.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;names&nbsp;=&nbsp;people-&gt;query_real_name();&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Make&nbsp;a&nbsp;mapping&nbsp;to&nbsp;call&nbsp;with.&nbsp;Item&nbsp;=&nbsp;name:pointer&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hp_map&nbsp;=&nbsp;mkmapping(names,&nbsp;people)&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;the&nbsp;pointers&nbsp;with&nbsp;hitpoint&nbsp;values.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hp_map&nbsp;=&nbsp;hp_map-&gt;query_hp();&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;All&nbsp;this&nbsp;could&nbsp;also&nbsp;have&nbsp;been&nbsp;done&nbsp;simpler&nbsp;as:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;hp_map&nbsp;=&nbsp;mkmapping(users()-&gt;query_real_name(),&nbsp;users()-&gt;query_hp());&nbsp;<BR>
&nbsp;<BR>
Inheriting&nbsp;object&nbsp;classes&nbsp;<BR>
&nbsp;<BR>
Assume&nbsp;that&nbsp;you&nbsp;want&nbsp;to&nbsp;code&nbsp;an&nbsp;item&nbsp;like&nbsp;a&nbsp;door,&nbsp;for&nbsp;example.&nbsp;Doing&nbsp;that&nbsp;means&nbsp;that&nbsp;you&nbsp;have&nbsp;to&nbsp;<BR>
create&nbsp;functionality&nbsp;that&nbsp;allows&nbsp;the&nbsp;opening&nbsp;and&nbsp;closing&nbsp;of&nbsp;a&nbsp;passage&nbsp;between&nbsp;two&nbsp;rooms.&nbsp;Perhaps&nbsp;you&nbsp;<BR>
want&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;lock&nbsp;and&nbsp;unlock&nbsp;the&nbsp;door,&nbsp;and&nbsp;perhaps&nbsp;you&nbsp;want&nbsp;the&nbsp;door&nbsp;to&nbsp;be&nbsp;transparent.&nbsp;All&nbsp;of&nbsp;<BR>
this&nbsp;must&nbsp;be&nbsp;taken&nbsp;care&nbsp;of&nbsp;in&nbsp;your&nbsp;code.&nbsp;Furthermore,&nbsp;you&nbsp;have&nbsp;to&nbsp;copy&nbsp;the&nbsp;same&nbsp;code&nbsp;and&nbsp;make&nbsp;small&nbsp;<BR>
variations&nbsp;in&nbsp;description&nbsp;and&nbsp;use&nbsp;every&nbsp;time&nbsp;you&nbsp;want&nbsp;to&nbsp;make&nbsp;a&nbsp;new&nbsp;door.&nbsp;&nbsp;<BR>
&nbsp;<BR>
After&nbsp;a&nbsp;while&nbsp;you'll&nbsp;get&nbsp;rather&nbsp;tired&nbsp;of&nbsp;this,&nbsp;particularly&nbsp;as&nbsp;you'll&nbsp;find&nbsp;that&nbsp;other&nbsp;wizards&nbsp;has&nbsp;created&nbsp;<BR>
doors&nbsp;of&nbsp;their&nbsp;own&nbsp;that&nbsp;work&nbsp;almost&nbsp;-&nbsp;but&nbsp;not&nbsp;quite&nbsp;-&nbsp;the&nbsp;same&nbsp;way&nbsp;your&nbsp;does,&nbsp;rendering&nbsp;nifty&nbsp;objects&nbsp;<BR>
and&nbsp;features&nbsp;useless&nbsp;anywhere&nbsp;but&nbsp;in&nbsp;your&nbsp;domain.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;object&nbsp;oriented&nbsp;way&nbsp;of&nbsp;thinking&nbsp;is&nbsp;that&nbsp;instead&nbsp;of&nbsp;doing&nbsp;things&nbsp;over&nbsp;and&nbsp;over&nbsp;you&nbsp;create&nbsp;a&nbsp;basic&nbsp;<BR>
door&nbsp;object&nbsp;that&nbsp;can&nbsp;do&nbsp;all&nbsp;the&nbsp;things&nbsp;you&nbsp;want&nbsp;any&nbsp;door&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;do.&nbsp;Then&nbsp;you&nbsp;just&nbsp;inherit&nbsp;this&nbsp;<BR>
generic&nbsp;door&nbsp;into&nbsp;a&nbsp;specialized&nbsp;door&nbsp;object&nbsp;where&nbsp;you&nbsp;configure&nbsp;exactly&nbsp;what&nbsp;it&nbsp;should&nbsp;be&nbsp;able&nbsp;to&nbsp;do&nbsp;<BR>
from&nbsp;the&nbsp;list&nbsp;of&nbsp;available&nbsp;options&nbsp;in&nbsp;the&nbsp;parent&nbsp;door.&nbsp;&nbsp;<BR>
&nbsp;<BR>
It&nbsp;is&nbsp;even&nbsp;possible&nbsp;to&nbsp;inherit&nbsp;several&nbsp;different&nbsp;objects&nbsp;where&nbsp;you&nbsp;can&nbsp;combine&nbsp;the&nbsp;functionality&nbsp;of&nbsp;<BR>
several&nbsp;objects&nbsp;into&nbsp;one.&nbsp;However,&nbsp;be&nbsp;aware&nbsp;that&nbsp;if&nbsp;the&nbsp;objects&nbsp;you&nbsp;inherit&nbsp;define&nbsp;functions&nbsp;with&nbsp;the&nbsp;<BR>
same&nbsp;names,&nbsp;they&nbsp;will&nbsp;indeed&nbsp;clash.&nbsp;Just&nbsp;be&nbsp;aware&nbsp;of&nbsp;what&nbsp;you&nbsp;are&nbsp;doing&nbsp;and&nbsp;why,&nbsp;and&nbsp;you&nbsp;won't&nbsp;<BR>
have&nbsp;any&nbsp;problems.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;syntax&nbsp;for&nbsp;inheriting&nbsp;objects&nbsp;is&nbsp;very&nbsp;simple.&nbsp;In&nbsp;the&nbsp;top&nbsp;of&nbsp;the&nbsp;file&nbsp;you&nbsp;write&nbsp;this:&nbsp;&nbsp;<BR>
&nbsp;<BR>
inherit&nbsp;&quot;&lt;file&nbsp;path&gt;&quot;;&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit&nbsp;&quot;/std/door&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit&nbsp;&quot;/std/room.c&quot;;&nbsp;<BR>
&nbsp;<BR>
NB!&nbsp;This&nbsp;is&nbsp;NOT&nbsp;a&nbsp;preprocessor&nbsp;command,&nbsp;it&nbsp;is&nbsp;a&nbsp;statement,&nbsp;so&nbsp;it&nbsp;does&nbsp;NOT&nbsp;have&nbsp;a&nbsp;#&nbsp;in&nbsp;front&nbsp;of&nbsp;it,&nbsp;<BR>
and&nbsp;it&nbsp;is&nbsp;ended&nbsp;with&nbsp;a&nbsp;;.&nbsp;As&nbsp;you&nbsp;see&nbsp;you&nbsp;may&nbsp;specify&nbsp;that&nbsp;it's&nbsp;a&nbsp;c-file&nbsp;if&nbsp;you&nbsp;wish,&nbsp;but&nbsp;that's&nbsp;not&nbsp;<BR>
necessary.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;child&nbsp;will&nbsp;inherit&nbsp;all&nbsp;functions&nbsp;and&nbsp;all&nbsp;variables&nbsp;that&nbsp;are&nbsp;declared&nbsp;in&nbsp;such&nbsp;a&nbsp;way&nbsp;as&nbsp;to&nbsp;permit&nbsp;<BR>
inheriting.&nbsp;If&nbsp;you&nbsp;have&nbsp;a&nbsp;function&nbsp;with&nbsp;the&nbsp;same&nbsp;name&nbsp;as&nbsp;a&nbsp;function&nbsp;in&nbsp;the&nbsp;parent,&nbsp;your&nbsp;function&nbsp;will&nbsp;<BR>
mask&nbsp;the&nbsp;parent&nbsp;one.&nbsp;When&nbsp;the&nbsp;function&nbsp;is&nbsp;called&nbsp;by&nbsp;an&nbsp;external&nbsp;call,&nbsp;your&nbsp;function&nbsp;will&nbsp;be&nbsp;executed.&nbsp;<BR>
Internal&nbsp;calls&nbsp;in&nbsp;the&nbsp;parent&nbsp;will&nbsp;still&nbsp;go&nbsp;to&nbsp;the&nbsp;parent&nbsp;function.&nbsp;Often&nbsp;you&nbsp;need&nbsp;to&nbsp;call&nbsp;the&nbsp;parent&nbsp;function&nbsp;<BR>
anyway&nbsp;from&nbsp;the&nbsp;child,&nbsp;you&nbsp;do&nbsp;that&nbsp;by&nbsp;adding&nbsp;::&nbsp;to&nbsp;the&nbsp;internal&nbsp;function&nbsp;call.&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;<BR>
my_func()&nbsp;<BR>
{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;This&nbsp;function&nbsp;exists&nbsp;in&nbsp;the&nbsp;parent,&nbsp;and&nbsp;I&nbsp;need&nbsp;to&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;call&nbsp;it&nbsp;from&nbsp;here.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;::my_func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Call&nbsp;my_func()&nbsp;in&nbsp;the&nbsp;parent.&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
It&nbsp;is&nbsp;not&nbsp;possible&nbsp;to&nbsp;call&nbsp;a&nbsp;masked&nbsp;function&nbsp;in&nbsp;the&nbsp;parent&nbsp;by&nbsp;an&nbsp;external&nbsp;call,&nbsp;it&nbsp;is&nbsp;only&nbsp;available&nbsp;from&nbsp;<BR>
within&nbsp;the&nbsp;object&nbsp;itself.&nbsp;If&nbsp;an&nbsp;object&nbsp;inherits&nbsp;an&nbsp;object&nbsp;that&nbsp;has&nbsp;inherited&nbsp;another&nbsp;object,&nbsp;e.g.&nbsp;C&nbsp;inherits&nbsp;<BR>
B&nbsp;that&nbsp;inherits&nbsp;A,&nbsp;then&nbsp;masked&nbsp;functions&nbsp;in&nbsp;A&nbsp;is&nbsp;only&nbsp;available&nbsp;from&nbsp;B,&nbsp;not&nbsp;from&nbsp;C.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Shadows:&nbsp;Masking&nbsp;functions&nbsp;during&nbsp;runtime&nbsp;<BR>
&nbsp;<BR>
There's&nbsp;a&nbsp;functionality&nbsp;called&nbsp;shadowing&nbsp;available&nbsp;in&nbsp;LPC.&nbsp;Purists&nbsp;tend&nbsp;to&nbsp;use&nbsp;the&nbsp;word&nbsp;'abomination'&nbsp;<BR>
and&nbsp;scream&nbsp;for&nbsp;its&nbsp;obliteration,&nbsp;since&nbsp;it&nbsp;goes&nbsp;against&nbsp;most&nbsp;of&nbsp;what's&nbsp;taught&nbsp;about&nbsp;proper&nbsp;control&nbsp;flow&nbsp;<BR>
and&nbsp;object&nbsp;purity.&nbsp;For&nbsp;gaming&nbsp;purposes&nbsp;it's&nbsp;rather&nbsp;useful,&nbsp;although&nbsp;it&nbsp;can&nbsp;cause&nbsp;a&nbsp;host&nbsp;of&nbsp;problems&nbsp;<BR>
(particularly&nbsp;when&nbsp;it&nbsp;comes&nbsp;to&nbsp;security).&nbsp;Use&nbsp;it&nbsp;with&nbsp;caution!&nbsp;&nbsp;<BR>
&nbsp;<BR>
It's&nbsp;possible&nbsp;to&nbsp;make&nbsp;an&nbsp;object&nbsp;shadow&nbsp;another&nbsp;object.&nbsp;What&nbsp;happens&nbsp;then&nbsp;is&nbsp;that&nbsp;the&nbsp;functions&nbsp;and&nbsp;<BR>
global&nbsp;variables&nbsp;in&nbsp;the&nbsp;shadow&nbsp;object&nbsp;that&nbsp;also&nbsp;exist&nbsp;in&nbsp;the&nbsp;shadowed&nbsp;object&nbsp;mask&nbsp;the&nbsp;original.&nbsp;Calls&nbsp;<BR>
to&nbsp;the&nbsp;shadowed&nbsp;functions&nbsp;will&nbsp;go&nbsp;to&nbsp;the&nbsp;shadow&nbsp;instead.&nbsp;The&nbsp;shadow&nbsp;will&nbsp;for&nbsp;all&nbsp;practical&nbsp;<BR>
appearances&nbsp;'become'&nbsp;the&nbsp;object&nbsp;it&nbsp;shadows.&nbsp;As&nbsp;you&nbsp;can&nbsp;see&nbsp;this&nbsp;is&nbsp;done&nbsp;in&nbsp;runtime,&nbsp;and&nbsp;not&nbsp;during&nbsp;<BR>
compilation.&nbsp;&nbsp;<BR>
&nbsp;<BR>
This&nbsp;is&nbsp;all&nbsp;I&nbsp;will&nbsp;say&nbsp;in&nbsp;this&nbsp;respect&nbsp;right&nbsp;now.&nbsp;How&nbsp;to&nbsp;create&nbsp;shadows&nbsp;and&nbsp;use&nbsp;them&nbsp;will&nbsp;be&nbsp;handled&nbsp;in&nbsp;<BR>
detail&nbsp;later.&nbsp;For&nbsp;now&nbsp;this&nbsp;is&nbsp;what&nbsp;you&nbsp;need&nbsp;to&nbsp;know.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Type&nbsp;identification&nbsp;<BR>
&nbsp;<BR>
[intp,&nbsp;floatp,&nbsp;functionp,&nbsp;stringp,&nbsp;objectp,&nbsp;mappingp,&nbsp;pointerp]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Due&nbsp;to&nbsp;the&nbsp;fact&nbsp;that&nbsp;all&nbsp;variables&nbsp;are&nbsp;initialized&nbsp;to&nbsp;0,&nbsp;and&nbsp;that&nbsp;many&nbsp;functions&nbsp;return&nbsp;0&nbsp;when&nbsp;failing,&nbsp;it's&nbsp;<BR>
desirable&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;determine&nbsp;what&nbsp;kind&nbsp;of&nbsp;value&nbsp;type&nbsp;you&nbsp;actually&nbsp;have&nbsp;received.&nbsp;Also,&nbsp;if&nbsp;you&nbsp;use&nbsp;<BR>
the&nbsp;mixed&nbsp;type&nbsp;it's&nbsp;virtually&nbsp;essential&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;test&nbsp;what&nbsp;the&nbsp;variable&nbsp;contains&nbsp;at&nbsp;times.&nbsp;For&nbsp;this&nbsp;<BR>
purpose&nbsp;there's&nbsp;a&nbsp;special&nbsp;test&nbsp;function&nbsp;for&nbsp;each&nbsp;type&nbsp;that&nbsp;will&nbsp;return&nbsp;1&nbsp;(true)&nbsp;if&nbsp;the&nbsp;tested&nbsp;value&nbsp;is&nbsp;of&nbsp;<BR>
the&nbsp;asked&nbsp;for&nbsp;type,&nbsp;and&nbsp;0&nbsp;if&nbsp;not.&nbsp;&nbsp;<BR>
&nbsp;<BR>
@bullet{int&nbsp;intp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;an&nbsp;integer&nbsp;&nbsp;<BR>
@bullet{int&nbsp;floatp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;a&nbsp;float&nbsp;&nbsp;<BR>
@bullet{functionp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;a&nbsp;function&nbsp;pointer&nbsp;&nbsp;<BR>
@bullet{int&nbsp;stringp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;a&nbsp;string&nbsp;&nbsp;<BR>
@bullet{int&nbsp;objectp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;an&nbsp;object&nbsp;pointer&nbsp;&nbsp;<BR>
@bullet{int&nbsp;mappingp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;a&nbsp;mapping&nbsp;&nbsp;<BR>
@bullet{int&nbsp;pointerp(mixed)}&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test&nbsp;if&nbsp;given&nbsp;value&nbsp;is&nbsp;an&nbsp;array&nbsp;&nbsp;<BR>
&nbsp;<BR>
NB!&nbsp;These&nbsp;functions&nbsp;test&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;value,&nbsp;NOT&nbsp;the&nbsp;value&nbsp;itself&nbsp;in&nbsp;the&nbsp;sense&nbsp;of&nbsp;truth&nbsp;<BR>
functionality.&nbsp;In&nbsp;other&nbsp;words&nbsp;intp(0)&nbsp;will&nbsp;always&nbsp;evaluate&nbsp;as&nbsp;true,&nbsp;as&nbsp;will&nbsp;mappingp(([])).&nbsp;&nbsp;<BR>
&nbsp;<BR>
Type&nbsp;qualifiers&nbsp;<BR>
&nbsp;<BR>
The&nbsp;very&nbsp;types&nbsp;you&nbsp;assign&nbsp;variables&nbsp;and&nbsp;function&nbsp;can&nbsp;have&nbsp;qualifiers&nbsp;changing&nbsp;the&nbsp;way&nbsp;they&nbsp;work.&nbsp;It's&nbsp;<BR>
very&nbsp;important&nbsp;to&nbsp;keep&nbsp;them&nbsp;in&nbsp;mind&nbsp;and&nbsp;use&nbsp;the&nbsp;proper&nbsp;qualifier&nbsp;at&nbsp;the&nbsp;proper&nbsp;time.&nbsp;Most&nbsp;work&nbsp;<BR>
differently&nbsp;when&nbsp;applied&nbsp;to&nbsp;variables&nbsp;rather&nbsp;than&nbsp;functions,&nbsp;so&nbsp;a&nbsp;bit&nbsp;of&nbsp;confusion&nbsp;about&nbsp;how&nbsp;they&nbsp;work&nbsp;<BR>
usually&nbsp;is&nbsp;quite&nbsp;common&nbsp;among&nbsp;the&nbsp;programmers.&nbsp;Try&nbsp;to&nbsp;get&nbsp;this&nbsp;straight&nbsp;now&nbsp;and&nbsp;you'll&nbsp;have&nbsp;no&nbsp;<BR>
problems&nbsp;later&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;(variable):&nbsp;The&nbsp;static&nbsp;variable&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;(function):&nbsp;The&nbsp;static&nbsp;function&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private:&nbsp;The&nbsp;private&nbsp;function/variable&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nomask:&nbsp;The&nbsp;nomask&nbsp;function/variable&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:&nbsp;The&nbsp;public&nbsp;function/variable&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;varargs:&nbsp;The&nbsp;varargs&nbsp;function&nbsp;qualifier&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;static&nbsp;variable&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
This&nbsp;is&nbsp;a&nbsp;problematic&nbsp;qualifier&nbsp;in&nbsp;the&nbsp;respect&nbsp;that&nbsp;it&nbsp;works&nbsp;differently&nbsp;even&nbsp;for&nbsp;variables&nbsp;depending&nbsp;on&nbsp;<BR>
where&nbsp;they&nbsp;are!&nbsp;Global&nbsp;variables,&nbsp;to&nbsp;begin&nbsp;with,&nbsp;are&nbsp;(as&nbsp;you&nbsp;know)&nbsp;variables&nbsp;that&nbsp;are&nbsp;defined&nbsp;in&nbsp;the&nbsp;<BR>
top&nbsp;of&nbsp;the&nbsp;file&nbsp;outside&nbsp;any&nbsp;function.&nbsp;These&nbsp;variables&nbsp;are&nbsp;available&nbsp;in&nbsp;all&nbsp;functions&nbsp;i.e.&nbsp;their&nbsp;scope&nbsp;is&nbsp;<BR>
object-wide,&nbsp;not&nbsp;just&nbsp;limited&nbsp;to&nbsp;one&nbsp;function.&nbsp;&nbsp;<BR>
&nbsp;<BR>
It&nbsp;is&nbsp;possible&nbsp;to&nbsp;save&nbsp;all&nbsp;global&nbsp;variables&nbsp;in&nbsp;an&nbsp;object&nbsp;with&nbsp;a&nbsp;special&nbsp;efun&nbsp;(described&nbsp;later).&nbsp;However,&nbsp;if&nbsp;<BR>
the&nbsp;global&nbsp;variable&nbsp;is&nbsp;declared&nbsp;as&nbsp;static,&nbsp;it&nbsp;is&nbsp;not&nbsp;saved&nbsp;along&nbsp;with&nbsp;the&nbsp;rest.&nbsp;&nbsp;<BR>
&nbsp;<BR>
static&nbsp;string&nbsp;&nbsp;&nbsp;TempName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;A&nbsp;non-saved&nbsp;global&nbsp;var.&nbsp;<BR>
&nbsp;<BR>
The&nbsp;static&nbsp;function&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
A&nbsp;function&nbsp;that&nbsp;is&nbsp;declared&nbsp;static&nbsp;can&nbsp;not&nbsp;be&nbsp;called&nbsp;using&nbsp;external&nbsp;calls,&nbsp;only&nbsp;internal.&nbsp;This&nbsp;makes&nbsp;<BR>
the&nbsp;function&nbsp;'invisible'&nbsp;and&nbsp;inaccessable&nbsp;for&nbsp;other&nbsp;objects.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;private&nbsp;function/variable&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
A&nbsp;variable&nbsp;or&nbsp;function&nbsp;that&nbsp;has&nbsp;been&nbsp;declared&nbsp;as&nbsp;private&nbsp;will&nbsp;not&nbsp;be&nbsp;inherited&nbsp;down&nbsp;to&nbsp;another&nbsp;<BR>
object.&nbsp;They&nbsp;can&nbsp;only&nbsp;be&nbsp;accessed&nbsp;within&nbsp;the&nbsp;object&nbsp;that&nbsp;defines&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;nomask&nbsp;function/variable&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
Functions&nbsp;and&nbsp;variables&nbsp;that&nbsp;are&nbsp;declared&nbsp;as&nbsp;nomask&nbsp;can&nbsp;not&nbsp;be&nbsp;masked&nbsp;in&nbsp;any&nbsp;way,&nbsp;neither&nbsp;by&nbsp;<BR>
shadowing&nbsp;nor&nbsp;inheriting.&nbsp;If&nbsp;you&nbsp;try&nbsp;you&nbsp;will&nbsp;be&nbsp;given&nbsp;an&nbsp;error&nbsp;message.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;public&nbsp;function/variable&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
This&nbsp;is&nbsp;the&nbsp;default&nbsp;qualifier&nbsp;for&nbsp;all&nbsp;functions.&nbsp;It&nbsp;means&nbsp;there&nbsp;is&nbsp;no&nbsp;limits&nbsp;other&nbsp;than&nbsp;those&nbsp;which&nbsp;the&nbsp;<BR>
language&nbsp;imposes&nbsp;on&nbsp;accessing,&nbsp;saving&nbsp;and&nbsp;masking.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;varargs&nbsp;function&nbsp;qualifier&nbsp;<BR>
&nbsp;<BR>
Sometimes&nbsp;you&nbsp;want&nbsp;a&nbsp;function&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;receive&nbsp;a&nbsp;variable&nbsp;amount&nbsp;of&nbsp;arguments.&nbsp;There's&nbsp;two&nbsp;<BR>
ways&nbsp;of&nbsp;doing&nbsp;this&nbsp;and&nbsp;it&nbsp;can&nbsp;be&nbsp;discussed&nbsp;if&nbsp;it's&nbsp;correct&nbsp;to&nbsp;put&nbsp;both&nbsp;explanations&nbsp;in&nbsp;this&nbsp;chapter,&nbsp;but&nbsp;<BR>
it's&nbsp;sort&nbsp;of&nbsp;logical&nbsp;to&nbsp;do&nbsp;so&nbsp;and&nbsp;not&nbsp;too&nbsp;hard&nbsp;to&nbsp;find.&nbsp;&nbsp;<BR>
&nbsp;<BR>
A&nbsp;function&nbsp;that&nbsp;is&nbsp;defined&nbsp;varargs&nbsp;will&nbsp;be&nbsp;able&nbsp;to&nbsp;receive&nbsp;a&nbsp;variable&nbsp;amount&nbsp;of&nbsp;arguments.&nbsp;The&nbsp;<BR>
variables&nbsp;that&nbsp;aren't&nbsp;specified&nbsp;at&nbsp;the&nbsp;call&nbsp;will&nbsp;be&nbsp;set&nbsp;to&nbsp;0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
varargs&nbsp;void&nbsp;<BR>
myfun(int&nbsp;a,&nbsp;string&nbsp;str,&nbsp;float&nbsp;c);&nbsp;<BR>
{&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
The&nbsp;call&nbsp;myfun(1);&nbsp;will&nbsp;set&nbsp;a&nbsp;to&nbsp;1,&nbsp;str&nbsp;and&nbsp;c&nbsp;to&nbsp;0.&nbsp;Make&nbsp;sure&nbsp;you&nbsp;test&nbsp;the&nbsp;potentially&nbsp;unused&nbsp;<BR>
variables&nbsp;before&nbsp;you&nbsp;try&nbsp;to&nbsp;use&nbsp;them&nbsp;so&nbsp;that&nbsp;they&nbsp;do&nbsp;contain&nbsp;a&nbsp;value&nbsp;you&nbsp;can&nbsp;use.&nbsp;&nbsp;<BR>
&nbsp;<BR>
There's&nbsp;another&nbsp;way&nbsp;as&nbsp;well.&nbsp;You&nbsp;can&nbsp;specify&nbsp;default&nbsp;values&nbsp;to&nbsp;the&nbsp;variables&nbsp;that&nbsp;you're&nbsp;uncertain&nbsp;<BR>
about.&nbsp;Then&nbsp;you&nbsp;don't&nbsp;have&nbsp;to&nbsp;declare&nbsp;the&nbsp;function&nbsp;varargs&nbsp;and&nbsp;you&nbsp;will&nbsp;have&nbsp;proper&nbsp;default&nbsp;values&nbsp;<BR>
in&nbsp;the&nbsp;unused&nbsp;argument&nbsp;variables&nbsp;as&nbsp;well.&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;<BR>
myfun(int&nbsp;a,&nbsp;string&nbsp;str&nbsp;=&nbsp;&quot;pelle&quot;,&nbsp;float&nbsp;c&nbsp;=&nbsp;3.0);&nbsp;<BR>
{&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
This&nbsp;function&nbsp;must&nbsp;be&nbsp;called&nbsp;with&nbsp;at&nbsp;least&nbsp;one&nbsp;argument,&nbsp;the&nbsp;first,&nbsp;as&nbsp;it&nbsp;wasn't&nbsp;given&nbsp;a&nbsp;default&nbsp;value.&nbsp;<BR>
The&nbsp;call&nbsp;myfun(1,&nbsp;&quot;apa&quot;);&nbsp;will&nbsp;set&nbsp;a&nbsp;to&nbsp;1,&nbsp;str&nbsp;to&nbsp;&quot;apa&quot;&nbsp;and&nbsp;c&nbsp;to&nbsp;3.0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;function&nbsp;data&nbsp;type,&nbsp;part&nbsp;2&nbsp;<BR>
&nbsp;<BR>
There's&nbsp;one&nbsp;data&nbsp;type&nbsp;that&nbsp;I&nbsp;more&nbsp;or&nbsp;less&nbsp;ignored&nbsp;earlier,&nbsp;and&nbsp;that's&nbsp;the&nbsp;function&nbsp;type.&nbsp;Just&nbsp;as&nbsp;<BR>
there's&nbsp;a&nbsp;type&nbsp;for&nbsp;objects,&nbsp;functions&nbsp;have&nbsp;a&nbsp;type&nbsp;as&nbsp;well.&nbsp;You&nbsp;can&nbsp;have&nbsp;function&nbsp;variables&nbsp;and&nbsp;call&nbsp;<BR>
assigned&nbsp;functions&nbsp;through&nbsp;those&nbsp;variables.&nbsp;Mostly&nbsp;the&nbsp;function&nbsp;type&nbsp;is&nbsp;used&nbsp;in&nbsp;conjunction&nbsp;with&nbsp;other&nbsp;<BR>
functions&nbsp;that&nbsp;use&nbsp;them&nbsp;as&nbsp;parameters.&nbsp;&nbsp;<BR>
&nbsp;<BR>
You&nbsp;declare&nbsp;a&nbsp;function&nbsp;type&nbsp;just&nbsp;as&nbsp;any&nbsp;variable:&nbsp;&nbsp;<BR>
&nbsp;<BR>
&lt;data&nbsp;type&gt;&nbsp;&lt;variable&nbsp;name&gt;,&nbsp;&lt;another&nbsp;variable&gt;,&nbsp;...,&nbsp;&lt;last&nbsp;variable&gt;;&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;my_func,&nbsp;*func_array;&nbsp;<BR>
&nbsp;<BR>
Assigning&nbsp;actual&nbsp;function&nbsp;references&nbsp;to&nbsp;them,&nbsp;however,&nbsp;is&nbsp;a&nbsp;bit&nbsp;tricker.&nbsp;You&nbsp;can&nbsp;assign&nbsp;any&nbsp;kind&nbsp;of&nbsp;<BR>
function&nbsp;to&nbsp;a&nbsp;function&nbsp;variable;&nbsp;efun,&nbsp;sfun&nbsp;or&nbsp;lfun&nbsp;is&nbsp;just&nbsp;the&nbsp;same.&nbsp;You&nbsp;can&nbsp;even&nbsp;assign&nbsp;external&nbsp;<BR>
function&nbsp;references.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Assigning&nbsp;a&nbsp;function&nbsp;reference&nbsp;requires&nbsp;that&nbsp;the&nbsp;function&nbsp;already&nbsp;is&nbsp;defined,&nbsp;either&nbsp;itself&nbsp;or&nbsp;by&nbsp;a&nbsp;<BR>
function&nbsp;prototype&nbsp;in&nbsp;the&nbsp;header.&nbsp;Let's&nbsp;assume&nbsp;for&nbsp;now&nbsp;that&nbsp;you're&nbsp;only&nbsp;interested&nbsp;in&nbsp;the&nbsp;simple&nbsp;<BR>
reference&nbsp;to&nbsp;the&nbsp;function.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&lt;function&nbsp;variable&gt;&nbsp;=&nbsp;&lt;function&nbsp;name&gt;;&nbsp;<BR>
&lt;function&nbsp;variable&gt;&nbsp;=&nbsp;&amp;&lt;function&nbsp;name&gt;();&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my_func&nbsp;=&nbsp;allocate;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my_func&nbsp;=&nbsp;&amp;allocate();&nbsp;<BR>
&nbsp;<BR>
Usage&nbsp;of&nbsp;the&nbsp;new&nbsp;function&nbsp;reference&nbsp;is&nbsp;done&nbsp;just&nbsp;as&nbsp;with&nbsp;the&nbsp;ordinary&nbsp;function&nbsp;call.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;*i_arr;&nbsp;<BR>
&nbsp;<BR>
i_arr&nbsp;=&nbsp;allocate(5);&nbsp;&nbsp;//&nbsp;Is&nbsp;the&nbsp;same&nbsp;as...&nbsp;<BR>
i_arr&nbsp;=&nbsp;my_func(5);&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;using&nbsp;the&nbsp;function&nbsp;assignment&nbsp;above.&nbsp;<BR>
&nbsp;<BR>
This&nbsp;will&nbsp;be&nbsp;enough&nbsp;for&nbsp;now.&nbsp;Later&nbsp;I'll&nbsp;explain&nbsp;how&nbsp;to&nbsp;create&nbsp;partial&nbsp;function&nbsp;applications,&nbsp;internal&nbsp;and&nbsp;<BR>
external&nbsp;function&nbsp;declarations&nbsp;and&nbsp;how&nbsp;to&nbsp;use&nbsp;them&nbsp;in&nbsp;complex&nbsp;function&nbsp;combinations.&nbsp;&nbsp;<BR>
&nbsp;<BR>
switch/case&nbsp;part&nbsp;2&nbsp;<BR>
&nbsp;<BR>
The&nbsp;LPC&nbsp;switch&nbsp;statement&nbsp;is&nbsp;very&nbsp;intelligent,&nbsp;it&nbsp;can&nbsp;also&nbsp;use&nbsp;ranges&nbsp;in&nbsp;integers:&nbsp;&nbsp;<BR>
&nbsp;<BR>
public&nbsp;void&nbsp;<BR>
wheel_of_fortune()&nbsp;<BR>
{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;random(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Get&nbsp;a&nbsp;random&nbsp;number&nbsp;0&nbsp;-&nbsp;9&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Strictly&nbsp;speaking,&nbsp;this&nbsp;local&nbsp;variable&nbsp;isn't&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;necessary,&nbsp;it's&nbsp;just&nbsp;there&nbsp;to&nbsp;demonstrate&nbsp;the&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;use&nbsp;and&nbsp;make&nbsp;things&nbsp;clearer.&nbsp;I&nbsp;could&nbsp;have&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;switched&nbsp;on&nbsp;'random(10)'&nbsp;directly&nbsp;instead&nbsp;if&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;I&nbsp;had&nbsp;wanted&nbsp;to.&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(i)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;0..4:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Try&nbsp;again,&nbsp;sucker!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;5..6:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Congrats,&nbsp;third&nbsp;prize!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;7..8:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Yes!&nbsp;Second&nbsp;prize!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;9:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;WOOOOPS!&nbsp;You&nbsp;did&nbsp;it!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Someone&nbsp;has&nbsp;tinkered&nbsp;with&nbsp;the&nbsp;wheel...&nbsp;Call&nbsp;911!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
}&nbsp;<BR>
&nbsp;<BR>
catch/throw:&nbsp;Error&nbsp;handling&nbsp;during&nbsp;runtime&nbsp;<BR>
&nbsp;<BR>
It&nbsp;happens&nbsp;now&nbsp;and&nbsp;then&nbsp;that&nbsp;you&nbsp;need&nbsp;to&nbsp;make&nbsp;function&nbsp;calls&nbsp;you&nbsp;know&nbsp;might&nbsp;result&nbsp;in&nbsp;a&nbsp;runtime&nbsp;<BR>
error.&nbsp;For&nbsp;example&nbsp;you&nbsp;might&nbsp;try&nbsp;to&nbsp;clone&nbsp;an&nbsp;object&nbsp;(described&nbsp;later)&nbsp;or&nbsp;read&nbsp;a&nbsp;file.&nbsp;If&nbsp;the&nbsp;files&nbsp;aren't&nbsp;<BR>
there&nbsp;or&nbsp;your&nbsp;privileges&nbsp;are&nbsp;wrong&nbsp;you&nbsp;will&nbsp;get&nbsp;a&nbsp;runtime&nbsp;error&nbsp;and&nbsp;execution&nbsp;will&nbsp;stop.&nbsp;In&nbsp;these&nbsp;<BR>
circumstances&nbsp;it&nbsp;is&nbsp;desireable&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;intercept&nbsp;the&nbsp;error&nbsp;and&nbsp;either&nbsp;display&nbsp;some&nbsp;kind&nbsp;of&nbsp;<BR>
message&nbsp;or&nbsp;perform&nbsp;other&nbsp;actions&nbsp;instead.&nbsp;The&nbsp;special&nbsp;LPC&nbsp;function&nbsp;operator&nbsp;catch()&nbsp;will&nbsp;do&nbsp;this&nbsp;for&nbsp;<BR>
you.&nbsp;It&nbsp;returns&nbsp;1&nbsp;(true)&nbsp;if&nbsp;an&nbsp;error&nbsp;occurs&nbsp;during&nbsp;evaluation&nbsp;of&nbsp;the&nbsp;given&nbsp;function&nbsp;and&nbsp;0&nbsp;(false)&nbsp;<BR>
otherwise.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;catch(function)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(catch(tail(&quot;/d/Relic/fatty/hidden_donut_map&quot;)))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Sorry,&nbsp;not&nbsp;possible&nbsp;to&nbsp;read&nbsp;that&nbsp;file.\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
It's&nbsp;also&nbsp;possible&nbsp;to&nbsp;cause&nbsp;error&nbsp;interrupts.&nbsp;This&nbsp;is&nbsp;particularly&nbsp;useful&nbsp;when&nbsp;you&nbsp;want&nbsp;to&nbsp;notify&nbsp;the&nbsp;user&nbsp;<BR>
of&nbsp;an&nbsp;unplanned&nbsp;for&nbsp;event&nbsp;that&nbsp;occured&nbsp;during&nbsp;execution.&nbsp;Typically&nbsp;you&nbsp;want&nbsp;to&nbsp;do&nbsp;this&nbsp;in&nbsp;the&nbsp;'default'&nbsp;<BR>
case&nbsp;of&nbsp;a&nbsp;switch&nbsp;statement,&nbsp;unless&nbsp;(naturally)&nbsp;you&nbsp;use&nbsp;default&nbsp;as&nbsp;a&nbsp;sort&nbsp;of&nbsp;catch-it-all&nbsp;position.&nbsp;In&nbsp;<BR>
any&nbsp;case&nbsp;throw()&nbsp;will&nbsp;generate&nbsp;a&nbsp;runtime&nbsp;error&nbsp;with&nbsp;the&nbsp;message&nbsp;you&nbsp;specify.&nbsp;A&nbsp;catch()&nbsp;<BR>
statement&nbsp;issued&nbsp;prior&nbsp;to&nbsp;calling&nbsp;the&nbsp;function&nbsp;that&nbsp;uses&nbsp;throw()&nbsp;will&nbsp;naturally&nbsp;intercept&nbsp;the&nbsp;error&nbsp;as&nbsp;<BR>
usual.&nbsp;&nbsp;<BR>
&nbsp;<BR>
throw(mixed&nbsp;info)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(test&nbsp;&lt;&nbsp;5)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(&quot;The&nbsp;variable&nbsp;'test'&nbsp;is&nbsp;less&nbsp;than&nbsp;5\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Array&nbsp;&amp;&nbsp;Mapping&nbsp;references&nbsp;<BR>
&nbsp;<BR>
In&nbsp;comp&nbsp;sci&nbsp;terms,&nbsp;arrays&nbsp;and&nbsp;mappings&nbsp;are&nbsp;used&nbsp;as&nbsp;reference&nbsp;by&nbsp;pointer&nbsp;and&nbsp;the&nbsp;other&nbsp;types&nbsp;as&nbsp;<BR>
reference&nbsp;by&nbsp;value.&nbsp;This&nbsp;means&nbsp;that&nbsp;arrays&nbsp;and&nbsp;mappings,&nbsp;unlike&nbsp;other&nbsp;variables,&nbsp;aren't&nbsp;copied&nbsp;<BR>
every&nbsp;time&nbsp;they&nbsp;are&nbsp;moved&nbsp;around.&nbsp;Instead,&nbsp;what&nbsp;is&nbsp;moved&nbsp;is&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;original&nbsp;array&nbsp;or&nbsp;<BR>
mapping.&nbsp;What&nbsp;does&nbsp;this&nbsp;mean&nbsp;then?&nbsp;&nbsp;<BR>
&nbsp;<BR>
Well...&nbsp;simply&nbsp;this:&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;*arr,&nbsp;*copy_arr;&nbsp;<BR>
&nbsp;<BR>
arr&nbsp;=&nbsp;({&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;An&nbsp;array&nbsp;<BR>
&nbsp;<BR>
copy_arr&nbsp;=&nbsp;arr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Assume&nbsp;(wrongly)&nbsp;that&nbsp;a&nbsp;copy_arr&nbsp;becomes&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;copy&nbsp;of&nbsp;arr.&nbsp;<BR>
&nbsp;<BR>
//&nbsp;Change&nbsp;the&nbsp;first&nbsp;value&nbsp;(1)&nbsp;into&nbsp;5.&nbsp;<BR>
copy_arr[0]&nbsp;=&nbsp;5;&nbsp;<BR>
&nbsp;<BR>
...&nbsp;Now...&nbsp;this&nbsp;far&nbsp;down&nbsp;the&nbsp;code&nbsp;it's&nbsp;logical&nbsp;to&nbsp;assume&nbsp;that&nbsp;the&nbsp;first&nbsp;value&nbsp;of&nbsp;copy_arr&nbsp;is&nbsp;5&nbsp;while&nbsp;the&nbsp;<BR>
first&nbsp;value&nbsp;or&nbsp;arr&nbsp;is&nbsp;1.&nbsp;That's&nbsp;not&nbsp;so&nbsp;however,&nbsp;because&nbsp;what&nbsp;got&nbsp;copied&nbsp;into&nbsp;copy_arr&nbsp;was&nbsp;not&nbsp;the&nbsp;<BR>
array&nbsp;itself,&nbsp;but&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;same&nbsp;array&nbsp;as&nbsp;arr.&nbsp;This&nbsp;means&nbsp;that&nbsp;your&nbsp;operation&nbsp;later&nbsp;where&nbsp;you&nbsp;<BR>
changed&nbsp;an&nbsp;element,&nbsp;changed&nbsp;that&nbsp;element&nbsp;in&nbsp;the&nbsp;original&nbsp;array&nbsp;which&nbsp;both&nbsp;variables&nbsp;refer&nbsp;to.&nbsp;<BR>
copy_arr&nbsp;and&nbsp;arr&nbsp;will&nbsp;both&nbsp;seem&nbsp;to&nbsp;have&nbsp;changed,&nbsp;while&nbsp;in&nbsp;fact&nbsp;it&nbsp;was&nbsp;only&nbsp;the&nbsp;original&nbsp;array&nbsp;that&nbsp;<BR>
both&nbsp;refered&nbsp;to&nbsp;that&nbsp;changed.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Exactly&nbsp;the&nbsp;same&nbsp;thing&nbsp;will&nbsp;happen&nbsp;if&nbsp;you&nbsp;use&nbsp;mappings&nbsp;since&nbsp;they&nbsp;work&nbsp;the&nbsp;same&nbsp;way&nbsp;in&nbsp;this&nbsp;respect.&nbsp;<BR>
&nbsp;<BR>
So...&nbsp;how&nbsp;do&nbsp;you&nbsp;get&nbsp;around&nbsp;this&nbsp;then?&nbsp;I&nbsp;mean...&nbsp;most&nbsp;times&nbsp;you&nbsp;really&nbsp;want&nbsp;to&nbsp;work&nbsp;on&nbsp;a&nbsp;copy&nbsp;and&nbsp;not&nbsp;<BR>
the&nbsp;original&nbsp;array&nbsp;or&nbsp;mapping.&nbsp;The&nbsp;solution&nbsp;is&nbsp;very&nbsp;simple&nbsp;actually.&nbsp;You&nbsp;just&nbsp;make&nbsp;sure&nbsp;that&nbsp;the&nbsp;copy&nbsp;is&nbsp;<BR>
created&nbsp;from&nbsp;another&nbsp;array&nbsp;or&nbsp;mapping&nbsp;instead.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;This&nbsp;is&nbsp;just&nbsp;an&nbsp;empty&nbsp;array&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;<BR>
copy_arr&nbsp;=&nbsp;({&nbsp;})&nbsp;+&nbsp;arr;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\_&nbsp;This&nbsp;is&nbsp;the&nbsp;one&nbsp;we&nbsp;want&nbsp;to&nbsp;make&nbsp;unique&nbsp;<BR>
&nbsp;<BR>
In&nbsp;this&nbsp;example&nbsp;copy_arr&nbsp;becomes&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;empty&nbsp;array&nbsp;and&nbsp;the&nbsp;arr&nbsp;array&nbsp;created&nbsp;as&nbsp;an&nbsp;<BR>
entirely&nbsp;new&nbsp;array.&nbsp;This&nbsp;leaves&nbsp;the&nbsp;original&nbsp;unchanged,&nbsp;just&nbsp;as&nbsp;we&nbsp;wanted.&nbsp;You&nbsp;can&nbsp;do&nbsp;exactly&nbsp;the&nbsp;<BR>
same&nbsp;thing&nbsp;with&nbsp;mappings.&nbsp;It&nbsp;doesn't&nbsp;matter&nbsp;if&nbsp;you&nbsp;add&nbsp;the&nbsp;empty&nbsp;array&nbsp;or&nbsp;mapping&nbsp;first&nbsp;or&nbsp;last,&nbsp;just&nbsp;<BR>
as&nbsp;long&nbsp;as&nbsp;you&nbsp;do&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;klab.ishii.utsu]&nbsp;<BR>
<A HREF="00000011.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000013.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>