<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;jameson&nbsp;(阿其),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;LPC&nbsp;Manual&nbsp;-&nbsp;Essential&nbsp;LPC&nbsp;and&nbsp;MUDLIB&nbsp;(5)&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Fri&nbsp;May&nbsp;23&nbsp;22:49:20&nbsp;1997)&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
How&nbsp;to&nbsp;obtain&nbsp;object&nbsp;references&nbsp;<BR>
&nbsp;<BR>
Objects,&nbsp;as&nbsp;previously&nbsp;described,&nbsp;comes&nbsp;in&nbsp;two&nbsp;kinds&nbsp;-&nbsp;master&nbsp;objects&nbsp;and&nbsp;clones.&nbsp;In&nbsp;general&nbsp;you&nbsp;tend&nbsp;to&nbsp;use&nbsp;cloned&nbsp;objects.&nbsp;At&nbsp;least&nbsp;for&nbsp;<BR>
objects&nbsp;that&nbsp;are&nbsp;being&nbsp;'handled'&nbsp;in&nbsp;the&nbsp;game,&nbsp;objects&nbsp;that&nbsp;you&nbsp;can&nbsp;move&nbsp;about,&nbsp;touch,&nbsp;examine&nbsp;etc,&nbsp;or&nbsp;any&nbsp;object&nbsp;that&nbsp;exist&nbsp;in&nbsp;more&nbsp;than&nbsp;one&nbsp;<BR>
copy.&nbsp;Making&nbsp;exclusive&nbsp;use&nbsp;of&nbsp;only&nbsp;the&nbsp;master&nbsp;object&nbsp;is&nbsp;usually&nbsp;only&nbsp;done&nbsp;for&nbsp;rooms,&nbsp;souls&nbsp;or&nbsp;dameon&nbsp;objects&nbsp;of&nbsp;various&nbsp;kinds.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Naturally&nbsp;any&nbsp;object&nbsp;in&nbsp;the&nbsp;game&nbsp;must&nbsp;have&nbsp;a&nbsp;master&nbsp;object.&nbsp;An&nbsp;object&nbsp;is&nbsp;loaded&nbsp;into&nbsp;memory&nbsp;and&nbsp;the&nbsp;master&nbsp;object&nbsp;created&nbsp;when&nbsp;a&nbsp;function&nbsp;<BR>
(any&nbsp;function&nbsp;call,&nbsp;even&nbsp;to&nbsp;a&nbsp;non-existing&nbsp;function)&nbsp;is&nbsp;called&nbsp;in&nbsp;it.&nbsp;Cloning&nbsp;it&nbsp;just&nbsp;makes&nbsp;identical&nbsp;copies&nbsp;of&nbsp;it.&nbsp;If&nbsp;you&nbsp;destroy&nbsp;the&nbsp;master&nbsp;object,&nbsp;<BR>
the&nbsp;gamedriver&nbsp;will&nbsp;have&nbsp;to&nbsp;load&nbsp;it&nbsp;again&nbsp;later&nbsp;before&nbsp;making&nbsp;any&nbsp;new&nbsp;clones.&nbsp;Naturally&nbsp;this&nbsp;is&nbsp;what&nbsp;you&nbsp;do&nbsp;every&nbsp;time&nbsp;you&nbsp;have&nbsp;made&nbsp;changes&nbsp;<BR>
to&nbsp;the&nbsp;object&nbsp;that&nbsp;you&nbsp;want&nbsp;to&nbsp;become&nbsp;active.&nbsp;Destroying&nbsp;the&nbsp;master&nbsp;object&nbsp;won't&nbsp;change&nbsp;the&nbsp;already&nbsp;existing&nbsp;clones,&nbsp;of&nbsp;course.&nbsp;You'll&nbsp;have&nbsp;to&nbsp;<BR>
replace&nbsp;them&nbsp;separately.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;mudlib&nbsp;in&nbsp;fact&nbsp;works&nbsp;so&nbsp;that&nbsp;loading&nbsp;an&nbsp;object&nbsp;is&nbsp;made&nbsp;by&nbsp;calling&nbsp;a&nbsp;non-existing&nbsp;function&nbsp;in&nbsp;the&nbsp;object&nbsp;and&nbsp;updating&nbsp;it&nbsp;simply&nbsp;destroys&nbsp;<BR>
the&nbsp;master&nbsp;object.&nbsp;&nbsp;<BR>
&nbsp;<BR>
How&nbsp;to&nbsp;get&nbsp;the&nbsp;object&nbsp;references&nbsp;then?&nbsp;Well,&nbsp;that&nbsp;depends&nbsp;on&nbsp;the&nbsp;situation.&nbsp;An&nbsp;object&nbsp;reference&nbsp;is&nbsp;either&nbsp;an&nbsp;object&nbsp;pointer&nbsp;or&nbsp;a&nbsp;string&nbsp;path,&nbsp;<BR>
referring&nbsp;to&nbsp;the&nbsp;object&nbsp;source&nbsp;in&nbsp;the&nbsp;mud&nbsp;filesystem.&nbsp;Obtaining&nbsp;them&nbsp;is&nbsp;different&nbsp;depending&nbsp;on&nbsp;the&nbsp;situation&nbsp;however.&nbsp;Let's&nbsp;go&nbsp;through&nbsp;them&nbsp;<BR>
all.&nbsp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relative&nbsp;references:&nbsp;References&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;object&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creating&nbsp;objects:&nbsp;How&nbsp;to&nbsp;create&nbsp;an&nbsp;object&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finding&nbsp;relative&nbsp;refs:&nbsp;Find&nbsp;a&nbsp;reference&nbsp;relative&nbsp;to&nbsp;another&nbsp;object&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interactive&nbsp;object&nbsp;refs:&nbsp;References&nbsp;to&nbsp;interactive&nbsp;objects&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroying&nbsp;objects:&nbsp;How&nbsp;to&nbsp;get&nbsp;rid&nbsp;of&nbsp;objects&nbsp;&nbsp;<BR>
&nbsp;<BR>
Object&nbsp;references&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;object&nbsp;<BR>
&nbsp;<BR>
[this_object,&nbsp;previous_object,&nbsp;calling_object]&nbsp;&nbsp;<BR>
&nbsp;<BR>
An&nbsp;object&nbsp;can&nbsp;always&nbsp;get&nbsp;the&nbsp;object&nbsp;reference&nbsp;to&nbsp;itself.&nbsp;Use&nbsp;the&nbsp;efun&nbsp;this_object():&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;this_object()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;ob;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ob&nbsp;=&nbsp;this_object();&nbsp;<BR>
&nbsp;<BR>
In&nbsp;order&nbsp;to&nbsp;find&nbsp;out&nbsp;which&nbsp;object&nbsp;called&nbsp;the&nbsp;currently&nbsp;running&nbsp;function&nbsp;in&nbsp;an&nbsp;object&nbsp;using&nbsp;an&nbsp;external&nbsp;call,&nbsp;you&nbsp;can&nbsp;use&nbsp;the&nbsp;efun&nbsp;<BR>
'previous_object()':&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;previous_object(void|int&nbsp;step)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;p_ob,&nbsp;pp_ob;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;p_ob&nbsp;=&nbsp;previous_object();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;object&nbsp;calling&nbsp;this&nbsp;function.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;pp_ob&nbsp;=&nbsp;previous_object(-2);&nbsp;&nbsp;//&nbsp;The&nbsp;object&nbsp;calling&nbsp;the&nbsp;object&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;calling&nbsp;this&nbsp;function.&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;supply&nbsp;no&nbsp;argument&nbsp;or&nbsp;-1,&nbsp;the&nbsp;function&nbsp;will&nbsp;return&nbsp;the&nbsp;immediately&nbsp;previous&nbsp;object&nbsp;that&nbsp;called.&nbsp;Decrementing&nbsp;the&nbsp;argument&nbsp;further&nbsp;will&nbsp;<BR>
return&nbsp;even&nbsp;more&nbsp;previous&nbsp;callers,&nbsp;i.e&nbsp;previous_object(-4)&nbsp;returns&nbsp;the&nbsp;object&nbsp;that&nbsp;called&nbsp;the&nbsp;object&nbsp;that&nbsp;called&nbsp;the&nbsp;object&nbsp;that&nbsp;called&nbsp;your&nbsp;<BR>
object.&nbsp;If&nbsp;indeed&nbsp;the&nbsp;chain&nbsp;of&nbsp;calling&nbsp;objects&nbsp;was&nbsp;that&nbsp;long.&nbsp;When&nbsp;you&nbsp;exceed&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;calling&nbsp;chain&nbsp;beyond&nbsp;the&nbsp;first&nbsp;object&nbsp;that&nbsp;made&nbsp;<BR>
a&nbsp;call,&nbsp;the&nbsp;function&nbsp;will&nbsp;return&nbsp;0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
As&nbsp;I&nbsp;hope&nbsp;you&nbsp;noticed,&nbsp;this&nbsp;call&nbsp;only&nbsp;checks&nbsp;for&nbsp;external&nbsp;calls,&nbsp;not&nbsp;internal.&nbsp;There&nbsp;is&nbsp;a&nbsp;corresponding&nbsp;efun&nbsp;that&nbsp;works&nbsp;just&nbsp;the&nbsp;same&nbsp;but&nbsp;for&nbsp;any&nbsp;<BR>
type&nbsp;of&nbsp;call&nbsp;(internal&nbsp;or&nbsp;external)&nbsp;that&nbsp;has&nbsp;been&nbsp;made:&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;calling_object(void|int&nbsp;step)&nbsp;<BR>
&nbsp;<BR>
The&nbsp;usage&nbsp;is&nbsp;the&nbsp;same&nbsp;however.&nbsp;&nbsp;<BR>
&nbsp;<BR>
So...&nbsp;how&nbsp;do&nbsp;you&nbsp;know&nbsp;if&nbsp;the&nbsp;object&nbsp;reference&nbsp;you&nbsp;just&nbsp;received&nbsp;is&nbsp;a&nbsp;valid&nbsp;object&nbsp;or&nbsp;not&nbsp;(i.e.&nbsp;0&nbsp;or&nbsp;something&nbsp;else)?&nbsp;Well,&nbsp;use&nbsp;the&nbsp;nice&nbsp;efun&nbsp;<BR>
objectp()&nbsp;as&nbsp;described&nbsp;earlier.&nbsp;It&nbsp;returns&nbsp;1&nbsp;if&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;valid&nbsp;object&nbsp;pointer&nbsp;and&nbsp;0&nbsp;otherwise.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;objectp(mixed&nbsp;ob)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(objectp(calling_object(-2)))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Yes,&nbsp;an&nbsp;ob&nbsp;calling&nbsp;an&nbsp;ob&nbsp;calling&nbsp;this&nbsp;object&nbsp;exists!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;No&nbsp;such&nbsp;luck.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Creating&nbsp;objects&nbsp;<BR>
&nbsp;<BR>
[setuid,&nbsp;getuid,&nbsp;seteuid,&nbsp;geteuid,&nbsp;creator,&nbsp;set_auth,&nbsp;query_auth,&nbsp;clone_object]&nbsp;&nbsp;<BR>
&nbsp;<BR>
First&nbsp;of&nbsp;all&nbsp;you&nbsp;must&nbsp;make&nbsp;sure&nbsp;that&nbsp;the&nbsp;object&nbsp;that&nbsp;tries&nbsp;to&nbsp;create&nbsp;a&nbsp;new&nbsp;object&nbsp;has&nbsp;the&nbsp;privileges&nbsp;required&nbsp;to&nbsp;do&nbsp;so.&nbsp;The&nbsp;rules&nbsp;are&nbsp;pretty&nbsp;simple&nbsp;<BR>
actually:&nbsp;An&nbsp;object&nbsp;with&nbsp;a&nbsp;valid&nbsp;euid&nbsp;can&nbsp;clone&nbsp;any&nbsp;other&nbsp;object.&nbsp;A&nbsp;valid&nbsp;euid&nbsp;is&nbsp;anything&nbsp;except&nbsp;0.&nbsp;The&nbsp;euid&nbsp;0&nbsp;is&nbsp;the&nbsp;default&nbsp;uid&nbsp;and&nbsp;euid&nbsp;on&nbsp;<BR>
creation&nbsp;of&nbsp;an&nbsp;object,&nbsp;and&nbsp;it's&nbsp;used&nbsp;as&nbsp;meaning&nbsp;'no&nbsp;privileges&nbsp;at&nbsp;all'.&nbsp;&nbsp;<BR>
&nbsp;<BR>
However,&nbsp;usually&nbsp;the&nbsp;choice&nbsp;of&nbsp;euids&nbsp;you&nbsp;can&nbsp;set&nbsp;is&nbsp;pretty&nbsp;limited.&nbsp;If&nbsp;you're&nbsp;a&nbsp;wiz&nbsp;it's&nbsp;usually&nbsp;limited&nbsp;to&nbsp;your&nbsp;own&nbsp;name.&nbsp;A&nbsp;Lord&nbsp;can&nbsp;set&nbsp;the&nbsp;euid&nbsp;<BR>
in&nbsp;an&nbsp;object&nbsp;to&nbsp;be&nbsp;his,&nbsp;or&nbsp;any&nbsp;of&nbsp;the&nbsp;wizard's&nbsp;in&nbsp;the&nbsp;domain&nbsp;(unless&nbsp;one&nbsp;of&nbsp;the&nbsp;wizards&nbsp;is&nbsp;an&nbsp;Archwiz,&nbsp;then&nbsp;that&nbsp;one&nbsp;is&nbsp;excempt&nbsp;as&nbsp;well).&nbsp;And&nbsp;<BR>
naturally&nbsp;objects&nbsp;with&nbsp;'root'&nbsp;uid&nbsp;can&nbsp;set&nbsp;any&nbsp;euid&nbsp;they&nbsp;like.&nbsp;&nbsp;<BR>
&nbsp;<BR>
So...&nbsp;the&nbsp;uid&nbsp;of&nbsp;the&nbsp;object&nbsp;determines&nbsp;what&nbsp;choice&nbsp;of&nbsp;euids&nbsp;you&nbsp;have.&nbsp;You&nbsp;set&nbsp;the&nbsp;uid&nbsp;to&nbsp;the&nbsp;default&nbsp;value&nbsp;by&nbsp;adding&nbsp;this&nbsp;sfun&nbsp;call:&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;setuid()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setuid();&nbsp;<BR>
&nbsp;<BR>
Simple&nbsp;eh?&nbsp;Doing&nbsp;that&nbsp;sets&nbsp;the&nbsp;uid&nbsp;to&nbsp;the&nbsp;value&nbsp;determined&nbsp;by&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;object&nbsp;source-file&nbsp;in&nbsp;the&nbsp;mud&nbsp;filesystem.&nbsp;The&nbsp;rules&nbsp;for&nbsp;this&nbsp;is&nbsp;<BR>
the&nbsp;same&nbsp;as&nbsp;for&nbsp;the&nbsp;creator&nbsp;value&nbsp;described&nbsp;earlier.&nbsp;You&nbsp;can&nbsp;get&nbsp;the&nbsp;creator&nbsp;value&nbsp;of&nbsp;an&nbsp;object&nbsp;with&nbsp;the&nbsp;sfun&nbsp;creator(),&nbsp;it&nbsp;simply&nbsp;returns&nbsp;the&nbsp;<BR>
string&nbsp;setuid()&nbsp;would&nbsp;use&nbsp;for&nbsp;that&nbsp;object.&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;creator(mixed&nbsp;reference)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;my_creator;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my_creator&nbsp;=&nbsp;creator(this_object());&nbsp;<BR>
&nbsp;<BR>
To&nbsp;get&nbsp;the&nbsp;actual&nbsp;uid&nbsp;value&nbsp;that&nbsp;is&nbsp;currently&nbsp;used,&nbsp;you&nbsp;the&nbsp;sfun&nbsp;getuid()&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;getuid()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;curr_uid;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;curr_uid&nbsp;=&nbsp;getuid();&nbsp;<BR>
&nbsp;<BR>
So..&nbsp;the&nbsp;uid&nbsp;is&nbsp;now&nbsp;set&nbsp;to&nbsp;the&nbsp;highest&nbsp;privilege&nbsp;giver.&nbsp;The&nbsp;euid&nbsp;however,&nbsp;is&nbsp;still&nbsp;0.&nbsp;Since&nbsp;the&nbsp;euid&nbsp;determines&nbsp;the&nbsp;actual&nbsp;privileges&nbsp;used&nbsp;in&nbsp;an&nbsp;<BR>
object&nbsp;this&nbsp;means&nbsp;that&nbsp;the&nbsp;object&nbsp;still&nbsp;has&nbsp;no&nbsp;privileges&nbsp;at&nbsp;all.&nbsp;&nbsp;<BR>
&nbsp;<BR>
To&nbsp;set&nbsp;the&nbsp;euid&nbsp;you&nbsp;use&nbsp;the&nbsp;sfun&nbsp;seteuid(),&nbsp;the&nbsp;argument&nbsp;given&nbsp;will&nbsp;be&nbsp;set&nbsp;as&nbsp;euid&nbsp;if&nbsp;allowed&nbsp;(it's&nbsp;tested).&nbsp;The&nbsp;function&nbsp;returns&nbsp;0&nbsp;on&nbsp;failure&nbsp;<BR>
and&nbsp;1&nbsp;on&nbsp;success.&nbsp;If&nbsp;you&nbsp;don't&nbsp;send&nbsp;any&nbsp;argument,&nbsp;the&nbsp;euid&nbsp;is&nbsp;set&nbsp;to&nbsp;0,&nbsp;'turning&nbsp;it&nbsp;off'&nbsp;so&nbsp;to&nbsp;speak.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;seteuid(void|string&nbsp;priv_giver)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(seteuid(&quot;mrpr&quot;))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Yes!&nbsp;I'm&nbsp;the&nbsp;ruler&nbsp;of&nbsp;the&nbsp;UNIVERSE!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Awwwww....\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Naturally&nbsp;there's&nbsp;a&nbsp;corresponding&nbsp;sfun&nbsp;to&nbsp;return&nbsp;the&nbsp;current&nbsp;euid:&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;geteuid()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;The&nbsp;current&nbsp;euid&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;geteuid()&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;<BR>
The&nbsp;sfuns&nbsp;setuid(),&nbsp;getuid(),&nbsp;seteuid()&nbsp;and&nbsp;geteuid()&nbsp;are&nbsp;all&nbsp;using&nbsp;the&nbsp;efuns&nbsp;set_auth()&nbsp;and&nbsp;get_auth().&nbsp;They&nbsp;are&nbsp;used&nbsp;to&nbsp;<BR>
manipulate&nbsp;a&nbsp;special&nbsp;authority&nbsp;variable&nbsp;inside&nbsp;the&nbsp;object&nbsp;in&nbsp;the&nbsp;gamedriver.&nbsp;The&nbsp;gamedriver&nbsp;will&nbsp;call&nbsp;a&nbsp;validizing&nbsp;function&nbsp;in&nbsp;the&nbsp;master&nbsp;object&nbsp;<BR>
(security)&nbsp;if&nbsp;you&nbsp;try&nbsp;to&nbsp;use&nbsp;set_auth()&nbsp;to&nbsp;make&nbsp;sure&nbsp;that&nbsp;you&nbsp;are&nbsp;privileged&nbsp;to&nbsp;do&nbsp;so.&nbsp;The&nbsp;reason&nbsp;is&nbsp;that&nbsp;it's&nbsp;possible&nbsp;to&nbsp;store&nbsp;any&nbsp;kind&nbsp;of&nbsp;<BR>
string&nbsp;in&nbsp;the&nbsp;authority&nbsp;variable,&nbsp;and&nbsp;the&nbsp;way&nbsp;we&nbsp;use&nbsp;it&nbsp;is&nbsp;merely&nbsp;a&nbsp;convention,&nbsp;something&nbsp;that&nbsp;we&nbsp;have&nbsp;decided&nbsp;is&nbsp;the&nbsp;best&nbsp;way&nbsp;of&nbsp;solving&nbsp;<BR>
security.&nbsp;&nbsp;<BR>
&nbsp;<BR>
When&nbsp;you&nbsp;try&nbsp;to&nbsp;perform&nbsp;a&nbsp;privileged&nbsp;operation,&nbsp;like&nbsp;writing&nbsp;to&nbsp;a&nbsp;file&nbsp;or&nbsp;cloning&nbsp;an&nbsp;object&nbsp;the&nbsp;gamedriver&nbsp;calls&nbsp;other&nbsp;special&nbsp;functions&nbsp;in&nbsp;the&nbsp;<BR>
master&nbsp;object&nbsp;to&nbsp;make&nbsp;sure&nbsp;you&nbsp;have&nbsp;the&nbsp;right&nbsp;privileges.&nbsp;They&nbsp;all&nbsp;depend&nbsp;on&nbsp;that&nbsp;the&nbsp;information&nbsp;stored&nbsp;in&nbsp;the&nbsp;authority&nbsp;variable&nbsp;is&nbsp;formatted&nbsp;<BR>
in&nbsp;the&nbsp;special&nbsp;way&nbsp;we&nbsp;want&nbsp;for&nbsp;it&nbsp;to&nbsp;work&nbsp;properly.&nbsp;Due&nbsp;to&nbsp;this&nbsp;fact&nbsp;you&nbsp;are&nbsp;not&nbsp;allowed&nbsp;to&nbsp;use&nbsp;set_auth()&nbsp;in&nbsp;any&nbsp;other&nbsp;way&nbsp;than&nbsp;already&nbsp;is&nbsp;<BR>
allowed&nbsp;by&nbsp;setuid()&nbsp;and&nbsp;seteuid(),&nbsp;so&nbsp;there's&nbsp;really&nbsp;no&nbsp;use&nbsp;in&nbsp;doing&nbsp;that&nbsp;at&nbsp;all.&nbsp;query_auth()&nbsp;is&nbsp;not&nbsp;protected&nbsp;but&nbsp;you&nbsp;won't&nbsp;find&nbsp;much&nbsp;<BR>
use&nbsp;for&nbsp;that&nbsp;information&nbsp;anyway.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;information&nbsp;stored&nbsp;in&nbsp;the&nbsp;authority&nbsp;variable&nbsp;is&nbsp;simply&nbsp;the&nbsp;uid&nbsp;and&nbsp;euid&nbsp;separated&nbsp;by&nbsp;a&nbsp;colon.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Now&nbsp;that&nbsp;we&nbsp;know&nbsp;how&nbsp;to&nbsp;give&nbsp;privileges&nbsp;to&nbsp;an&nbsp;object,&nbsp;let's&nbsp;find&nbsp;out&nbsp;how&nbsp;to&nbsp;make&nbsp;it&nbsp;clone&nbsp;others!&nbsp;The&nbsp;efun&nbsp;used&nbsp;is&nbsp;called&nbsp;clone_object(),&nbsp;it&nbsp;<BR>
loads&nbsp;and&nbsp;creates&nbsp;an&nbsp;object&nbsp;from&nbsp;a&nbsp;source&nbsp;file.&nbsp;If&nbsp;the&nbsp;cloning&nbsp;should&nbsp;fail,&nbsp;due&nbsp;to&nbsp;programming&nbsp;mistakes&nbsp;for&nbsp;example,&nbsp;an&nbsp;error&nbsp;message&nbsp;will&nbsp;be&nbsp;<BR>
given&nbsp;and&nbsp;execution&nbsp;of&nbsp;the&nbsp;current&nbsp;object&nbsp;aborted.&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;clone_object(string&nbsp;obref)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;magic_ring;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Set&nbsp;the&nbsp;object&nbsp;privileges&nbsp;so&nbsp;that&nbsp;it's&nbsp;possible&nbsp;to&nbsp;clone&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;setuid();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;seteuid(getuid());&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Actually&nbsp;clone&nbsp;the&nbsp;object&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;magic_ring&nbsp;=&nbsp;clone_object(&quot;/d/Domain/wiz/magic_ring&quot;);&nbsp;<BR>
&nbsp;<BR>
Naturally&nbsp;you&nbsp;only&nbsp;have&nbsp;to&nbsp;set&nbsp;the&nbsp;uid/euid&nbsp;of&nbsp;an&nbsp;object&nbsp;ONCE&nbsp;in&nbsp;an&nbsp;object&nbsp;and&nbsp;not&nbsp;every&nbsp;time&nbsp;you&nbsp;want&nbsp;to&nbsp;perform&nbsp;a&nbsp;privileged&nbsp;operation.&nbsp;The&nbsp;<BR>
most&nbsp;common&nbsp;procedure&nbsp;is&nbsp;to&nbsp;put&nbsp;thes&nbsp;uid/euid&nbsp;setting&nbsp;calls&nbsp;in&nbsp;a&nbsp;function&nbsp;that&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;object&nbsp;is&nbsp;first&nbsp;created,&nbsp;but&nbsp;more&nbsp;about&nbsp;that&nbsp;<BR>
later.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Now...&nbsp;when&nbsp;arrays&nbsp;or&nbsp;mappings&nbsp;were&nbsp;created&nbsp;they&nbsp;existed&nbsp;as&nbsp;long&nbsp;as&nbsp;any&nbsp;variable&nbsp;used&nbsp;them.&nbsp;If&nbsp;the&nbsp;variable&nbsp;was&nbsp;set&nbsp;to&nbsp;0,&nbsp;the&nbsp;data&nbsp;they&nbsp;<BR>
contained&nbsp;was&nbsp;scrapped&nbsp;as&nbsp;well.&nbsp;Is&nbsp;this&nbsp;true&nbsp;for&nbsp;objects&nbsp;as&nbsp;well?&nbsp;NO!&nbsp;It's&nbsp;not.&nbsp;The&nbsp;object&nbsp;will&nbsp;remain&nbsp;in&nbsp;the&nbsp;game&nbsp;as&nbsp;long&nbsp;as&nbsp;the&nbsp;gamedriver&nbsp;is&nbsp;<BR>
running,&nbsp;unless&nbsp;you&nbsp;explicitly&nbsp;destroy&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Finding&nbsp;references&nbsp;relative&nbsp;to&nbsp;another&nbsp;object&nbsp;<BR>
&nbsp;<BR>
[file_name,&nbsp;find_object,&nbsp;object_clones,&nbsp;find_living,&nbsp;set_living_name,&nbsp;MASTER_OB,&nbsp;IS_CLONE]&nbsp;&nbsp;<BR>
&nbsp;<BR>
As&nbsp;stated&nbsp;object&nbsp;references&nbsp;either&nbsp;are&nbsp;strings&nbsp;or&nbsp;object&nbsp;pointers.&nbsp;Turning&nbsp;an&nbsp;object&nbsp;reference&nbsp;to&nbsp;a&nbsp;string&nbsp;is&nbsp;done&nbsp;with&nbsp;the&nbsp;efun&nbsp;file_name():&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;file_name(object&nbsp;ob)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;This&nbsp;object&nbsp;is:&nbsp;&quot;&nbsp;+&nbsp;file_name(this_object())&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;<BR>
The&nbsp;string&nbsp;that&nbsp;pops&nbsp;out&nbsp;of&nbsp;file_name&nbsp;is&nbsp;the&nbsp;string&nbsp;representation&nbsp;of&nbsp;the&nbsp;object&nbsp;reference&nbsp;pointer.&nbsp;It's&nbsp;given&nbsp;as&nbsp;&lt;file&nbsp;path&gt;#&lt;object&nbsp;<BR>
number&gt;,&nbsp;for&nbsp;example&nbsp;&quot;/d/Domain/wiz/magic_potion#2321&quot;.&nbsp;This&nbsp;string&nbsp;is&nbsp;a&nbsp;valid&nbsp;object&nbsp;reference&nbsp;to&nbsp;that&nbsp;specific&nbsp;object&nbsp;as&nbsp;well.&nbsp;&nbsp;<BR>
&nbsp;<BR>
To&nbsp;turn&nbsp;a&nbsp;string&nbsp;object&nbsp;reference&nbsp;into&nbsp;an&nbsp;object&nbsp;pointer&nbsp;reference&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;find_object().&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;find_object(string&nbsp;obref)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;the_ob;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;master&nbsp;object&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;the_ob&nbsp;=&nbsp;find_object(&quot;/d/Domain/wiz/magic_potion&quot;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;specific&nbsp;clone&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;the_ob&nbsp;=&nbsp;find_object(&quot;/d/Domain/wiz/magic_potion#2321&quot;);&nbsp;<BR>
&nbsp;<BR>
If&nbsp;the&nbsp;function&nbsp;doesn't&nbsp;find&nbsp;the&nbsp;object&nbsp;(the&nbsp;path&nbsp;might&nbsp;be&nbsp;wrong,&nbsp;the&nbsp;specified&nbsp;clone&nbsp;might&nbsp;not&nbsp;exist&nbsp;or&nbsp;the&nbsp;object&nbsp;might&nbsp;not&nbsp;be&nbsp;loaded),&nbsp;it&nbsp;<BR>
returns&nbsp;0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Sometimes&nbsp;it's&nbsp;useful&nbsp;to&nbsp;find&nbsp;all&nbsp;the&nbsp;clones&nbsp;of&nbsp;a&nbsp;specific&nbsp;object.&nbsp;The&nbsp;efun&nbsp;for&nbsp;that&nbsp;is&nbsp;object_clones().&nbsp;It&nbsp;will&nbsp;return&nbsp;an&nbsp;array&nbsp;holding&nbsp;all&nbsp;<BR>
clones&nbsp;of&nbsp;the&nbsp;master&nbsp;object&nbsp;the&nbsp;object&nbsp;reference&nbsp;indictes.&nbsp;This&nbsp;means&nbsp;that&nbsp;you&nbsp;can&nbsp;give&nbsp;either&nbsp;a&nbsp;master&nbsp;object&nbsp;or&nbsp;an&nbsp;object&nbsp;clone&nbsp;pointer&nbsp;as&nbsp;<BR>
argument.&nbsp;However,&nbsp;be&nbsp;a&nbsp;bit&nbsp;careful&nbsp;here.&nbsp;If&nbsp;the&nbsp;object&nbsp;was&nbsp;updated&nbsp;and&nbsp;your&nbsp;provide&nbsp;the&nbsp;master&nbsp;object&nbsp;as&nbsp;argument,&nbsp;you&nbsp;will&nbsp;get&nbsp;a&nbsp;list&nbsp;of&nbsp;all&nbsp;<BR>
the&nbsp;'new'&nbsp;clones.&nbsp;If&nbsp;you&nbsp;give&nbsp;an&nbsp;old&nbsp;object&nbsp;as&nbsp;argument&nbsp;you&nbsp;will&nbsp;get&nbsp;a&nbsp;list&nbsp;of&nbsp;all&nbsp;contemporary&nbsp;objects,&nbsp;the&nbsp;objects&nbsp;of&nbsp;that&nbsp;'generation'.&nbsp;If&nbsp;no&nbsp;<BR>
clones&nbsp;can&nbsp;be&nbsp;found,&nbsp;an&nbsp;empty&nbsp;array&nbsp;is&nbsp;returned.&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;*object_clones(object&nbsp;obref)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;*ob_list;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ob_list&nbsp;=&nbsp;object_clones(find_object(&quot;/d/Domain/wiz/magic_potion&quot;));&nbsp;<BR>
&nbsp;<BR>
Some&nbsp;objects&nbsp;are&nbsp;living.&nbsp;In&nbsp;the&nbsp;game&nbsp;this&nbsp;denotes&nbsp;the&nbsp;fact&nbsp;that&nbsp;the&nbsp;objects&nbsp;can&nbsp;be&nbsp;attacked&nbsp;and&nbsp;(perhaps)&nbsp;killed&nbsp;and&nbsp;that&nbsp;they&nbsp;want&nbsp;to&nbsp;receive&nbsp;<BR>
command&nbsp;updates&nbsp;from&nbsp;objects&nbsp;that&nbsp;turn&nbsp;up&nbsp;either&nbsp;in&nbsp;the&nbsp;environment&nbsp;or&nbsp;the&nbsp;inventory&nbsp;of&nbsp;the&nbsp;object&nbsp;itself.&nbsp;Living&nbsp;objects&nbsp;have&nbsp;the&nbsp;option&nbsp;of&nbsp;<BR>
registering&nbsp;themselves&nbsp;in&nbsp;a&nbsp;special&nbsp;list&nbsp;in&nbsp;the&nbsp;gamedriver.&nbsp;This&nbsp;is&nbsp;done&nbsp;in&nbsp;order&nbsp;to&nbsp;make&nbsp;them&nbsp;easier&nbsp;to&nbsp;find.&nbsp;The&nbsp;special&nbsp;efun&nbsp;find_living()&nbsp;<BR>
looks&nbsp;for&nbsp;a&nbsp;named&nbsp;living&nbsp;object&nbsp;in&nbsp;the&nbsp;internal&nbsp;list&nbsp;of&nbsp;names.&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;*find_living(string&nbsp;name,&nbsp;void|int&nbsp;1)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;balrog_ob,&nbsp;*bals;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Search&nbsp;for&nbsp;the&nbsp;'balrog'&nbsp;monster&nbsp;in&nbsp;the&nbsp;game.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;balrog_ob&nbsp;=&nbsp;find_living(&quot;balrog&quot;);&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;give&nbsp;'1'&nbsp;as&nbsp;second&nbsp;argument,&nbsp;the&nbsp;efun&nbsp;will&nbsp;return&nbsp;a&nbsp;list&nbsp;of&nbsp;all&nbsp;objects&nbsp;with&nbsp;that&nbsp;name&nbsp;found&nbsp;instead.&nbsp;&nbsp;<BR>
&nbsp;<BR>
bals&nbsp;=&nbsp;find_living(&quot;balrog&quot;,&nbsp;1);&nbsp;<BR>
&nbsp;<BR>
If&nbsp;no&nbsp;living&nbsp;object&nbsp;with&nbsp;the&nbsp;given&nbsp;name&nbsp;can&nbsp;be&nbsp;found,&nbsp;0&nbsp;is&nbsp;returned.&nbsp;&nbsp;<BR>
&nbsp;<BR>
In&nbsp;order&nbsp;for&nbsp;the&nbsp;name&nbsp;to&nbsp;become&nbsp;part&nbsp;of&nbsp;the&nbsp;list&nbsp;of&nbsp;names,&nbsp;the&nbsp;object&nbsp;itself&nbsp;must&nbsp;add&nbsp;the&nbsp;name&nbsp;to&nbsp;the&nbsp;central&nbsp;list&nbsp;with&nbsp;the&nbsp;efun&nbsp;<BR>
set_living_name().&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;set_living_name(string&nbsp;name)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;is&nbsp;part&nbsp;of&nbsp;the&nbsp;'create()'&nbsp;function&nbsp;of&nbsp;the&nbsp;balrog&nbsp;above.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;set_living_name(&quot;balrog&quot;);&nbsp;<BR>
&nbsp;<BR>
Remember&nbsp;that&nbsp;if&nbsp;you&nbsp;have&nbsp;several&nbsp;objects&nbsp;with&nbsp;the&nbsp;same&nbsp;name,&nbsp;find_living()&nbsp;in&nbsp;the&nbsp;single&nbsp;object&nbsp;mode&nbsp;will&nbsp;randomly&nbsp;return&nbsp;one&nbsp;of&nbsp;them.&nbsp;&nbsp;<BR>
&nbsp;<BR>
For&nbsp;your&nbsp;own&nbsp;sake&nbsp;you&nbsp;ought&nbsp;to&nbsp;reserve&nbsp;the&nbsp;use&nbsp;of&nbsp;npc&nbsp;names&nbsp;with&nbsp;the&nbsp;special&nbsp;'banish'&nbsp;command&nbsp;in&nbsp;the&nbsp;game,&nbsp;so&nbsp;that&nbsp;no&nbsp;players&nbsp;turn&nbsp;up&nbsp;with&nbsp;<BR>
the&nbsp;same&nbsp;name&nbsp;as&nbsp;you&nbsp;npc.&nbsp;If&nbsp;that&nbsp;happens&nbsp;things&nbsp;are&nbsp;very&nbsp;likely&nbsp;to&nbsp;get&nbsp;confused...&nbsp;&nbsp;<BR>
&nbsp;<BR>
In&nbsp;order&nbsp;to&nbsp;get&nbsp;the&nbsp;master&nbsp;object&nbsp;reference&nbsp;of&nbsp;an&nbsp;object&nbsp;you&nbsp;have&nbsp;a&nbsp;pointer&nbsp;to,&nbsp;you&nbsp;can&nbsp;convert&nbsp;it&nbsp;to&nbsp;a&nbsp;string,&nbsp;then&nbsp;strip&nbsp;off&nbsp;the&nbsp;object&nbsp;specifying&nbsp;<BR>
bits.&nbsp;However,&nbsp;there's&nbsp;already&nbsp;a&nbsp;macro&nbsp;doing&nbsp;that&nbsp;in&nbsp;the&nbsp;standard&nbsp;package&nbsp;`/sys/macros.h'.&nbsp;Simply&nbsp;add&nbsp;the&nbsp;line&nbsp;#include&nbsp;&lt;macros.h&gt;&nbsp;<BR>
to&nbsp;the&nbsp;top&nbsp;of&nbsp;your&nbsp;file&nbsp;and&nbsp;use&nbsp;the&nbsp;macro&nbsp;MASTER_OB.&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;MASTER_OB(object&nbsp;ob)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;master;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Assume&nbsp;that&nbsp;/sys/macros.h&nbsp;is&nbsp;included&nbsp;in&nbsp;this&nbsp;file.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;master&nbsp;=&nbsp;MASTER_OB(find_living(&quot;balrog&quot;));&nbsp;<BR>
&nbsp;<BR>
As&nbsp;stated,&nbsp;this&nbsp;returns&nbsp;the&nbsp;string&nbsp;reference&nbsp;to&nbsp;the&nbsp;master&nbsp;object,&nbsp;if&nbsp;you&nbsp;particularly&nbsp;need&nbsp;the&nbsp;object&nbsp;reference&nbsp;just&nbsp;get&nbsp;it&nbsp;with&nbsp;find_object()&nbsp;<BR>
given&nbsp;the&nbsp;just&nbsp;established&nbsp;object&nbsp;path&nbsp;as&nbsp;argument.&nbsp;&nbsp;<BR>
&nbsp;<BR>
A&nbsp;clone&nbsp;is&nbsp;easiest&nbsp;distinguished&nbsp;from&nbsp;the&nbsp;master&nbsp;object&nbsp;by&nbsp;comparing&nbsp;the&nbsp;object&nbsp;reference&nbsp;strings.&nbsp;The&nbsp;macro&nbsp;IS_CLONE&nbsp;does&nbsp;that&nbsp;for&nbsp;you,&nbsp;<BR>
also&nbsp;available&nbsp;in&nbsp;`/sys/macros.h'.&nbsp;The&nbsp;macro&nbsp;works&nbsp;on&nbsp;this_object()&nbsp;and&nbsp;takes&nbsp;no&nbsp;argument&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;IS_CLONE&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(IS_CLONE)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;I&nbsp;am&nbsp;a&nbsp;clone!\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Object&nbsp;references&nbsp;to&nbsp;interactive&nbsp;objects&nbsp;<BR>
&nbsp;<BR>
[find_player,&nbsp;this_interactive,&nbsp;this_player]&nbsp;&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;are&nbsp;looking&nbsp;for&nbsp;a&nbsp;particular&nbsp;player,&nbsp;you&nbsp;could&nbsp;look&nbsp;for&nbsp;him&nbsp;with&nbsp;find_living()&nbsp;and&nbsp;then&nbsp;just&nbsp;make&nbsp;sure&nbsp;it's&nbsp;an&nbsp;interactive&nbsp;object.&nbsp;<BR>
However,&nbsp;it's&nbsp;a&nbsp;lot&nbsp;quicker&nbsp;to&nbsp;use&nbsp;the&nbsp;efun&nbsp;find_player()&nbsp;that&nbsp;works&nbsp;just&nbsp;the&nbsp;same&nbsp;with&nbsp;the&nbsp;exception&nbsp;that&nbsp;there&nbsp;can&nbsp;only&nbsp;be&nbsp;one&nbsp;player&nbsp;with&nbsp;<BR>
a&nbsp;given&nbsp;name;&nbsp;if&nbsp;he's&nbsp;in&nbsp;the&nbsp;game&nbsp;you&nbsp;will&nbsp;get&nbsp;the&nbsp;object&nbsp;reference&nbsp;to&nbsp;him&nbsp;and&nbsp;no&nbsp;other.&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;*find_player(string&nbsp;name)&nbsp;<BR>
e.g.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;fat_one;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fat_one&nbsp;=&nbsp;find_player(&quot;fatty&quot;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(objectp(fat_one))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fat_one-&gt;catch_msg(&quot;Hail&nbsp;thee,&nbsp;bloated&nbsp;one!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Nope,&nbsp;no&nbsp;such&nbsp;luck.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Very&nbsp;often&nbsp;you&nbsp;want&nbsp;to&nbsp;know&nbsp;which&nbsp;player&nbsp;issued&nbsp;the&nbsp;command&nbsp;that&nbsp;led&nbsp;to&nbsp;the&nbsp;execution&nbsp;of&nbsp;a&nbsp;specific&nbsp;function.&nbsp;The&nbsp;efun&nbsp;<BR>
this_interactive()&nbsp;will&nbsp;return&nbsp;the&nbsp;object&nbsp;reference&nbsp;to&nbsp;that&nbsp;player.&nbsp;If&nbsp;the&nbsp;execution&nbsp;chain&nbsp;was&nbsp;started&nbsp;by&nbsp;an&nbsp;independent&nbsp;non-player&nbsp;<BR>
object,&nbsp;0&nbsp;is&nbsp;returned.&nbsp;&nbsp;<BR>
&nbsp;<BR>
However,&nbsp;more&nbsp;often&nbsp;you're&nbsp;not&nbsp;interested&nbsp;in&nbsp;who&nbsp;actually&nbsp;started&nbsp;the&nbsp;chain,&nbsp;but&nbsp;rather&nbsp;who&nbsp;the&nbsp;object&nbsp;is&nbsp;supposed&nbsp;to&nbsp;direct&nbsp;its&nbsp;attention&nbsp;at.&nbsp;<BR>
That&nbsp;object&nbsp;is&nbsp;returned&nbsp;by&nbsp;the&nbsp;efun&nbsp;this_player().&nbsp;In&nbsp;other&nbsp;words,&nbsp;while&nbsp;the&nbsp;object&nbsp;might&nbsp;be&nbsp;expected&nbsp;to&nbsp;turn&nbsp;its&nbsp;attentions&nbsp;(command&nbsp;lists,&nbsp;<BR>
output&nbsp;messages,&nbsp;object&nbsp;effects&nbsp;etc)&nbsp;to&nbsp;the&nbsp;object&nbsp;given&nbsp;by&nbsp;this_player(),&nbsp;it&nbsp;might&nbsp;be&nbsp;another&nbsp;player&nbsp;given&nbsp;by&nbsp;this_interactive()&nbsp;that&nbsp;<BR>
actually&nbsp;started&nbsp;the&nbsp;execution&nbsp;chain&nbsp;in&nbsp;the&nbsp;object.&nbsp;The&nbsp;value&nbsp;of&nbsp;this_interactive()&nbsp;can&nbsp;never&nbsp;be&nbsp;manipulated&nbsp;by&nbsp;objects&nbsp;in&nbsp;the&nbsp;game,&nbsp;<BR>
this_player()&nbsp;on&nbsp;the&nbsp;other&nbsp;hand&nbsp;can&nbsp;be&nbsp;set&nbsp;at&nbsp;will.&nbsp;More&nbsp;about&nbsp;that&nbsp;later.&nbsp;&nbsp;<BR>
&nbsp;<BR>
object&nbsp;this_player();&nbsp;<BR>
object&nbsp;this_interactive();&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;tp,&nbsp;ti;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;tp&nbsp;=&nbsp;this_player();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ti&nbsp;=&nbsp;this_interactive();&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(objectp(ti))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ti&nbsp;!=&nbsp;tp)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tp-&gt;catch_msg(&quot;Zapppp!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ti-&gt;catch_msg(&quot;Zapped&nbsp;him!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ti-&gt;catch_msg(&quot;Fzzzzz...\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
Destroying&nbsp;objects&nbsp;<BR>
&nbsp;<BR>
[destruct,&nbsp;remove_object]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Sooner&nbsp;or&nbsp;later&nbsp;you&nbsp;will&nbsp;want&nbsp;to&nbsp;get&nbsp;rid&nbsp;of&nbsp;an&nbsp;object.&nbsp;The&nbsp;efun&nbsp;you&nbsp;use&nbsp;is&nbsp;destruct().&nbsp;However,&nbsp;the&nbsp;gamedriver&nbsp;only&nbsp;allows&nbsp;the&nbsp;object&nbsp;that&nbsp;<BR>
issued&nbsp;the&nbsp;destruct()&nbsp;efun&nbsp;to&nbsp;actually&nbsp;be&nbsp;removed.&nbsp;This&nbsp;means&nbsp;that&nbsp;every&nbsp;object&nbsp;need&nbsp;to&nbsp;have&nbsp;a&nbsp;function&nbsp;that&nbsp;you&nbsp;can&nbsp;call&nbsp;from&nbsp;another&nbsp;<BR>
object&nbsp;in&nbsp;order&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;destroy&nbsp;it&nbsp;from&nbsp;without.&nbsp;If&nbsp;the&nbsp;object&nbsp;doesn't&nbsp;contain&nbsp;the&nbsp;destruct()&nbsp;efun,&nbsp;it&nbsp;will&nbsp;remain&nbsp;for&nbsp;the&nbsp;duration&nbsp;of&nbsp;the&nbsp;<BR>
game.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Well,&nbsp;actually&nbsp;there&nbsp;exists&nbsp;a&nbsp;backdoor&nbsp;that&nbsp;allows&nbsp;you&nbsp;to&nbsp;destroy&nbsp;any&nbsp;object,&nbsp;but&nbsp;it's&nbsp;a&nbsp;command&nbsp;you&nbsp;have&nbsp;to&nbsp;issue&nbsp;manually.&nbsp;You&nbsp;can't&nbsp;use&nbsp;it&nbsp;in&nbsp;<BR>
a&nbsp;program.&nbsp;&nbsp;<BR>
&nbsp;<BR>
However,&nbsp;the&nbsp;standard&nbsp;object&nbsp;base&nbsp;-&nbsp;which&nbsp;is&nbsp;being&nbsp;discussed&nbsp;in&nbsp;more&nbsp;detail&nbsp;later&nbsp;-&nbsp;does&nbsp;define&nbsp;a&nbsp;function&nbsp;called&nbsp;remove_object()&nbsp;that&nbsp;<BR>
you&nbsp;can&nbsp;call&nbsp;to&nbsp;destroy&nbsp;the&nbsp;object.&nbsp;Since&nbsp;all&nbsp;objects&nbsp;actually&nbsp;in&nbsp;the&nbsp;game&nbsp;MUST&nbsp;inherit&nbsp;the&nbsp;standard&nbsp;object&nbsp;you&nbsp;can&nbsp;rely&nbsp;on&nbsp;having&nbsp;that&nbsp;function&nbsp;<BR>
there.&nbsp;It's&nbsp;possible&nbsp;to&nbsp;mask&nbsp;it,&nbsp;thereby&nbsp;blocking&nbsp;that&nbsp;function.&nbsp;However,&nbsp;masking&nbsp;remove_object()&nbsp;is&nbsp;tantamount&nbsp;to&nbsp;sabotage&nbsp;so&nbsp;please&nbsp;<BR>
don't&nbsp;even&nbsp;think&nbsp;about&nbsp;it.&nbsp;The&nbsp;reason&nbsp;the&nbsp;function&nbsp;is&nbsp;maskable&nbsp;is&nbsp;so&nbsp;that&nbsp;you&nbsp;should&nbsp;be&nbsp;able&nbsp;to&nbsp;add&nbsp;last-second&nbsp;cleanup&nbsp;code,&nbsp;not&nbsp;so&nbsp;that&nbsp;you&nbsp;<BR>
should&nbsp;be&nbsp;able&nbsp;to&nbsp;render&nbsp;the&nbsp;object&nbsp;indestructable.&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;remove_object()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;remove_balrog(string&nbsp;bal_name)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;bal;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal&nbsp;=&nbsp;find_living(bal_name);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(objectp(bal))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bal-&gt;remove_object();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;use&nbsp;the&nbsp;destruct()&nbsp;efun&nbsp;directly&nbsp;or&nbsp;call&nbsp;remove_object()&nbsp;in&nbsp;the&nbsp;object&nbsp;itself,&nbsp;make&nbsp;DOUBLE&nbsp;sure&nbsp;that&nbsp;no&nbsp;code&nbsp;is&nbsp;being&nbsp;executed&nbsp;<BR>
afterwards.&nbsp;You&nbsp;see,&nbsp;execution&nbsp;isn't&nbsp;aborted&nbsp;on&nbsp;completion&nbsp;of&nbsp;the&nbsp;destruction,&nbsp;the&nbsp;object&nbsp;is&nbsp;just&nbsp;ear-marked&nbsp;as&nbsp;destructed,&nbsp;actual&nbsp;removal&nbsp;is&nbsp;<BR>
done&nbsp;when&nbsp;execution&nbsp;of&nbsp;it&nbsp;is&nbsp;finished.&nbsp;This&nbsp;means&nbsp;that&nbsp;function&nbsp;calls&nbsp;or&nbsp;commands&nbsp;issued&nbsp;after&nbsp;destruction&nbsp;might&nbsp;give&nbsp;rise&nbsp;to&nbsp;runtime&nbsp;errors&nbsp;in&nbsp;<BR>
other&nbsp;objects.&nbsp;&nbsp;<BR>
&nbsp;<BR>
void&nbsp;destruct()&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;destruct_me()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Goodbye,&nbsp;cruel&nbsp;world!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
When&nbsp;an&nbsp;object&nbsp;is&nbsp;destructed,&nbsp;ALL&nbsp;object&nbsp;pointers&nbsp;(not&nbsp;string&nbsp;references)&nbsp;in&nbsp;the&nbsp;game&nbsp;pointing&nbsp;at&nbsp;the&nbsp;destructed&nbsp;object&nbsp;are&nbsp;set&nbsp;to&nbsp;0.&nbsp;Due&nbsp;to&nbsp;this&nbsp;<BR>
fact&nbsp;it's&nbsp;usually&nbsp;sensible&nbsp;to&nbsp;make&nbsp;sure&nbsp;that&nbsp;an&nbsp;old&nbsp;object&nbsp;reference&nbsp;still&nbsp;is&nbsp;valid&nbsp;before&nbsp;doing&nbsp;anything&nbsp;with&nbsp;it.&nbsp;You&nbsp;never&nbsp;know,&nbsp;it&nbsp;just&nbsp;might&nbsp;<BR>
have&nbsp;been&nbsp;removed&nbsp;since&nbsp;you&nbsp;obtained&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
if&nbsp;an&nbsp;object&nbsp;contains&nbsp;other&nbsp;objects&nbsp;in&nbsp;its&nbsp;inventory&nbsp;when&nbsp;it&nbsp;is&nbsp;destructed,&nbsp;those&nbsp;objects&nbsp;will&nbsp;be&nbsp;destructed&nbsp;with&nbsp;it.&nbsp;The&nbsp;exception&nbsp;is&nbsp;interactive&nbsp;<BR>
objects,&nbsp;players.&nbsp;If&nbsp;you&nbsp;update&nbsp;a&nbsp;room&nbsp;you&nbsp;are&nbsp;effectively&nbsp;destructing&nbsp;it,&nbsp;if&nbsp;it&nbsp;has&nbsp;players&nbsp;in&nbsp;it&nbsp;they&nbsp;will&nbsp;be&nbsp;moved&nbsp;to&nbsp;their&nbsp;respective&nbsp;starting&nbsp;<BR>
locations.&nbsp;If&nbsp;the&nbsp;room&nbsp;is&nbsp;the&nbsp;start&nbsp;location&nbsp;or&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;problem&nbsp;with&nbsp;moving&nbsp;them&nbsp;(buggy&nbsp;start&nbsp;location&nbsp;or&nbsp;impossible&nbsp;to&nbsp;move&nbsp;them)&nbsp;those&nbsp;<BR>
players&nbsp;will&nbsp;be&nbsp;destructed&nbsp;as&nbsp;well.&nbsp;In&nbsp;any&nbsp;circumstances&nbsp;you&nbsp;should&nbsp;always&nbsp;be&nbsp;able&nbsp;to&nbsp;rely&nbsp;on&nbsp;an&nbsp;object&nbsp;being&nbsp;destructed&nbsp;when&nbsp;ordered&nbsp;to.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;one&nbsp;time&nbsp;there's&nbsp;problems&nbsp;with&nbsp;this&nbsp;is&nbsp;when&nbsp;the&nbsp;function&nbsp;remove_object()&nbsp;has&nbsp;been&nbsp;overridden&nbsp;and&nbsp;has&nbsp;a&nbsp;bug&nbsp;in&nbsp;it.&nbsp;That&nbsp;might&nbsp;just&nbsp;<BR>
abort&nbsp;the&nbsp;process&nbsp;and&nbsp;cause&nbsp;problems.&nbsp;&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;klab.ishii.utsu]&nbsp;<BR>
<A HREF="00000013.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000015.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>