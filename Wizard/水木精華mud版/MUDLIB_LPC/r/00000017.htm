<HTML>
<HEAD>
<TITLE>BBS水木清華站︰精華區</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
<A Name="top"></a>
發信人:&nbsp;jameson&nbsp;(阿其),&nbsp;信區:&nbsp;Mud_Builder&nbsp;<BR>
標&nbsp;&nbsp;題:&nbsp;LPC&nbsp;Manual&nbsp;-&nbsp;Essential&nbsp;LPC&nbsp;and&nbsp;MUDLIB&nbsp;(8)&nbsp;<BR>
發信站:&nbsp;BBS&nbsp;水木清華站&nbsp;(Fri&nbsp;May&nbsp;23&nbsp;22:57:03&nbsp;1997)&nbsp;<BR>
&nbsp;<BR>
Bit&nbsp;functions&nbsp;<BR>
&nbsp;<BR>
[clear_bit,&nbsp;set_bit,&nbsp;test_bit]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Sometimes&nbsp;it's&nbsp;desireable&nbsp;to&nbsp;store&nbsp;lots&nbsp;of&nbsp;simple&nbsp;`on/off'-type&nbsp;information.&nbsp;The&nbsp;quick&nbsp;and&nbsp;dirty&nbsp;approach&nbsp;is&nbsp;then&nbsp;to&nbsp;allocate&nbsp;one&nbsp;integer&nbsp;for&nbsp;<BR>
each&nbsp;of&nbsp;this&nbsp;information&nbsp;bearers&nbsp;and&nbsp;use&nbsp;them&nbsp;to&nbsp;hold&nbsp;either&nbsp;a&nbsp;one&nbsp;or&nbsp;a&nbsp;zero&nbsp;to&nbsp;indicate&nbsp;the&nbsp;state.&nbsp;This&nbsp;makes&nbsp;for&nbsp;easy&nbsp;access&nbsp;and&nbsp;easy&nbsp;<BR>
understanding,&nbsp;but&nbsp;it's&nbsp;a&nbsp;pain&nbsp;when&nbsp;you&nbsp;want&nbsp;to&nbsp;store&nbsp;the&nbsp;info&nbsp;and&nbsp;it&nbsp;takes&nbsp;a&nbsp;lot&nbsp;of&nbsp;memory.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Instead&nbsp;you&nbsp;can&nbsp;use&nbsp;strings&nbsp;where&nbsp;every&nbsp;bit&nbsp;in&nbsp;a&nbsp;character&nbsp;(8&nbsp;per&nbsp;char)&nbsp;can&nbsp;hold&nbsp;an&nbsp;information&nbsp;state&nbsp;of&nbsp;the&nbsp;on/off&nbsp;kind.&nbsp;The&nbsp;max&nbsp;number&nbsp;of&nbsp;<BR>
bits&nbsp;right&nbsp;now&nbsp;in&nbsp;a&nbsp;string&nbsp;is&nbsp;something&nbsp;like&nbsp;1200&nbsp;=&nbsp;a&nbsp;string&nbsp;length&nbsp;of&nbsp;150&nbsp;characters.&nbsp;However,&nbsp;I&nbsp;doubt&nbsp;you'll&nbsp;ever&nbsp;need&nbsp;to&nbsp;store&nbsp;that&nbsp;many&nbsp;<BR>
states.&nbsp;&nbsp;<BR>
&nbsp;<BR>
You&nbsp;set&nbsp;the&nbsp;bits&nbsp;with&nbsp;the&nbsp;efun&nbsp;set_bit()&nbsp;which&nbsp;takes&nbsp;two&nbsp;arguments,&nbsp;the&nbsp;first&nbsp;is&nbsp;the&nbsp;string&nbsp;that&nbsp;actually&nbsp;contains&nbsp;the&nbsp;bits&nbsp;and&nbsp;the&nbsp;second&nbsp;is&nbsp;<BR>
an&nbsp;integer&nbsp;specifying&nbsp;exactly&nbsp;what&nbsp;bit&nbsp;you&nbsp;want&nbsp;to&nbsp;set.&nbsp;Remember&nbsp;that&nbsp;the&nbsp;first&nbsp;bit&nbsp;is&nbsp;bit&nbsp;number&nbsp;0.&nbsp;To&nbsp;clear&nbsp;a&nbsp;bit&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;<BR>
clear_bit()&nbsp;that&nbsp;works&nbsp;analogous&nbsp;to&nbsp;set_bit().&nbsp;When&nbsp;you&nbsp;need&nbsp;to&nbsp;test&nbsp;a&nbsp;bit&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;test_bit()&nbsp;which&nbsp;simply&nbsp;takes&nbsp;the&nbsp;same&nbsp;<BR>
arguments&nbsp;as&nbsp;the&nbsp;other&nbsp;efun&nbsp;but&nbsp;returns&nbsp;1&nbsp;or&nbsp;0&nbsp;depending&nbsp;on&nbsp;whether&nbsp;the&nbsp;tested&nbsp;bit&nbsp;was&nbsp;set&nbsp;or&nbsp;not.&nbsp;&nbsp;<BR>
&nbsp;<BR>
You&nbsp;don't&nbsp;have&nbsp;to&nbsp;allocate&nbsp;a&nbsp;string&nbsp;in&nbsp;advance&nbsp;when&nbsp;you&nbsp;use&nbsp;set_bit().&nbsp;Both&nbsp;set_bit()&nbsp;and&nbsp;clear_bit()&nbsp;return&nbsp;the&nbsp;new&nbsp;modified&nbsp;<BR>
string,&nbsp;and&nbsp;in&nbsp;case&nbsp;it's&nbsp;not&nbsp;wide&nbsp;enough&nbsp;it&nbsp;will&nbsp;be&nbsp;extended&nbsp;by&nbsp;set_bit().&nbsp;However,&nbsp;clear_bit()&nbsp;will&nbsp;not&nbsp;shorten&nbsp;it&nbsp;automatically.&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;set_bit(string&nbsp;bitstr,&nbsp;int&nbsp;the_bit)&nbsp;<BR>
string&nbsp;clear_bit(string&nbsp;bitstr,&nbsp;int&nbsp;the_bit)&nbsp;<BR>
int&nbsp;test_bit(string&nbsp;bitstr,&nbsp;int&nbsp;the_bit)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Set&nbsp;bit&nbsp;23&nbsp;in&nbsp;a&nbsp;new&nbsp;bitfield.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;bf;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;bf&nbsp;=&nbsp;&quot;&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;bf&nbsp;=&nbsp;set_bit(bf,&nbsp;22);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Clear&nbsp;bit&nbsp;93&nbsp;in&nbsp;the&nbsp;same&nbsp;bitfield&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;bf&nbsp;=&nbsp;clear_bit(bf,&nbsp;92);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Test&nbsp;bit&nbsp;3&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(test_bit(bf,&nbsp;2))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Set!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Clear!\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Time&nbsp;functions&nbsp;<BR>
&nbsp;<BR>
[time,&nbsp;ctime,&nbsp;file_time,&nbsp;last_reference_time,&nbsp;object_time,&nbsp;convtime]&nbsp;&nbsp;<BR>
&nbsp;<BR>
All&nbsp;time&nbsp;measurements&nbsp;in&nbsp;UNIX,&nbsp;and&nbsp;hence&nbsp;in&nbsp;the&nbsp;mud,&nbsp;are&nbsp;measured&nbsp;starting&nbsp;at&nbsp;Jan&nbsp;1,&nbsp;1970&nbsp;for&nbsp;some&nbsp;obscure&nbsp;reason.&nbsp;Perhaps&nbsp;the&nbsp;creators&nbsp;of&nbsp;<BR>
this&nbsp;system&nbsp;figured&nbsp;that,&nbsp;from&nbsp;a&nbsp;computer&nbsp;point&nbsp;of&nbsp;view,&nbsp;there's&nbsp;no&nbsp;reason&nbsp;ever&nbsp;to&nbsp;need&nbsp;to&nbsp;store&nbsp;a&nbsp;timestamp&nbsp;of&nbsp;an&nbsp;earlier&nbsp;date.&nbsp;In&nbsp;any&nbsp;case&nbsp;<BR>
that's&nbsp;how&nbsp;it&nbsp;is.&nbsp;Timestamps&nbsp;are&nbsp;integers&nbsp;and&nbsp;measure&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;from&nbsp;that&nbsp;previously&nbsp;mentioned&nbsp;date.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;simple&nbsp;efun&nbsp;time()&nbsp;will&nbsp;return&nbsp;the&nbsp;current&nbsp;time.&nbsp;You&nbsp;can&nbsp;either&nbsp;use&nbsp;it&nbsp;as&nbsp;it&nbsp;is&nbsp;or&nbsp;convert&nbsp;it&nbsp;to&nbsp;a&nbsp;printable&nbsp;string&nbsp;with&nbsp;the&nbsp;ctime()&nbsp;efun.&nbsp;To&nbsp;<BR>
find&nbsp;the&nbsp;creation&nbsp;time&nbsp;of&nbsp;a&nbsp;file,&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;file_time(),&nbsp;of&nbsp;an&nbsp;object&nbsp;the&nbsp;efun&nbsp;object_time().&nbsp;&nbsp;<BR>
&nbsp;<BR>
Sometimes&nbsp;it's&nbsp;desirable&nbsp;to&nbsp;know&nbsp;when&nbsp;the&nbsp;object&nbsp;last&nbsp;was&nbsp;referenced,&nbsp;i.e.&nbsp;when&nbsp;it&nbsp;last&nbsp;had&nbsp;a&nbsp;function&nbsp;called&nbsp;in&nbsp;it.&nbsp;If&nbsp;you&nbsp;then,&nbsp;as&nbsp;the&nbsp;first&nbsp;<BR>
instruction&nbsp;in&nbsp;the&nbsp;function&nbsp;call&nbsp;last_reference_time()&nbsp;you&nbsp;will&nbsp;get&nbsp;that&nbsp;time.&nbsp;However,&nbsp;remember&nbsp;that&nbsp;it&nbsp;naturally&nbsp;is&nbsp;set&nbsp;to&nbsp;the&nbsp;current&nbsp;<BR>
time&nbsp;as&nbsp;soon&nbsp;as&nbsp;that&nbsp;is&nbsp;done.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;time()&nbsp;<BR>
string&nbsp;ctime(int&nbsp;tm)&nbsp;<BR>
int&nbsp;file_time(string&nbsp;obref)&nbsp;<BR>
int&nbsp;object_time(object&nbsp;ob)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;This&nbsp;object&nbsp;was&nbsp;last&nbsp;referenced&nbsp;at&nbsp;&quot;&nbsp;+&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctime(last_reference_time())&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;The&nbsp;time&nbsp;right&nbsp;now&nbsp;is:&nbsp;&quot;&nbsp;+&nbsp;ctime(time())&nbsp;+&nbsp;&quot;.\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;This&nbsp;object&nbsp;is&nbsp;&quot;&nbsp;+&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(time()&nbsp;-&nbsp;object_time(this_object()))&nbsp;+&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;seconds&nbsp;old.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
There&nbsp;exists&nbsp;a&nbsp;convenient&nbsp;lfun&nbsp;convtime&nbsp;in&nbsp;the&nbsp;module&nbsp;/lib/time&nbsp;that&nbsp;will&nbsp;convert&nbsp;the&nbsp;timestamp&nbsp;to&nbsp;days,&nbsp;hours,&nbsp;minutes&nbsp;and&nbsp;seconds,&nbsp;<BR>
excluding&nbsp;those&nbsp;entries&nbsp;which&nbsp;doesn't&nbsp;contain&nbsp;anything.&nbsp;Nice&nbsp;for&nbsp;more&nbsp;condensed&nbsp;listings.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Array/string&nbsp;conversion&nbsp;<BR>
&nbsp;<BR>
[explode,&nbsp;implode]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Very&nbsp;often&nbsp;you&nbsp;come&nbsp;to&nbsp;situations&nbsp;where&nbsp;you&nbsp;either&nbsp;have&nbsp;a&nbsp;string&nbsp;that&nbsp;you&nbsp;would&nbsp;like&nbsp;to&nbsp;break&nbsp;up&nbsp;into&nbsp;smaller&nbsp;strings&nbsp;based&nbsp;on&nbsp;a&nbsp;regular&nbsp;<BR>
substring,&nbsp;or&nbsp;conversly&nbsp;where&nbsp;you&nbsp;have&nbsp;a&nbsp;number&nbsp;of&nbsp;strings&nbsp;you&nbsp;would&nbsp;like&nbsp;to&nbsp;paste&nbsp;together&nbsp;to&nbsp;make&nbsp;up&nbsp;one&nbsp;single&nbsp;string.&nbsp;For&nbsp;this&nbsp;purpose&nbsp;<BR>
you&nbsp;can&nbsp;use&nbsp;the&nbsp;efuns&nbsp;explode()&nbsp;and&nbsp;implode().&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;efun&nbsp;explode()&nbsp;takes&nbsp;two&nbsp;two&nbsp;strings&nbsp;as&nbsp;arguments,&nbsp;the&nbsp;first&nbsp;is&nbsp;the&nbsp;string&nbsp;you&nbsp;want&nbsp;to&nbsp;break&nbsp;up,&nbsp;and&nbsp;the&nbsp;second&nbsp;is&nbsp;the&nbsp;pattern&nbsp;that&nbsp;<BR>
explode()&nbsp;looks&nbsp;for&nbsp;as&nbsp;a&nbsp;marker&nbsp;of&nbsp;where&nbsp;to&nbsp;break&nbsp;the&nbsp;string.&nbsp;It&nbsp;returns&nbsp;an&nbsp;array&nbsp;of&nbsp;strings&nbsp;holding&nbsp;the&nbsp;result.&nbsp;The&nbsp;efun&nbsp;implode()&nbsp;takes&nbsp;an&nbsp;<BR>
array&nbsp;and&nbsp;a&nbsp;string&nbsp;as&nbsp;arguemnts,&nbsp;returning&nbsp;one&nbsp;string&nbsp;made&nbsp;up&nbsp;from&nbsp;the&nbsp;contents&nbsp;of&nbsp;the&nbsp;array&nbsp;with&nbsp;the&nbsp;string&nbsp;argument&nbsp;pasted&nbsp;in&nbsp;between&nbsp;all&nbsp;<BR>
elements.&nbsp;&nbsp;<BR>
&nbsp;<BR>
string&nbsp;*explode(string&nbsp;str,&nbsp;string&nbsp;expstr)&nbsp;<BR>
string&nbsp;implode(string&nbsp;*strlist,&nbsp;string&nbsp;impstr)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;fruit&nbsp;=&nbsp;&quot;apple&nbsp;and&nbsp;banana&nbsp;and&nbsp;pear&nbsp;&quot;&nbsp;+&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;and&nbsp;orange&nbsp;and&nbsp;fatty&nbsp;eating&nbsp;it&nbsp;all&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*fruit_list;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;fruit_list&nbsp;=&nbsp;explode(fruit,&nbsp;&quot;&nbsp;and&nbsp;&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dump_array(fruit_list);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;result&nbsp;is:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Array)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0]&nbsp;=&nbsp;(string)&nbsp;&quot;apple&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1]&nbsp;=&nbsp;(string)&nbsp;&quot;banana&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2]&nbsp;=&nbsp;(string)&nbsp;&quot;pear&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3]&nbsp;=&nbsp;(string)&nbsp;&quot;orange&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4]&nbsp;=&nbsp;(string)&nbsp;&quot;fatty&nbsp;eating&nbsp;it&nbsp;all&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fruit&nbsp;=&nbsp;implode(fruit_list,&nbsp;&quot;,&nbsp;&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(fruit&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;The&nbsp;result&nbsp;is:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;apple,&nbsp;banana,&nbsp;pear,&nbsp;orange,&nbsp;fatty&nbsp;eating&nbsp;it&nbsp;all&nbsp;<BR>
&nbsp;<BR>
Array&nbsp;functions&nbsp;<BR>
&nbsp;<BR>
[allocate,&nbsp;member_array,&nbsp;sizeof,&nbsp;pointerp]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Arrays&nbsp;are&nbsp;actually&nbsp;not&nbsp;arrays,&nbsp;but&nbsp;rather&nbsp;ordered&nbsp;lists&nbsp;of&nbsp;LPC&nbsp;data&nbsp;types.&nbsp;They&nbsp;can&nbsp;be&nbsp;made&nbsp;to&nbsp;contain&nbsp;any&nbsp;type&nbsp;of&nbsp;data,&nbsp;including&nbsp;other&nbsp;<BR>
arrays.&nbsp;Keep&nbsp;in&nbsp;mind&nbsp;that&nbsp;arrays&nbsp;unlike&nbsp;other&nbsp;data&nbsp;types&nbsp;are&nbsp;copied&nbsp;by&nbsp;reference&nbsp;rather&nbsp;than&nbsp;by&nbsp;value.&nbsp;This&nbsp;means&nbsp;that&nbsp;when&nbsp;you&nbsp;assign&nbsp;an&nbsp;<BR>
array&nbsp;to&nbsp;variable&nbsp;you&nbsp;do&nbsp;not&nbsp;copy&nbsp;the&nbsp;array,&nbsp;you&nbsp;merely&nbsp;store&nbsp;a&nbsp;reference,&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;array,&nbsp;in&nbsp;the&nbsp;variable.&nbsp;&nbsp;<BR>
&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*arr1,&nbsp;*arr2;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;arr1&nbsp;=&nbsp;({&nbsp;1,&nbsp;2,&nbsp;3&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;arr2&nbsp;=&nbsp;arr1;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;arr2[1]&nbsp;=&nbsp;5;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dump_array(arr1);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;output&nbsp;is:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(Array)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;[0]&nbsp;=&nbsp;(int)&nbsp;1&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;[1]&nbsp;=&nbsp;(int)&nbsp;5&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;[2]&nbsp;=&nbsp;(int)&nbsp;3&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
So,&nbsp;as&nbsp;you&nbsp;can&nbsp;see,&nbsp;changing&nbsp;the&nbsp;array&nbsp;`arr2'&nbsp;effectively&nbsp;changes&nbsp;the&nbsp;contents&nbsp;of&nbsp;`arr1'&nbsp;as&nbsp;well.&nbsp;You&nbsp;need&nbsp;to&nbsp;make&nbsp;a&nbsp;copy&nbsp;of&nbsp;`arr1'&nbsp;first,&nbsp;<BR>
to&nbsp;make&nbsp;it&nbsp;unique.&nbsp;For&nbsp;example&nbsp;by&nbsp;simply&nbsp;adding&nbsp;an&nbsp;empty&nbsp;array&nbsp;`({})'&nbsp;to&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
As&nbsp;you&nbsp;have&nbsp;learnt&nbsp;arrays&nbsp;can&nbsp;be&nbsp;automatically&nbsp;allocated&nbsp;simply&nbsp;by&nbsp;writing&nbsp;them&nbsp;in&nbsp;the&nbsp;code,&nbsp;by&nbsp;adding&nbsp;elements&nbsp;to&nbsp;them&nbsp;or&nbsp;adding&nbsp;arrays&nbsp;to&nbsp;<BR>
each&nbsp;other.&nbsp;However,&nbsp;if&nbsp;you&nbsp;need&nbsp;to&nbsp;allocate&nbsp;an&nbsp;array&nbsp;immediately&nbsp;to&nbsp;a&nbsp;specified&nbsp;size,&nbsp;you&nbsp;can&nbsp;use&nbsp;the&nbsp;allocate()&nbsp;efun.&nbsp;It&nbsp;takes&nbsp;as&nbsp;an&nbsp;<BR>
argument&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;array&nbsp;you&nbsp;want&nbsp;and&nbsp;initializes&nbsp;all&nbsp;elements,&nbsp;regardless&nbsp;of&nbsp;array&nbsp;type,&nbsp;to&nbsp;0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
mixed&nbsp;*allocate(int&nbsp;num)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*str_arr;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;str_arr&nbsp;=&nbsp;allocate(3);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;str_arr[1]&nbsp;=&nbsp;&quot;Fatty&nbsp;is&nbsp;a&nbsp;flabby&nbsp;blimp&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dump_array(str_arr);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;result&nbsp;is:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Array)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0]&nbsp;=&nbsp;(int)&nbsp;0&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1]&nbsp;=&nbsp;(string)&nbsp;&quot;Fatty&nbsp;is&nbsp;a&nbsp;flabby&nbsp;blimp&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2]&nbsp;=&nbsp;(int)&nbsp;0&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
If&nbsp;you&nbsp;need&nbsp;to&nbsp;find&nbsp;out&nbsp;if&nbsp;a&nbsp;particular&nbsp;item&nbsp;is&nbsp;a&nbsp;member&nbsp;of&nbsp;an&nbsp;array&nbsp;or&nbsp;the&nbsp;index&nbsp;of&nbsp;that&nbsp;item,&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;member_array().&nbsp;It&nbsp;takes&nbsp;as&nbsp;<BR>
arguments&nbsp;an&nbsp;array&nbsp;and&nbsp;an&nbsp;item&nbsp;of&nbsp;any&nbsp;type,&nbsp;returning&nbsp;the&nbsp;index&nbsp;if&nbsp;it&nbsp;is&nbsp;part&nbsp;of&nbsp;the&nbsp;array&nbsp;and&nbsp;-1&nbsp;if&nbsp;it&nbsp;isn't.&nbsp;If&nbsp;several&nbsp;instances&nbsp;of&nbsp;the&nbsp;searched&nbsp;<BR>
for&nbsp;item&nbsp;exists&nbsp;in&nbsp;the&nbsp;array,&nbsp;the&nbsp;first&nbsp;index&nbsp;is&nbsp;returned.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;member_array(mixed&nbsp;arr,&nbsp;mixed&nbsp;elem)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*arr&nbsp;=&nbsp;({&nbsp;1,&nbsp;55443,&nbsp;123,&nbsp;-3,&nbsp;5,&nbsp;828,&nbsp;120398,&nbsp;5,&nbsp;12&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;index;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;all&nbsp;instances&nbsp;of&nbsp;the&nbsp;value&nbsp;'5'&nbsp;with&nbsp;'33'&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((index&nbsp;=&nbsp;member_array(arr,&nbsp;5))&nbsp;&gt;=&nbsp;0)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr[index]&nbsp;=&nbsp;33;&nbsp;<BR>
&nbsp;<BR>
A&nbsp;very&nbsp;important&nbsp;efun&nbsp;to&nbsp;use&nbsp;with&nbsp;arrays&nbsp;is&nbsp;sizeof().&nbsp;It&nbsp;simply&nbsp;returns&nbsp;the&nbsp;size,&nbsp;the&nbsp;number&nbsp;of&nbsp;elements,&nbsp;in&nbsp;an&nbsp;array.&nbsp;It's&nbsp;very&nbsp;common&nbsp;that&nbsp;<BR>
you&nbsp;need&nbsp;to&nbsp;loop&nbsp;through&nbsp;all&nbsp;elements&nbsp;of&nbsp;an&nbsp;array&nbsp;to&nbsp;do&nbsp;something,&nbsp;or&nbsp;perhaps&nbsp;just&nbsp;find&nbsp;the&nbsp;last&nbsp;element,&nbsp;and&nbsp;then&nbsp;you&nbsp;need&nbsp;to&nbsp;know&nbsp;the&nbsp;size.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;sizeof(mixed&nbsp;arr)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*arr&nbsp;=&nbsp;({&nbsp;&quot;Fatty&quot;,&nbsp;&quot;the&quot;,&nbsp;&quot;blurp&quot;&nbsp;});&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(implode(arr,&nbsp;&quot;&nbsp;&quot;)&nbsp;+&nbsp;&quot;&nbsp;is&nbsp;wrong.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Replace&nbsp;the&nbsp;_last_&nbsp;argument,&nbsp;but&nbsp;remember&nbsp;that&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;in&nbsp;LPC&nbsp;we&nbsp;start&nbsp;counting&nbsp;at&nbsp;0&nbsp;so&nbsp;subtract&nbsp;1.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;arr[sizeof(arr)&nbsp;-&nbsp;1]&nbsp;=&nbsp;&quot;blimp&quot;;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(implode(arr,&nbsp;&quot;&nbsp;&quot;)&nbsp;+&nbsp;&quot;&nbsp;is&nbsp;correct.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
The&nbsp;efun&nbsp;pointerp()&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;determine&nbsp;if&nbsp;a&nbsp;variable&nbsp;contains&nbsp;an&nbsp;array&nbsp;(of&nbsp;any&nbsp;type)&nbsp;or&nbsp;not.&nbsp;This&nbsp;is&nbsp;useful&nbsp;when&nbsp;you&nbsp;have&nbsp;a&nbsp;function&nbsp;<BR>
that&nbsp;might&nbsp;return&nbsp;0&nbsp;(NULL&nbsp;value)&nbsp;if&nbsp;something&nbsp;goes&nbsp;wrong.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;pointerp(mixed&nbsp;arr)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*arr;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pointerp((arr&nbsp;=&nbsp;find_player(&quot;fatty&quot;)-&gt;get_blimps())))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Fatty's&nbsp;blimps&nbsp;right&nbsp;now&nbsp;are:&nbsp;&quot;&nbsp;+&nbsp;implode(arr,&nbsp;&quot;,&nbsp;&quot;)&nbsp;+&nbsp;&quot;.\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Fatty&nbsp;doesn't&nbsp;have&nbsp;any&nbsp;blimps,&nbsp;stupid.&nbsp;He&nbsp;is&nbsp;one.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Mapping&nbsp;functions&nbsp;<BR>
&nbsp;<BR>
[mkmapping,&nbsp;mappingp,&nbsp;m_sizeof,&nbsp;m_indices,&nbsp;m_values,&nbsp;m_restore_object,&nbsp;m_save_object]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Mappings,&nbsp;as&nbsp;stated&nbsp;earlier,&nbsp;are&nbsp;lists&nbsp;of&nbsp;associated&nbsp;indices&nbsp;and&nbsp;values.&nbsp;A&nbsp;value&nbsp;is&nbsp;associated&nbsp;with&nbsp;another,&nbsp;so&nbsp;that&nbsp;by&nbsp;indexing&nbsp;with&nbsp;the&nbsp;first&nbsp;<BR>
value&nbsp;you&nbsp;retrieve&nbsp;the&nbsp;second.&nbsp;Internally&nbsp;they&nbsp;are&nbsp;set&nbsp;up&nbsp;as&nbsp;hashed&nbsp;lists,&nbsp;which&nbsp;makes&nbsp;for&nbsp;very&nbsp;quick&nbsp;lookups.&nbsp;However,&nbsp;they&nbsp;are&nbsp;memory&nbsp;hogs,&nbsp;<BR>
using&nbsp;up&nbsp;lots&nbsp;of&nbsp;memory&nbsp;as&nbsp;compared&nbsp;with&nbsp;arrays.&nbsp;&nbsp;<BR>
&nbsp;<BR>
How&nbsp;to&nbsp;allocate&nbsp;mappings&nbsp;then?&nbsp;Well,&nbsp;that's&nbsp;very&nbsp;easy.&nbsp;Just&nbsp;declare&nbsp;it&nbsp;and&nbsp;assign&nbsp;a&nbsp;value&nbsp;to&nbsp;an&nbsp;index&nbsp;value.&nbsp;If&nbsp;it&nbsp;exists,&nbsp;the&nbsp;old&nbsp;value&nbsp;is&nbsp;removed&nbsp;<BR>
and&nbsp;the&nbsp;new&nbsp;put&nbsp;in&nbsp;its&nbsp;place.&nbsp;If&nbsp;it&nbsp;doesn't&nbsp;exist&nbsp;it&nbsp;is&nbsp;allocated&nbsp;and&nbsp;stored&nbsp;in&nbsp;the&nbsp;mapping&nbsp;automatically.&nbsp;You&nbsp;can&nbsp;also&nbsp;use&nbsp;two&nbsp;arrays,&nbsp;one&nbsp;with&nbsp;<BR>
the&nbsp;indices&nbsp;and&nbsp;one&nbsp;with&nbsp;the&nbsp;values&nbsp;and&nbsp;combine&nbsp;those&nbsp;into&nbsp;a&nbsp;mapping&nbsp;with&nbsp;the&nbsp;efun&nbsp;mkmapping().&nbsp;Just&nbsp;remember&nbsp;that&nbsp;the&nbsp;two&nbsp;arrays&nbsp;must&nbsp;<BR>
be&nbsp;of&nbsp;the&nbsp;same&nbsp;size.&nbsp;&nbsp;<BR>
&nbsp;<BR>
mapping&nbsp;mkmapping(mixed&nbsp;indarr,&nbsp;mixed&nbsp;valarr)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;*ind_arr,&nbsp;*val_arr;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;mp;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;fatty&quot;]&nbsp;=&nbsp;&quot;blimp&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;mrpr&quot;]&nbsp;=&nbsp;&quot;unique&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;olorin&quot;]&nbsp;=&nbsp;&quot;bloodshot&quot;;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Is&nbsp;the&nbsp;same&nbsp;as...&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;ind_arr&nbsp;=&nbsp;({&nbsp;&quot;fatty&quot;,&nbsp;&quot;mrpr&quot;,&nbsp;&quot;olorin&quot;&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;val_arr&nbsp;=&nbsp;({&nbsp;&quot;blimp&quot;,&nbsp;&quot;unique&quot;,&nbsp;&quot;bloodshot&quot;&nbsp;});&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp&nbsp;=&nbsp;mkmapping(ind_arr,&nbsp;val_arr);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;You&nbsp;can&nbsp;give&nbsp;the&nbsp;arrays&nbsp;directly,&nbsp;instead&nbsp;of&nbsp;through&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;variables,&nbsp;of&nbsp;course.&nbsp;<BR>
&nbsp;<BR>
As&nbsp;with&nbsp;arrays,&nbsp;there's&nbsp;a&nbsp;function&nbsp;available&nbsp;to&nbsp;determine&nbsp;if&nbsp;a&nbsp;given&nbsp;variable&nbsp;contains&nbsp;a&nbsp;mapping&nbsp;or&nbsp;not,&nbsp;mappingp(),&nbsp;that&nbsp;works&nbsp;in&nbsp;the&nbsp;exact&nbsp;<BR>
same&nbsp;way.&nbsp;Use&nbsp;it&nbsp;in&nbsp;the&nbsp;same&nbsp;circumstances,&nbsp;i.e.&nbsp;typically&nbsp;when&nbsp;a&nbsp;function&nbsp;might&nbsp;or&nbsp;might&nbsp;not&nbsp;return&nbsp;a&nbsp;mapping&nbsp;and&nbsp;you&nbsp;need&nbsp;to&nbsp;know&nbsp;for&nbsp;<BR>
certain&nbsp;that&nbsp;it&nbsp;contains&nbsp;a&nbsp;valid&nbsp;value&nbsp;before&nbsp;you&nbsp;try&nbsp;to&nbsp;index&nbsp;it.&nbsp;&nbsp;<BR>
&nbsp;<BR>
To&nbsp;find&nbsp;the&nbsp;size&nbsp;of&nbsp;mapping&nbsp;you&nbsp;have&nbsp;to&nbsp;use&nbsp;the&nbsp;special&nbsp;efun&nbsp;m_sizeof().&nbsp;However,&nbsp;it&nbsp;works&nbsp;exactly&nbsp;like&nbsp;the&nbsp;corresponding&nbsp;array&nbsp;function,&nbsp;<BR>
returning&nbsp;the&nbsp;amount&nbsp;of&nbsp;elements&nbsp;in&nbsp;the&nbsp;mapping.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Removing&nbsp;elements&nbsp;from&nbsp;a&nbsp;mapping&nbsp;is&nbsp;slightly&nbsp;more&nbsp;complicated&nbsp;than&nbsp;with&nbsp;arrays&nbsp;however,&nbsp;you&nbsp;have&nbsp;to&nbsp;use&nbsp;the&nbsp;special&nbsp;function&nbsp;m_delete()&nbsp;<BR>
to&nbsp;do&nbsp;that.&nbsp;m_delete()&nbsp;doesn't&nbsp;exactly&nbsp;remove&nbsp;an&nbsp;element,&nbsp;what&nbsp;it&nbsp;does&nbsp;is&nbsp;that&nbsp;it&nbsp;creates&nbsp;a&nbsp;new&nbsp;mapping&nbsp;that&nbsp;is&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;indicated&nbsp;<BR>
mapping,&nbsp;apart&nbsp;from&nbsp;a&nbsp;particular&nbsp;value&nbsp;pair.&nbsp;As&nbsp;you&nbsp;can&nbsp;see,&nbsp;it&nbsp;takes&nbsp;the&nbsp;mapping&nbsp;to&nbsp;delete&nbsp;from&nbsp;and&nbsp;the&nbsp;index&nbsp;to&nbsp;the&nbsp;value&nbsp;pair&nbsp;you&nbsp;want&nbsp;<BR>
removed&nbsp;as&nbsp;arguments:&nbsp;&nbsp;<BR>
&nbsp;<BR>
mapping&nbsp;m_delete(mapping&nbsp;delmap,&nbsp;mixed&nbsp;elem)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;mp,&nbsp;mdel;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;fatty&quot;]&nbsp;=&nbsp;&quot;blimp&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;mrpr&quot;]&nbsp;=&nbsp;&quot;unique&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mp[&quot;olorin&quot;]&nbsp;=&nbsp;&quot;bloodshot&quot;;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mdel&nbsp;=&nbsp;m_delete(mp,&nbsp;&quot;olorin&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dump_array(mdel);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Output:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;(Mapping)&nbsp;([&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&quot;mrpr&quot;:&quot;unique&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&quot;fatty&quot;:&quot;blimp&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;])&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
Well...&nbsp;how&nbsp;to&nbsp;access&nbsp;all&nbsp;elements&nbsp;of&nbsp;a&nbsp;mapping&nbsp;then?&nbsp;Particularly&nbsp;one&nbsp;would&nbsp;want&nbsp;some&nbsp;kind&nbsp;of&nbsp;reverse&nbsp;function&nbsp;to&nbsp;mkmapping()&nbsp;earlier.&nbsp;<BR>
Actually,&nbsp;there's&nbsp;two:&nbsp;m_indices()&nbsp;and&nbsp;m_values()&nbsp;which&nbsp;returns&nbsp;an&nbsp;array&nbsp;containing&nbsp;the&nbsp;index&nbsp;and&nbsp;value&nbsp;part&nbsp;of&nbsp;the&nbsp;given&nbsp;mapping&nbsp;<BR>
respectively.&nbsp;Due&nbsp;to&nbsp;a&nbsp;linguistic&nbsp;confusion,&nbsp;the&nbsp;efun&nbsp;m_indices()&nbsp;has&nbsp;a&nbsp;double&nbsp;called&nbsp;m_indexes().&nbsp;They&nbsp;both&nbsp;do&nbsp;the&nbsp;same&nbsp;thing&nbsp;however&nbsp;<BR>
(actually&nbsp;just&nbsp;two&nbsp;names&nbsp;for&nbsp;the&nbsp;same&nbsp;function)&nbsp;so&nbsp;you&nbsp;can&nbsp;use&nbsp;either,&nbsp;as&nbsp;your&nbsp;linguistic&nbsp;preferences&nbsp;dictate.&nbsp;:)&nbsp;&nbsp;<BR>
&nbsp;<BR>
However,&nbsp;now&nbsp;we&nbsp;come&nbsp;to&nbsp;a&nbsp;sensitive&nbsp;subject&nbsp;-&nbsp;order&nbsp;in&nbsp;mappings.&nbsp;As&nbsp;explained&nbsp;earlier&nbsp;a&nbsp;mapping&nbsp;has&nbsp;no&nbsp;defined&nbsp;internal&nbsp;order.&nbsp;Well...&nbsp;it&nbsp;has,&nbsp;<BR>
but&nbsp;no&nbsp;order&nbsp;that&nbsp;you&nbsp;need&nbsp;or&nbsp;should&nbsp;worry&nbsp;about.&nbsp;This&nbsp;order&nbsp;also&nbsp;changes&nbsp;when&nbsp;you&nbsp;remove&nbsp;or&nbsp;add&nbsp;value&nbsp;pairs&nbsp;to&nbsp;a&nbsp;mapping.&nbsp;All&nbsp;in&nbsp;all&nbsp;this&nbsp;<BR>
means&nbsp;that&nbsp;if&nbsp;you&nbsp;extract&nbsp;the&nbsp;indices&nbsp;and&nbsp;the&nbsp;values&nbsp;from&nbsp;a&nbsp;mapping,&nbsp;those&nbsp;two&nbsp;arrays&nbsp;will&nbsp;correspond&nbsp;to&nbsp;each&nbsp;other,&nbsp;the&nbsp;first&nbsp;index&nbsp;value&nbsp;<BR>
corresponding&nbsp;to&nbsp;the&nbsp;first&nbsp;array&nbsp;value,&nbsp;only&nbsp;as&nbsp;long&nbsp;as&nbsp;the&nbsp;mapping&nbsp;hasn't&nbsp;been&nbsp;changed&nbsp;in&nbsp;between&nbsp;those&nbsp;two&nbsp;operations.&nbsp;&nbsp;<BR>
&nbsp;<BR>
mixed&nbsp;m_indices(mapping&nbsp;mapp);&nbsp;<BR>
mixed&nbsp;m_values(mapping&nbsp;mapp);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;This&nbsp;function&nbsp;displays&nbsp;a&nbsp;mapping&nbsp;and&nbsp;its&nbsp;contents&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dump_mapping(mapping&nbsp;mp)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;sz;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mixed&nbsp;ind,&nbsp;val;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ind&nbsp;=&nbsp;m_indices(mp);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;m_values(mp);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sz&nbsp;=&nbsp;sizeof(ind);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0&nbsp;;&nbsp;i&nbsp;&lt;&nbsp;sz&nbsp;;&nbsp;i++)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(sprintf(&quot;%O&quot;,&nbsp;ind[i])&nbsp;+&nbsp;&quot;&nbsp;corresponds&nbsp;to&nbsp;&quot;&nbsp;+&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(&quot;%O&quot;,&nbsp;val[i])&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Example&nbsp;run:&nbsp;dump_mapping(([&nbsp;&quot;fatty&quot;&nbsp;:&nbsp;&quot;blimp&quot;,&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mrpr&quot;&nbsp;:&nbsp;&quot;unique&quot;,&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;olorin&quot;&nbsp;:&nbsp;&quot;bloodshot&quot;&nbsp;]));&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&quot;olorin&quot;&nbsp;corresponds&nbsp;to&nbsp;&quot;bloodshot&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&quot;fatty&quot;&nbsp;corresponds&nbsp;to&nbsp;&quot;blimp&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&quot;mrpr&quot;&nbsp;corresponds&nbsp;to&nbsp;&quot;unique&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
There&nbsp;are&nbsp;two&nbsp;functions&nbsp;that&nbsp;faciliates&nbsp;the&nbsp;saving&nbsp;and&nbsp;restoration&nbsp;of&nbsp;object&nbsp;data,&nbsp;m_save_object()&nbsp;will&nbsp;create&nbsp;a&nbsp;mapping&nbsp;that&nbsp;contains&nbsp;all&nbsp;<BR>
global&nbsp;non-static&nbsp;variables,&nbsp;with&nbsp;the&nbsp;variable&nbsp;names&nbsp;as&nbsp;string&nbsp;indices&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;actual&nbsp;values.&nbsp;You&nbsp;can&nbsp;then&nbsp;either&nbsp;save&nbsp;this&nbsp;<BR>
mapping&nbsp;to&nbsp;file&nbsp;directly,&nbsp;or&nbsp;pass&nbsp;it&nbsp;to&nbsp;another&nbsp;function&nbsp;as&nbsp;you&nbsp;please.&nbsp;The&nbsp;converse&nbsp;of&nbsp;this&nbsp;efun;&nbsp;m_restore_object()&nbsp;takes&nbsp;a&nbsp;mapping&nbsp;as&nbsp;<BR>
argument&nbsp;and&nbsp;reads&nbsp;the&nbsp;contents&nbsp;into&nbsp;the&nbsp;corresponding&nbsp;non-static&nbsp;global&nbsp;variables.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Type&nbsp;conversion&nbsp;<BR>
&nbsp;<BR>
[atoi,&nbsp;atof,&nbsp;ftoa,&nbsp;itof,&nbsp;ftoi,&nbsp;str2val,&nbsp;val2str,&nbsp;sscanf]&nbsp;&nbsp;<BR>
&nbsp;<BR>
Most&nbsp;user&nbsp;input&nbsp;is&nbsp;in&nbsp;the&nbsp;form&nbsp;of&nbsp;strings;&nbsp;you&nbsp;type&nbsp;something&nbsp;and&nbsp;then&nbsp;the&nbsp;game&nbsp;is&nbsp;supposed&nbsp;to&nbsp;act&nbsp;upon&nbsp;your&nbsp;answer.&nbsp;This&nbsp;calls&nbsp;for&nbsp;functions&nbsp;<BR>
that&nbsp;can&nbsp;analyze&nbsp;your&nbsp;input&nbsp;and&nbsp;translate&nbsp;it&nbsp;to&nbsp;values&nbsp;you&nbsp;can&nbsp;use&nbsp;in&nbsp;your&nbsp;program.&nbsp;The&nbsp;syntactical&nbsp;analysis&nbsp;is&nbsp;very&nbsp;complicated,&nbsp;to&nbsp;say&nbsp;the&nbsp;<BR>
least,&nbsp;and&nbsp;I'm&nbsp;going&nbsp;to&nbsp;leave&nbsp;that&nbsp;part&nbsp;for&nbsp;chapter&nbsp;three.&nbsp;However,&nbsp;let's&nbsp;look&nbsp;a&nbsp;bit&nbsp;at&nbsp;the&nbsp;value&nbsp;transformation&nbsp;bit.&nbsp;As&nbsp;stated&nbsp;input&nbsp;is&nbsp;in&nbsp;the&nbsp;form&nbsp;<BR>
of&nbsp;strings,&nbsp;this&nbsp;makes&nbsp;it&nbsp;very&nbsp;interesting&nbsp;to&nbsp;convert&nbsp;strings&nbsp;to&nbsp;integers&nbsp;and&nbsp;floats,&nbsp;and&nbsp;vice&nbsp;versa.&nbsp;&nbsp;<BR>
&nbsp;<BR>
Let's&nbsp;start&nbsp;with&nbsp;integers.&nbsp;Suppose&nbsp;you&nbsp;have&nbsp;received&nbsp;a&nbsp;string&nbsp;holding&nbsp;a&nbsp;numerical&nbsp;value&nbsp;and&nbsp;you&nbsp;want&nbsp;to&nbsp;use&nbsp;it&nbsp;computations.&nbsp;In&nbsp;order&nbsp;to&nbsp;<BR>
convert&nbsp;it&nbsp;to&nbsp;the&nbsp;proper&nbsp;integer&nbsp;value&nbsp;you&nbsp;use&nbsp;the&nbsp;efun&nbsp;atoi(),&nbsp;very&nbsp;simply.&nbsp;It&nbsp;takes&nbsp;a&nbsp;string&nbsp;as&nbsp;argument&nbsp;and&nbsp;converts&nbsp;it&nbsp;to&nbsp;the&nbsp;corresponding&nbsp;<BR>
integer.&nbsp;However,&nbsp;if&nbsp;the&nbsp;string&nbsp;contained&nbsp;non-numerical&nbsp;characters&nbsp;apart&nbsp;from&nbsp;leading&nbsp;or&nbsp;trailing&nbsp;spaces,&nbsp;0&nbsp;will&nbsp;be&nbsp;returned.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;name&nbsp;atoi()&nbsp;is&nbsp;derived&nbsp;from&nbsp;'a(scii)&nbsp;to&nbsp;i(nteger)',&nbsp;for&nbsp;those&nbsp;of&nbsp;you&nbsp;who&nbsp;are&nbsp;interested&nbsp;to&nbsp;know.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;atoi(string&nbsp;str)&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;val;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;atoi(&quot;23&quot;);&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;23&nbsp;+&nbsp;3&nbsp;=&nbsp;&quot;&nbsp;+&nbsp;(val&nbsp;+&nbsp;3)&nbsp;+&nbsp;&quot;\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Floats&nbsp;have&nbsp;a&nbsp;corresponding&nbsp;efun,&nbsp;atof(),&nbsp;which&nbsp;converts&nbsp;a&nbsp;string&nbsp;to&nbsp;float.&nbsp;As&nbsp;you&nbsp;know&nbsp;by&nbsp;now,&nbsp;floats&nbsp;can't&nbsp;be&nbsp;converted&nbsp;to&nbsp;strings&nbsp;the&nbsp;same&nbsp;<BR>
way&nbsp;integers&nbsp;can&nbsp;by&nbsp;simply&nbsp;adding&nbsp;them&nbsp;to&nbsp;another&nbsp;string,&nbsp;but&nbsp;require&nbsp;some&nbsp;other&nbsp;kind&nbsp;of&nbsp;treatment.&nbsp;The&nbsp;efun&nbsp;ftoa()&nbsp;will&nbsp;convert&nbsp;a&nbsp;float&nbsp;to&nbsp;a&nbsp;<BR>
string,&nbsp;and&nbsp;the&nbsp;reverse&nbsp;functoin&nbsp;atof()&nbsp;will&nbsp;turn&nbsp;a&nbsp;string&nbsp;to&nbsp;a&nbsp;float,&nbsp;provided&nbsp;it&nbsp;contains&nbsp;a&nbsp;floating&nbsp;point&nbsp;number.&nbsp;Again,&nbsp;if&nbsp;the&nbsp;string&nbsp;contains&nbsp;<BR>
any&nbsp;non-numerical&nbsp;characters&nbsp;the&nbsp;result&nbsp;will&nbsp;be&nbsp;0.&nbsp;&nbsp;<BR>
&nbsp;<BR>
For&nbsp;conversion&nbsp;between&nbsp;integer&nbsp;and&nbsp;float&nbsp;you&nbsp;have&nbsp;the&nbsp;efuns&nbsp;itof()&nbsp;and&nbsp;ftoi().&nbsp;Just&nbsp;keep&nbsp;in&nbsp;mind&nbsp;that&nbsp;when&nbsp;you&nbsp;convert&nbsp;a&nbsp;float&nbsp;to&nbsp;integer,&nbsp;<BR>
the&nbsp;decimal&nbsp;part&nbsp;will&nbsp;be&nbsp;cut&nbsp;off,&nbsp;not&nbsp;rounded.&nbsp;&nbsp;<BR>
&nbsp;<BR>
There&nbsp;are&nbsp;many&nbsp;occations&nbsp;when&nbsp;you&nbsp;would&nbsp;want&nbsp;to&nbsp;store&nbsp;a&nbsp;value&nbsp;as&nbsp;a&nbsp;string&nbsp;and&nbsp;later&nbsp;convert&nbsp;it&nbsp;back&nbsp;to&nbsp;a&nbsp;value.&nbsp;For&nbsp;this&nbsp;purpose&nbsp;you&nbsp;have&nbsp;the&nbsp;<BR>
two&nbsp;efuns&nbsp;val2str()&nbsp;and&nbsp;str2val().&nbsp;The&nbsp;output&nbsp;from&nbsp;val2str()&nbsp;can&nbsp;be&nbsp;printed,&nbsp;but&nbsp;is&nbsp;not&nbsp;intended&nbsp;to.&nbsp;You&nbsp;can&nbsp;store&nbsp;any&nbsp;kind&nbsp;of&nbsp;<BR>
variable&nbsp;contents&nbsp;as&nbsp;a&nbsp;string&nbsp;using&nbsp;these&nbsp;efuns.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;most&nbsp;used&nbsp;data&nbsp;converter,&nbsp;however,&nbsp;is&nbsp;the&nbsp;efun&nbsp;sscanf().&nbsp;With&nbsp;sscanf()&nbsp;you&nbsp;can&nbsp;specify&nbsp;a&nbsp;pattern&nbsp;that&nbsp;should&nbsp;be&nbsp;scanned&nbsp;for&nbsp;a&nbsp;<BR>
certain&nbsp;value,&nbsp;extract&nbsp;that&nbsp;and&nbsp;put&nbsp;it&nbsp;into&nbsp;a&nbsp;variable.&nbsp;This&nbsp;makes&nbsp;sscanf()&nbsp;a&nbsp;bit&nbsp;special&nbsp;since&nbsp;it&nbsp;handles&nbsp;variables&nbsp;given&nbsp;as&nbsp;arguments,&nbsp;so&nbsp;it's&nbsp;<BR>
impossible&nbsp;to&nbsp;get&nbsp;the&nbsp;function&nbsp;address&nbsp;of&nbsp;sscanf().&nbsp;I&nbsp;know&nbsp;this&nbsp;sounds&nbsp;pretty&nbsp;much&nbsp;like&nbsp;garbled&nbsp;greek&nbsp;to&nbsp;you&nbsp;at&nbsp;this&nbsp;moment,&nbsp;but&nbsp;trust&nbsp;me.&nbsp;<BR>
I'll&nbsp;explain&nbsp;more&nbsp;in&nbsp;detail&nbsp;in&nbsp;chapter&nbsp;3.&nbsp;Anyway,&nbsp;otherwise&nbsp;sscanf()&nbsp;is&nbsp;fairly&nbsp;simple;&nbsp;you&nbsp;provide&nbsp;a&nbsp;string&nbsp;to&nbsp;to&nbsp;search&nbsp;through,&nbsp;a&nbsp;pattern&nbsp;and&nbsp;<BR>
the&nbsp;variables&nbsp;it&nbsp;should&nbsp;store&nbsp;data&nbsp;in,&nbsp;and&nbsp;it&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;matches&nbsp;it&nbsp;actually&nbsp;managed&nbsp;to&nbsp;make.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;string&nbsp;you&nbsp;give&nbsp;for&nbsp;pattern&nbsp;matching&nbsp;is&nbsp;interpreted&nbsp;literally&nbsp;apart&nbsp;from&nbsp;these&nbsp;control&nbsp;strings:&nbsp;&nbsp;<BR>
&nbsp;<BR>
`%d'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches&nbsp;an&nbsp;integer&nbsp;number.&nbsp;&nbsp;<BR>
`%s'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches&nbsp;a&nbsp;character&nbsp;string.&nbsp;&nbsp;<BR>
`%f'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches&nbsp;a&nbsp;float.&nbsp;&nbsp;<BR>
`%%'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matches&nbsp;a&nbsp;%-character.&nbsp;&nbsp;<BR>
&nbsp;<BR>
int&nbsp;sscanf(string&nbsp;str,&nbsp;string&nbsp;pattern,&nbsp;...);&nbsp;<BR>
e.g.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;wide;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;weight;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;orgstr;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;wide_type,&nbsp;weight_type;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Assume&nbsp;the&nbsp;question&nbsp;&quot;How&nbsp;wide&nbsp;and&nbsp;heavy&nbsp;do&nbsp;you&nbsp;think&nbsp;Fatty&nbsp;is?&quot;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;has&nbsp;been&nbsp;posed&nbsp;and&nbsp;answered&nbsp;to.&nbsp;Furthermore,&nbsp;assume&nbsp;that&nbsp;the&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;answer&nbsp;is&nbsp;given&nbsp;on&nbsp;the&nbsp;form&nbsp;'&lt;amount&gt;&nbsp;&lt;sort&gt;&nbsp;and&nbsp;&lt;amount&gt;&nbsp;&lt;sort&gt;',&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;as&nbsp;for&nbsp;example&nbsp;'4&nbsp;yards&nbsp;and&nbsp;3.2&nbsp;tons'.&nbsp;Assume&nbsp;the&nbsp;first&nbsp;value&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;always&nbsp;is&nbsp;an&nbsp;integer&nbsp;and&nbsp;that&nbsp;the&nbsp;second&nbsp;is&nbsp;a&nbsp;float.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Assume&nbsp;that&nbsp;this&nbsp;answer&nbsp;is&nbsp;given&nbsp;in&nbsp;the&nbsp;variable&nbsp;'orgstr'&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;above&nbsp;is&nbsp;naturally&nbsp;only&nbsp;convenient&nbsp;assumptions&nbsp;to&nbsp;make&nbsp;the&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;example&nbsp;easy&nbsp;to&nbsp;write.&nbsp;In&nbsp;reality&nbsp;you'd&nbsp;better&nbsp;be&nbsp;prepared&nbsp;for&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;any&nbsp;kind&nbsp;of&nbsp;format&nbsp;being&nbsp;given&nbsp;as&nbsp;answer.&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sscanf(orgstr,&nbsp;&quot;%d&nbsp;%s&nbsp;and&nbsp;%f&nbsp;%s&quot;,&nbsp;wide,&nbsp;wide_type,&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weight,&nbsp;weight_type)&nbsp;!=&nbsp;4)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Please&nbsp;give&nbsp;a&nbsp;full&nbsp;answer!\n&quot;);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;write(&quot;Aha,&nbsp;you&nbsp;think&nbsp;Fatty&nbsp;is&nbsp;&quot;&nbsp;+&nbsp;wide&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;wide_type&nbsp;+&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;wide&nbsp;and&nbsp;&quot;&nbsp;+&nbsp;ftoa(weight)&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;weight_type&nbsp;+&nbsp;&quot;&nbsp;heavy.\n&quot;);&nbsp;<BR>
&nbsp;<BR>
Math&nbsp;functions&nbsp;<BR>
&nbsp;<BR>
[random,&nbsp;rnd,&nbsp;sin,&nbsp;cos,&nbsp;tan,&nbsp;asin,&nbsp;acos,&nbsp;atan,&nbsp;atan2,&nbsp;exp,&nbsp;log,&nbsp;pow,&nbsp;sinh,&nbsp;cosh,&nbsp;tanh,&nbsp;asinh,&nbsp;acosh,&nbsp;atanh,&nbsp;abs,&nbsp;fact,&nbsp;sqrt]&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;efun&nbsp;random()&nbsp;will&nbsp;return&nbsp;an&nbsp;integer&nbsp;random&nbsp;number&nbsp;from&nbsp;0&nbsp;to&nbsp;one&nbsp;less&nbsp;the&nbsp;number&nbsp;you&nbsp;give&nbsp;as&nbsp;an&nbsp;argument.&nbsp;For&nbsp;example&nbsp;random(8)&nbsp;<BR>
will&nbsp;return&nbsp;an&nbsp;integer&nbsp;from&nbsp;0&nbsp;to&nbsp;7.&nbsp;&nbsp;<BR>
&nbsp;<BR>
The&nbsp;rest&nbsp;of&nbsp;the&nbsp;mathematical&nbsp;functions&nbsp;all&nbsp;return&nbsp;floats&nbsp;and&nbsp;take&nbsp;floats&nbsp;as&nbsp;arguments.&nbsp;The&nbsp;trigonometric&nbsp;functions&nbsp;use&nbsp;radians,&nbsp;not&nbsp;degrees.&nbsp;<BR>
Keep&nbsp;this&nbsp;in&nbsp;mind.&nbsp;&nbsp;<BR>
&nbsp;<BR>
`float&nbsp;rnd()'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns&nbsp;a&nbsp;random&nbsp;number&nbsp;in&nbsp;the&nbsp;range&nbsp;0&nbsp;(inclusive)&nbsp;to&nbsp;1&nbsp;(exclusive),&nbsp;i.e.&nbsp;it&nbsp;might&nbsp;be&nbsp;0,&nbsp;but&nbsp;never&nbsp;1.&nbsp;&nbsp;<BR>
`float&nbsp;sin(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;sinus&nbsp;value&nbsp;of&nbsp;an&nbsp;angle.&nbsp;&nbsp;<BR>
`float&nbsp;cos(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;cosinus&nbsp;value&nbsp;of&nbsp;an&nbsp;angle.&nbsp;&nbsp;<BR>
`float&nbsp;tan(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;tangens&nbsp;value&nbsp;of&nbsp;an&nbsp;angle.&nbsp;&nbsp;<BR>
`float&nbsp;asin(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;sinus&nbsp;value&nbsp;in&nbsp;the&nbsp;range&nbsp;-pi/2&nbsp;to&nbsp;pi/2.&nbsp;&nbsp;<BR>
`float&nbsp;acos(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;cosinus&nbsp;value&nbsp;in&nbsp;the&nbsp;range&nbsp;0&nbsp;to&nbsp;pi.&nbsp;&nbsp;<BR>
`float&nbsp;atan(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;tangens&nbsp;value&nbsp;in&nbsp;the&nbsp;range&nbsp;-pi/2&nbsp;to&nbsp;pi/2.&nbsp;&nbsp;<BR>
`float&nbsp;atan2(float&nbsp;x,&nbsp;float&nbsp;y)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;argument&nbsp;(phase)&nbsp;of&nbsp;a&nbsp;rectangular&nbsp;coordinate&nbsp;in&nbsp;the&nbsp;range&nbsp;-pi&nbsp;to&nbsp;pi.&nbsp;&nbsp;<BR>
`float&nbsp;exp(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;exponential&nbsp;function&nbsp;using&nbsp;the&nbsp;natural&nbsp;logarithm&nbsp;e&nbsp;as&nbsp;base.&nbsp;&nbsp;<BR>
`float&nbsp;log(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;natural&nbsp;logaritm.&nbsp;&nbsp;<BR>
`float&nbsp;sinh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;sinus&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;cosh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;cosinus&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;tanh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;tangens&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;asinh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;sinus&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;acosh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;cosinus&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;atanh(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;arcus&nbsp;tangens&nbsp;hyperbolicus&nbsp;value.&nbsp;&nbsp;<BR>
`float&nbsp;abs(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;absolute&nbsp;value&nbsp;of&nbsp;the&nbsp;given&nbsp;argument.&nbsp;&nbsp;<BR>
`float&nbsp;fact(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;factorial&nbsp;(gamma&nbsp;function)&nbsp;of&nbsp;the&nbsp;given&nbsp;argument.&nbsp;&nbsp;<BR>
`float&nbsp;sqrt(float)'&nbsp;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute&nbsp;the&nbsp;square&nbsp;root&nbsp;of&nbsp;the&nbsp;given&nbsp;argument.&nbsp;&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
※&nbsp;來源:•BBS&nbsp;水木清華站&nbsp;bbs.net.tsinghua.edu.cn•[FROM:&nbsp;klab.ishii.utsu]&nbsp;<BR>
<A HREF="00000016.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一頁</A>
<A HREF="index.htm">回到目錄</A>
<A HREF="#top">回到頁首</A>
<A HREF="00000018.htm">下一篇</A>
</H1></CENTER>
<CENTER><H1>BBS水木清華站︰精華區</H1></CENTER>
</BODY></HTML>