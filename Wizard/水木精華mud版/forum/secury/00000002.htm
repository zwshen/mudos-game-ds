<HTML>
<HEAD>
<TITLE>BBS水木清华站∶精华区</TITLE>
</HEAD>
<BODY>
<CENTER><H1>BBS水木清华站∶精华区</H1></CENTER>
<A Name="top"></a>
发信人:&nbsp;heyusong&nbsp;(松),&nbsp;信区:&nbsp;Mud_Builder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>
标&nbsp;&nbsp;题:&nbsp;《安全漫谈》&nbsp;<BR>
发信站:&nbsp;BBS&nbsp;水木清华站&nbsp;(Thu&nbsp;May&nbsp;18&nbsp;21:37:19&nbsp;2000)&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《安全漫谈》&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;这篇文章主要针对提供正式开放的游戏，如果你&nbsp;<BR>
&nbsp;&nbsp;只是在单机游戏上玩一玩，请不要费神阅读，因&nbsp;<BR>
&nbsp;&nbsp;为这对你毫无用处。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;前一段时间经常看到什么&nbsp;mud&nbsp;被黑，某某自称&nbsp;<BR>
&nbsp;&nbsp;“黑客”者要挟某游戏之说，由此产生感慨写下&nbsp;<BR>
&nbsp;&nbsp;这篇文章。这里无意贬低任何人的能力，如果您&nbsp;<BR>
&nbsp;&nbsp;真是一位高手而并非一知半解的翻翻安全公报、&nbsp;<BR>
&nbsp;&nbsp;在网上找点所谓“黑客工具”试试的那种，鄙人&nbsp;<BR>
&nbsp;&nbsp;愿意随时怀着敬仰的心情聆听您的教诲。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;既然是漫谈，就是想到哪说到哪，内容难免有离题&nbsp;<BR>
&nbsp;&nbsp;之处。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;有些人采用正式开放的游戏里不设巫师，而启动另&nbsp;<BR>
&nbsp;&nbsp;一个游戏的副本来开发以为就万事大吉了，或者我&nbsp;<BR>
&nbsp;&nbsp;根本不给巫师提供&nbsp;edit，首先不说这完全抛弃了&nbsp;<BR>
&nbsp;&nbsp;LPMUD&nbsp;的优越性，还不如改动一下将&nbsp;OS&nbsp;和&nbsp;LIB&nbsp;<BR>
&nbsp;&nbsp;编译后运行，还能极大的提高效率，如果开发环境&nbsp;<BR>
&nbsp;&nbsp;本身是一个不安全的环境，又有谁能保证从这里拿&nbsp;<BR>
&nbsp;&nbsp;走的代码是安全的呢。可能会有人说：比如我根本&nbsp;<BR>
&nbsp;&nbsp;不招收巫师、我们游戏的巫师一生一世都能团结一&nbsp;<BR>
&nbsp;&nbsp;致的象一个人、用人不疑疑人不用，我们的机器是&nbsp;<BR>
&nbsp;&nbsp;请专家配置的，你算什么，等等超过&nbsp;100&nbsp;条理由&nbsp;<BR>
&nbsp;&nbsp;来反驳对安全措施的看法，对此我不提出任何意见，&nbsp;<BR>
&nbsp;&nbsp;记得有人说过一句笑话：使服务器最安全的方法就&nbsp;<BR>
&nbsp;&nbsp;是拔掉网线。对于无谓的争论我不感兴趣，如果你&nbsp;<BR>
&nbsp;&nbsp;认为安全是一个不值得一提的话题，请立刻停止阅&nbsp;<BR>
&nbsp;&nbsp;读本文章以免耽误宝贵的时间。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;最初接触&nbsp;LPC&nbsp;就是看的&nbsp;es2&nbsp;的&nbsp;MUDLIB，还是&nbsp;big5&nbsp;<BR>
&nbsp;&nbsp;码的，读完以后对于其作者&nbsp;Annihilator&nbsp;充满敬仰&nbsp;<BR>
&nbsp;&nbsp;之情，虽说是一个“游戏”之作，但绝对只有本着严&nbsp;<BR>
&nbsp;&nbsp;谨的治学态度才能写到这种程度，虽说也存在着不少&nbsp;<BR>
&nbsp;&nbsp;问题，但那都是细枝末节。es2&nbsp;的&nbsp;mudlib&nbsp;由于是一&nbsp;<BR>
&nbsp;&nbsp;个人由一个统一的思路指导创作而成，其明晰整洁的&nbsp;<BR>
&nbsp;&nbsp;模块化结构，科学直观的继承关系，极大的简化了区&nbsp;<BR>
&nbsp;&nbsp;域编程的难易程度和给与极大的灵活性，致使以后的&nbsp;<BR>
&nbsp;&nbsp;文字&nbsp;mud&nbsp;在&nbsp;es2&nbsp;的沃土上迅速的繁衍生息，而将&nbsp;<BR>
&nbsp;&nbsp;es2&nbsp;类的&nbsp;mud&nbsp;推上&nbsp;LPMUD&nbsp;的主流地位，里面有很大&nbsp;<BR>
&nbsp;&nbsp;的必然性。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;***&nbsp;先从&nbsp;mudlib&nbsp;内部入手&nbsp;***&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;首先要注意几个特别的文件&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;第一位的就是&nbsp;MASTER_OB&nbsp;，一般位于&nbsp;/adm/obj/master.c&nbsp;<BR>
&nbsp;&nbsp;所有限制都是由这个物件里的函数通知&nbsp;mudos，&nbsp;<BR>
&nbsp;&nbsp;当然也包括读、写的禁止与允许，一般的&nbsp;mudlib&nbsp;<BR>
&nbsp;&nbsp;都把有关安全的部分集中到一个叫&nbsp;SECURITY_D&nbsp;模块里&nbsp;<BR>
&nbsp;&nbsp;统一管理，一般位于&nbsp;/adm/daemons/securityd.c，&nbsp;<BR>
&nbsp;&nbsp;将&nbsp;MASTER_OB&nbsp;的读写判断用&nbsp;call_other&nbsp;方式&nbsp;<BR>
&nbsp;&nbsp;引用到这个物件里。这两个文件如果有机会被改写，&nbsp;<BR>
&nbsp;&nbsp;会将&nbsp;mudlib&nbsp;的安全机制完全打破，所以在正式运行&nbsp;<BR>
&nbsp;&nbsp;的游戏里应当禁止对这两个文件的写，需要对这两个&nbsp;<BR>
&nbsp;&nbsp;文件进行改写的机会是很少的，如果遇到这种需要&nbsp;<BR>
&nbsp;&nbsp;可在&nbsp;shell&nbsp;里进行。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;巫师列表文件，一般为&nbsp;/adm/etc/wizlist&nbsp;，这个文&nbsp;<BR>
&nbsp;&nbsp;件里保存了所有巫师的列表和对应的等级，对这个文件&nbsp;<BR>
&nbsp;&nbsp;的写应当设定成只有&nbsp;SECURITY_D&nbsp;物件允许，其它物件&nbsp;<BR>
&nbsp;&nbsp;一律不允许。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;提升巫师命令，一般叫&nbsp;promote&nbsp;，位于&nbsp;/cmds/arch/&nbsp;<BR>
&nbsp;&nbsp;目录下，（这个命令里应当注意的基本原则例如传入物件&nbsp;<BR>
&nbsp;&nbsp;应当为&nbsp;this_player(1)，提升的等级不可超过命令执行&nbsp;<BR>
&nbsp;&nbsp;者的等级等基本问题你应当非常熟悉，此文章的其它部&nbsp;<BR>
&nbsp;&nbsp;分也假设你对一些基本的问题已经有了透彻的了解，而&nbsp;<BR>
&nbsp;&nbsp;不会再与提及，如果你未能了解，请立刻停止阅读本文&nbsp;<BR>
&nbsp;&nbsp;章，以免造成不应有的误解而适得其反。）此文件一经&nbsp;<BR>
&nbsp;&nbsp;写好应当不需要再更改，因此在&nbsp;mudlib&nbsp;应当禁止对此&nbsp;<BR>
&nbsp;&nbsp;文件的写。promote&nbsp;需要呼叫&nbsp;SECURITY_D&nbsp;里的相应函数&nbsp;<BR>
&nbsp;&nbsp;实现巫师等级的提升，一般为&nbsp;set_status()&nbsp;函数，这个&nbsp;<BR>
&nbsp;&nbsp;函数里应当首先判断他的前物件&nbsp;previous_object(0)&nbsp;<BR>
&nbsp;&nbsp;是否为&nbsp;find_object(&quot;/cmds/arch/promote&quot;)&nbsp;，当然不&nbsp;<BR>
&nbsp;&nbsp;能是&nbsp;clonep&nbsp;了，如果不是，立刻&nbsp;return&nbsp;0&nbsp;就是了。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;MASTER_OB&nbsp;里的&nbsp;valid_seteuid()&nbsp;函数很重要，要小心&nbsp;<BR>
&nbsp;&nbsp;配置，一般&nbsp;call_other&nbsp;到&nbsp;SECURITY_D&nbsp;里处理，普通情&nbsp;<BR>
&nbsp;&nbsp;况应当只有&nbsp;seteuid(getuid())&nbsp;、&nbsp;ROOT_UID&nbsp;和&nbsp;<BR>
&nbsp;&nbsp;SIMUL_EFUN_OB&nbsp;允许&nbsp;seteuid。如根据需要扩展须小心配置。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;玩家档案（当然包括巫师）的读和写是应当小心管理的&nbsp;<BR>
&nbsp;&nbsp;地方，LOGIN_OB&nbsp;保存档案的读应当除了&nbsp;restore_object&nbsp;<BR>
&nbsp;&nbsp;函数和神，其它都不能读。由于&nbsp;LOGIN_OB&nbsp;的&nbsp;query_save_file()&nbsp;<BR>
&nbsp;&nbsp;函数的返回值是由&nbsp;query(&quot;id&quot;,1)&nbsp;决定的，所以对&nbsp;LOGIN_OB&nbsp;<BR>
&nbsp;&nbsp;的&nbsp;set&nbsp;应当除了&nbsp;ROOT_UID&nbsp;其它都禁止，也就是在文件里&nbsp;<BR>
&nbsp;&nbsp;写入同名函数&nbsp;nomask&nbsp;mixed&nbsp;set(string&nbsp;prop,&nbsp;mixed&nbsp;data)&nbsp;<BR>
&nbsp;&nbsp;作提前判断，此函数里第一行就应当是&nbsp;<BR>
&nbsp;&nbsp;if(&nbsp;geteuid(previous_object())&nbsp;!=&nbsp;ROOT_UID&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;关于玩家档案的写，应当以物件的文件名和它的&nbsp;euid&nbsp;作依据，&nbsp;<BR>
&nbsp;&nbsp;文件名是否为&nbsp;LOGIN_OB&nbsp;和&nbsp;USER_OB，在&nbsp;valid_write&nbsp;里可以&nbsp;<BR>
&nbsp;&nbsp;象这样判断：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;if(&nbsp;func==&quot;save_object&quot;&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(&nbsp;sscanf(file,&quot;/obj/login/%*s&quot;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;||&nbsp;sscanf(file,&quot;/obj/user/%*s&quot;)&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;id;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(sscanf(file,sprintf(&quot;/obj/login/%c/%%s.o&quot;,euid[0]),id)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(id&nbsp;==&nbsp;euid)&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(sscanf(file,sprintf(&quot;/obj/user/%c/%%s.o&quot;,euid[0]),id)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(id&nbsp;==&nbsp;euid)&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;......&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;不符合就直接进入权限检查，建议除了神和&nbsp;ROOT_UID，其它都&nbsp;<BR>
&nbsp;&nbsp;过滤掉。对于&nbsp;LOGIN_OB&nbsp;和&nbsp;USER_OB&nbsp;这两个文件的写应当经受&nbsp;<BR>
&nbsp;&nbsp;最严格的安全检查。对于&nbsp;LOGIN_OB-&gt;query(&quot;password&quot;)，如&nbsp;<BR>
&nbsp;&nbsp;果不是&nbsp;ROOT_UID，不用说&nbsp;return&nbsp;0&nbsp;就是了，写一个&nbsp;query&nbsp;<BR>
&nbsp;&nbsp;的同名函数即可。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;/feature&nbsp;目录应当只有&nbsp;admin&nbsp;才能写，尤其是&nbsp;save.c&nbsp;、&nbsp;<BR>
&nbsp;&nbsp;dbase.c&nbsp;和&nbsp;command.c&nbsp;。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;SIMUL_EFUN_OB，这个物件的&nbsp;euid&nbsp;绝对不能是&nbsp;ROOT_UID。&nbsp;<BR>
&nbsp;&nbsp;有一个&nbsp;cat()&nbsp;函数写的很不好，根据基本的配置这个函数&nbsp;<BR>
&nbsp;&nbsp;可以完全超越读权限的限制而且毫无实际用处，只是表现了&nbsp;<BR>
&nbsp;&nbsp;编写者对&nbsp;unix&nbsp;的钟爱，建议取消。还有一个函数&nbsp;assure_file()&nbsp;<BR>
&nbsp;&nbsp;用于越权创建原来没有而又必须的目录，在里面要执行&nbsp;<BR>
&nbsp;&nbsp;seteuid(ROOT_UID)，但是&nbsp;es2&nbsp;里面却没有还原，致使执行过&nbsp;<BR>
&nbsp;&nbsp;此函数会使&nbsp;SIMUL_EFUN_OB&nbsp;以后以&nbsp;ROOT_UID&nbsp;运行，这可是不&nbsp;<BR>
&nbsp;&nbsp;得了的事情，在此函数的末尾返回前要加上&nbsp;seteuid(getuid())&nbsp;<BR>
&nbsp;&nbsp;来还原。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;log&nbsp;记录是系统运行状况的晴雨表，此记录的真实性和完整性&nbsp;<BR>
&nbsp;&nbsp;对于管理者至关重要，一般都造一个&nbsp;log_file()&nbsp;simul_efun&nbsp;函&nbsp;<BR>
&nbsp;&nbsp;数，这个函数只接受两个字符串作为参数，这就保证只能以&nbsp;<BR>
&nbsp;&nbsp;append&nbsp;方式写，而不能&nbsp;write_file(&quot;/log/xxx&quot;,&quot;xxx&quot;,1)这种&nbsp;<BR>
&nbsp;&nbsp;形式覆盖写，这个目录应该只有&nbsp;SIMUL_EFUN_OB&nbsp;和神才能写，&nbsp;<BR>
&nbsp;&nbsp;或者连神也不能写也无所谓。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;bind()&nbsp;函数在&nbsp;MASTER_OB&nbsp;的&nbsp;valid_bind&nbsp;里限制，最起码的&nbsp;<BR>
&nbsp;&nbsp;对于玩家物件是绝对不能的。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;关于需要保护的一些函数：&nbsp;<BR>
&nbsp;&nbsp;MASTER_OB&nbsp;里的&nbsp;valid_override专门就是干这个的，当这个函数返&nbsp;<BR>
&nbsp;&nbsp;回&nbsp;0&nbsp;时，你就不能用&nbsp;efun::xxxx()&nbsp;的形式使用系统函数的原型，&nbsp;<BR>
&nbsp;&nbsp;而必须用&nbsp;SIMUL_EFUN_OB&nbsp;里提供的同名函数。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;move_object&nbsp;和&nbsp;destruct&nbsp;由于根据游戏情节需要进行预处理比如&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重量的调整，所以是需要的。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;shutdown&nbsp;函数应当只有&nbsp;shutdown&nbsp;命令才能呼叫，处理方法参考&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提升权限命令的部分，必须保护。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;localtime&nbsp;函数当传入一个&nbsp;&lt;=&nbsp;0&nbsp;的参数时正常情况下会当机，&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必须保护。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;ctime&nbsp;函数同理&nbsp;localtime&nbsp;函数，必须保护。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;interactive&nbsp;函数当传入一个&nbsp;0&nbsp;作为参数时正常情况下会当机，&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;必须保护。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;snoop&nbsp;不用说了，不能允许&nbsp;snoop&nbsp;高于自己权限的人，比如&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你正在&nbsp;more&nbsp;一个我没有读权限的文件。。。必须保护。&nbsp;<BR>
&nbsp;&nbsp;**&nbsp;exec&nbsp;要命的东西，一般只有&nbsp;LOGIN_D&nbsp;才需要，如果你想提供&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update&nbsp;玩家的能力，update&nbsp;命令也应当允许，其它一律禁止，&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然还要注意&nbsp;LOGIN_D&nbsp;执行&nbsp;exec&nbsp;的部分函数必须是&nbsp;private，&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update&nbsp;玩家需要调用&nbsp;enter_world&nbsp;函数，这样&nbsp;enter_world&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;里必须先判断&nbsp;origin()，如果是&nbsp;local&nbsp;可以，如果是&nbsp;call_other&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则&nbsp;previous_object(0)&nbsp;必须是&nbsp;ROOT_UID，其它情况一律禁止。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;MASTER_OB&nbsp;里的&nbsp;creator_file&nbsp;函数是至关重要的，一般引导到&nbsp;<BR>
&nbsp;&nbsp;SIMUL_EFUN_OB&nbsp;里的同名函数处理。它的返回值决定着物件的&nbsp;uid，&nbsp;<BR>
&nbsp;&nbsp;也就是被&nbsp;Mudos&nbsp;制造出来时的&nbsp;euid，它的返回值必须要将第一个&nbsp;<BR>
&nbsp;&nbsp;字母转换成大写以避免和玩家的&nbsp;id&nbsp;发生混淆，需要&nbsp;ROOT_UID&nbsp;的&nbsp;<BR>
&nbsp;&nbsp;一般只有&nbsp;/adm&nbsp;目录，里面的&nbsp;SIMUL_EFUN_OB&nbsp;必须设成一个特殊的&nbsp;<BR>
&nbsp;&nbsp;ID(注意大写开头)，还有极少数的命令需要，其它的都不需要！！&nbsp;<BR>
&nbsp;&nbsp;对于这些目录应当除了神以外任何其它的巫师都不能写。&nbsp;<BR>
&nbsp;&nbsp;有一个特殊情况就是巫师的工作目录可不能大写开头，因为要和巫师&nbsp;<BR>
&nbsp;&nbsp;的等级对齐，不过一定要先判断&nbsp;this_palyer(1)，如果存在必须优&nbsp;<BR>
&nbsp;&nbsp;先返回&nbsp;this_player(1)&nbsp;的&nbsp;euid，否则你目录下的东西被别人&nbsp;clone&nbsp;<BR>
&nbsp;&nbsp;走以后物件的&nbsp;euid&nbsp;还是你的&nbsp;euid，如果碰巧你写了一个权限测试&nbsp;<BR>
&nbsp;&nbsp;物件或者其他什么不像话的东西忘了删掉，后果不堪设想。执行命令&nbsp;<BR>
&nbsp;&nbsp;里需要&nbsp;ROOT_UID&nbsp;的玩家命令是很有限的，最好将这几个命令单开一&nbsp;<BR>
&nbsp;&nbsp;个目录赋予&nbsp;ROOT_UID，小心的检查每一行代码，其它的目录都赋予&nbsp;<BR>
&nbsp;&nbsp;一个奇怪的&nbsp;uid，例如：&quot;Nobody&quot;。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;说到巫师工作目录，由于上面的理由可以知道工作目录的上一级目&nbsp;<BR>
&nbsp;&nbsp;录的写权限是多么的重要，这应该只有神才能写，其它一律禁止。&nbsp;<BR>
&nbsp;&nbsp;再有除了神绝对不能允许写别人的工作目录，这绝对是必要的。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;global&nbsp;include&nbsp;file&nbsp;也是一个非常重要的文件，&nbsp;<BR>
&nbsp;&nbsp;一般定义为&nbsp;/include/globals.h&nbsp;，一般&nbsp;ROOT_UID&nbsp;<BR>
&nbsp;&nbsp;就是由这个文件定义的，如果我把&nbsp;ROOT_UID&nbsp;改成&nbsp;<BR>
&nbsp;&nbsp;我自己的&nbsp;ID&nbsp;&quot;find&quot;，我的&nbsp;euid&nbsp;就是&nbsp;ROOT_UID，后果&nbsp;<BR>
&nbsp;&nbsp;不言而喻，所以在正式开放的游戏里这个文件应该定义&nbsp;<BR>
&nbsp;&nbsp;为不可写。再有一个叫&nbsp;command.h&nbsp;的头文件用来定义可&nbsp;<BR>
&nbsp;&nbsp;执行命令的搜索路径，要瞪大眼睛仔细看，对于此文件&nbsp;<BR>
&nbsp;&nbsp;的写应当只有神允许。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于除了巫师写自己的工作目录以外的写都应当作记录。对于&nbsp;<BR>
&nbsp;&nbsp;/adm&nbsp;目录下的载入物件应当除了神和&nbsp;ROOT_UID&nbsp;以外不允许&nbsp;<BR>
&nbsp;&nbsp;摧毁。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;mudos&nbsp;的&nbsp;OLD_ED&nbsp;是一般游戏都使用的编辑器，在使用者&nbsp;<BR>
&nbsp;&nbsp;断线后保存&nbsp;ed_buffer&nbsp;之前不进行写检查，保存的文件名&nbsp;<BR>
&nbsp;&nbsp;由&nbsp;MASTER_OB&nbsp;里的&nbsp;get_save_file_name&nbsp;返回值决定。这&nbsp;<BR>
&nbsp;&nbsp;绝对不是件好事请，应当在&nbsp;mudos&nbsp;的源代码里&nbsp;ed.c&nbsp;的&nbsp;<BR>
&nbsp;&nbsp;void&nbsp;save_ed_buffer&nbsp;P1(object_t&nbsp;*,&nbsp;who)&nbsp;函数中把&nbsp;<BR>
&nbsp;&nbsp;stmp&nbsp;=&nbsp;safe_apply_master_ob(APPLY_GET_ED_BUFFER_SAVE_FILE_NAME,&nbsp;2);&nbsp;<BR>
&nbsp;&nbsp;一直到&nbsp;free_ed_buffer(who);&nbsp;前一行的内容用&nbsp;<BR>
&nbsp;&nbsp;if&nbsp;(getfn(1)&nbsp;!=&nbsp;NULL)&nbsp;{&nbsp;}&nbsp;括起来。&nbsp;<BR>
&nbsp;&nbsp;MASTER_OB&nbsp;里的&nbsp;get_save_file_name&nbsp;应该返回一个奇怪&nbsp;<BR>
&nbsp;&nbsp;而又难以重复的名字，es2&nbsp;里是&nbsp;sprintf(&quot;%s.%d&quot;,&nbsp;fname&nbsp;,&nbsp;time())&nbsp;<BR>
&nbsp;&nbsp;就很好，如果想以后对此文件操作时少输入几个数字用&nbsp;<BR>
&nbsp;&nbsp;uptime()&nbsp;也很好。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;巫师的档案应当是不允许&nbsp;purge&nbsp;的，purge&nbsp;之前应当&nbsp;<BR>
&nbsp;&nbsp;先降为玩家，同理，巫师也应当不允许自杀。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;区域文件的&nbsp;euid&nbsp;应当定义为区域名较容易管理，&nbsp;<BR>
&nbsp;&nbsp;它的&nbsp;euid&nbsp;应当把第一个字母置换成大写以避免&nbsp;<BR>
&nbsp;&nbsp;和用户&nbsp;id&nbsp;冲突。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;在所有的读写权限安排好以后，还有一个巨大的安全&nbsp;<BR>
&nbsp;&nbsp;隐患，就是&nbsp;dbase.c&nbsp;，一般位于&nbsp;/feature/dbase.c&nbsp;<BR>
&nbsp;&nbsp;这一般不太会引起人的注意但又是很致命的弱点，这&nbsp;<BR>
&nbsp;&nbsp;个物件里的主变量&nbsp;mapping&nbsp;dbase&nbsp;保存所有的变量&nbsp;<BR>
&nbsp;&nbsp;设置，这是&nbsp;es2&nbsp;类的&nbsp;mudlib&nbsp;极大的优点，把所有的&nbsp;<BR>
&nbsp;&nbsp;变量处理集中模块化，充分的利用了继承性极大的简&nbsp;<BR>
&nbsp;&nbsp;化了编程和执行效率。但由于它极强的通用性在某些&nbsp;<BR>
&nbsp;&nbsp;方面如果不作限制会造成安全隐患。问题在于这个物&nbsp;<BR>
&nbsp;&nbsp;件里的&nbsp;query_entire_dbase()&nbsp;函数，由于&nbsp;mudos&nbsp;是&nbsp;<BR>
&nbsp;&nbsp;用&nbsp;c&nbsp;语言编写充分利用了指针的特性，这个函数返回&nbsp;<BR>
&nbsp;&nbsp;的是&nbsp;dbase&nbsp;的指针而不是它的副本，由于通过这个函&nbsp;<BR>
&nbsp;&nbsp;数取得了&nbsp;dbase&nbsp;的地址指针，所以就可对它为所欲为&nbsp;<BR>
&nbsp;&nbsp;而完全超越&nbsp;mudlib&nbsp;的安全限制。例如：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;object&nbsp;user;&nbsp;//&nbsp;是一个玩家物件。&nbsp;<BR>
&nbsp;&nbsp;&nbsp;mapping&nbsp;my;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;my&nbsp;=&nbsp;user-&gt;query_entire_dbase();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;my[&quot;max_force&quot;]&nbsp;=&nbsp;1000000;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;my[&quot;force&quot;]&nbsp;=&nbsp;1000000;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;哈，这个玩家的内力就变成&nbsp;100&nbsp;万了，有什么东西能&nbsp;<BR>
&nbsp;&nbsp;检查出我干了这事情？&nbsp;<BR>
&nbsp;&nbsp;更有甚者：&nbsp;<BR>
&nbsp;&nbsp;比如我有一个密码的密文&nbsp;&quot;Tn/2pfZd4HtKc&quot;&nbsp;<BR>
&nbsp;&nbsp;它的明文只有我知道是&nbsp;&quot;12345&quot;&nbsp;<BR>
&nbsp;&nbsp;这个密文是很容易得到的，随便一个单机&nbsp;mud&nbsp;设置好&nbsp;<BR>
&nbsp;&nbsp;密码一&nbsp;save&nbsp;就得到了。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;object&nbsp;user;&nbsp;//&nbsp;是一个在线的天神物件&nbsp;<BR>
&nbsp;&nbsp;&nbsp;object&nbsp;link;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;mapping&nbsp;my;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(objectp(link&nbsp;=&nbsp;user-&gt;query_temp(&quot;link_ob&quot;))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;=&nbsp;link-&gt;query_entire_dbase();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my[&quot;password&quot;]&nbsp;=&nbsp;&quot;Tn/2pfZd4HtKc&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;在其毫无知觉的情况下把他的密码改掉了，等他退线，&nbsp;<BR>
&nbsp;&nbsp;这个密码就会保存好，那位神由于不知道新密码就进&nbsp;<BR>
&nbsp;&nbsp;不来了，这个账号的密码明文只有你知道，怎么说呢，&nbsp;<BR>
&nbsp;&nbsp;&nbsp;现在你就是神！&nbsp;<BR>
&nbsp;&nbsp;所以应当作一些小限制，在&nbsp;LOGIN_OB&nbsp;里应当加入：&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;这对系统毫无用处，return&nbsp;0&nbsp;<BR>
&nbsp;&nbsp;nomask&nbsp;mapping&nbsp;query_entire_dbase()&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;避免以后扩展可能带来问题&nbsp;<BR>
&nbsp;&nbsp;nomask&nbsp;mapping&nbsp;query_entire_temp_dbase()&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;连接物件只允许系统设置&nbsp;<BR>
&nbsp;&nbsp;nomask&nbsp;mixed&nbsp;set_temp(string&nbsp;prop,&nbsp;mixed&nbsp;data)&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if((&nbsp;prop&nbsp;==&nbsp;&quot;body_ob&quot;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(!previous_object()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;||&nbsp;(geteuid(previous_object())&nbsp;!=&nbsp;ROOT_UID))&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;::set_temp(prop,&nbsp;data);&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;除了系统不允许取得密码的密文，避免互相了解以后&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;缩小猜测范围，用猜谜码软件取得明文&nbsp;<BR>
&nbsp;&nbsp;nomask&nbsp;varargs&nbsp;mixed&nbsp;query(string&nbsp;prop,&nbsp;int&nbsp;raw)&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if((&nbsp;prop&nbsp;==&nbsp;&quot;password&quot;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(!previous_object()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;||&nbsp;(geteuid(previous_object())&nbsp;!=&nbsp;ROOT_UID))&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;::query(prop,raw);&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于&nbsp;USER_OB&nbsp;不能这么限制，首先应当写一个&nbsp;simul_efun&nbsp;<BR>
&nbsp;&nbsp;用于复制变量，也就是强制产生一个变量副本而不是指针，&nbsp;<BR>
&nbsp;&nbsp;比如这个函数叫&nbsp;mixed&nbsp;duplicate(mixed&nbsp;var)&nbsp;<BR>
&nbsp;&nbsp;在&nbsp;USER_OB&nbsp;里加入：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;mapping&nbsp;query_entire_dbase()&nbsp;//&nbsp;Find.&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;//&nbsp;非系统需要返回&nbsp;dbase&nbsp;的副本而非指针&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(&nbsp;previous_object()&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(previous_object()&nbsp;!=&nbsp;this_object())&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;(geteuid(previous_object())&nbsp;!=&nbsp;ROOT_UID)&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;duplicate(dbase);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;dbase;&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;mapping&nbsp;query_entire_temp_dbase()&nbsp;同理。需要注意的还有&nbsp;<BR>
&nbsp;&nbsp;保存武功的&nbsp;skill.c&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;//&nbsp;link_ob&nbsp;除了系统决不能允许别人设置&nbsp;<BR>
&nbsp;&nbsp;nomask&nbsp;mixed&nbsp;set_temp(string&nbsp;prop,&nbsp;mixed&nbsp;data)&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if((prop&nbsp;==&nbsp;&quot;link_ob&quot;))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if(!previous_object()&nbsp;||&nbsp;(geteuid(previous_object())&nbsp;!=&nbsp;ROOT_UID)&nbsp;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;::set_temp(prop,&nbsp;data);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;再有一个忠告，对于安全至关重要的物件绝对不要用&nbsp;<BR>
&nbsp;&nbsp;F_DBASE&nbsp;来管理变量！！！！！！！切记！！&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;关于巫师的一些特有设置：&nbsp;<BR>
&nbsp;&nbsp;比如隐身或者根据某些标记察看系统的运行状态，一般为了&nbsp;<BR>
&nbsp;&nbsp;方便巫师都集中在&nbsp;set&nbsp;玩家命令里，这些标记应该单开一&nbsp;<BR>
&nbsp;&nbsp;个区域存放，如果沿用&nbsp;es2&nbsp;的处理方法，需要有几点要&nbsp;<BR>
&nbsp;&nbsp;注意:&nbsp;<BR>
&nbsp;&nbsp;在设置时进行检查，如果都是单层设置可以：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;strsrch(arg,'/');&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(!i)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;错误返回&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(i&gt;0)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;arg[0..i-1];&nbsp;<BR>
&nbsp;&nbsp;再进行设置标记判断。&nbsp;<BR>
&nbsp;&nbsp;如果有多层设置：&nbsp;<BR>
&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;implode(&nbsp;(explode(arg,&quot;/&quot;)&nbsp;-&nbsp;({&quot;&quot;})),&quot;/&quot;);&nbsp;<BR>
&nbsp;&nbsp;再进行设置标记判断。&nbsp;<BR>
&nbsp;&nbsp;在标记的作用模块里应当进行&nbsp;wizardp()&nbsp;的检查，这是好&nbsp;<BR>
&nbsp;&nbsp;的作风。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于巫师物件和来源于巫师的物件应当在自己的系统里严格的&nbsp;<BR>
&nbsp;&nbsp;标记出来，对于这些物件上的&nbsp;action&nbsp;应当绝对禁止玩家执行，&nbsp;<BR>
&nbsp;&nbsp;对于这些物件对玩家产生的任何影响都应当毫无例外的详细的&nbsp;<BR>
&nbsp;&nbsp;记录，如果想给自己留一个方便之门最后只会使自己深受其害。&nbsp;<BR>
&nbsp;&nbsp;对于这套系统的建立方法由于牵涉面比较广通用性也很差，说&nbsp;<BR>
&nbsp;&nbsp;起来连篇累牍，就不详细说了，需要根据自己的系统特点小心&nbsp;<BR>
&nbsp;&nbsp;的选择方法详细的考察。&nbsp;<BR>
&nbsp;&nbsp;对于非法&nbsp;action&nbsp;的过滤到是可以举个例子供参考，这个工作&nbsp;<BR>
&nbsp;&nbsp;应当在玩家物件的&nbsp;process_input()&nbsp;函数里进行，在返回之前&nbsp;<BR>
&nbsp;&nbsp;应当通过一个过滤函数进行过滤，比如&nbsp;<BR>
&nbsp;&nbsp;if(userp(this_object())&nbsp;&amp;&amp;&nbsp;!wizardp(this_object()))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;action&nbsp;=&nbsp;control_action(action);&nbsp;<BR>
&nbsp;&nbsp;control_action&nbsp;函数的内容应该大概象下面这个样子：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;private&nbsp;string&nbsp;control_action(string&nbsp;cmd)&nbsp;<BR>
&nbsp;&nbsp;{&nbsp;<BR>
&nbsp;&nbsp;&nbsp;mixed&nbsp;*cmds;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;int&nbsp;i;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;string&nbsp;str;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(!stringp(cmd)&nbsp;||&nbsp;cmd&nbsp;==&nbsp;&quot;&quot;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;&quot;;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;sscanf(cmd,&quot;%s&nbsp;%*s&quot;,str);&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(str&nbsp;==&nbsp;&quot;&quot;)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;str;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(!str)&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;cmd;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;cmds&nbsp;=&nbsp;this_object()-&gt;query_commands();&nbsp;<BR>
&nbsp;&nbsp;&nbsp;//&nbsp;后面乱了，请自己看此页的源码&nbsp;<BR>
&nbsp;&nbsp;&nbsp;for(i=0;iquery_wiz_flag())&nbsp;//&nbsp;巫师或来源于巫师的物件&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;&quot;;&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;return&nbsp;cmd;&nbsp;<BR>
&nbsp;&nbsp;}&nbsp;<BR>
&nbsp;&nbsp;这样的结果例如巫师&nbsp;clone&nbsp;一个鸡腿给玩家，玩家是&nbsp;<BR>
&nbsp;&nbsp;没法“吃”的，或者有巫师&nbsp;clone&nbsp;一个乱七八糟的衣服&nbsp;<BR>
&nbsp;&nbsp;之类的东西给玩家，玩家拿着它什么也干不了。这样的行&nbsp;<BR>
&nbsp;&nbsp;为应当根据记录受到严厉的处罚。不过在&nbsp;give&nbsp;命令里应&nbsp;<BR>
&nbsp;&nbsp;当作个判断来禁止这种“给”从而提醒巫师或者自己这样&nbsp;<BR>
&nbsp;&nbsp;作是非法的！窃以为这是'仁慈'的做法，不要不教而诛。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于巫师的密码应当有特殊的要求，必须8位同时包含字母、数字&nbsp;<BR>
&nbsp;&nbsp;和特殊字符，否则应当禁止登陆。巫师账号的密码过一定时间&nbsp;<BR>
&nbsp;&nbsp;应当强制更改，一般&nbsp;30&nbsp;天比较合适。对于巫师账号的密码输&nbsp;<BR>
&nbsp;&nbsp;入错误应当作详细的记录，至少也应当包括时间和来源。对于&nbsp;<BR>
&nbsp;&nbsp;连续几次输入错误应当将这个账号&nbsp;block&nbsp;住禁止登陆来防止&nbsp;<BR>
&nbsp;&nbsp;密码猜测，一般为&nbsp;3-5&nbsp;次较好。当然还要设立灵活安全的恢&nbsp;<BR>
&nbsp;&nbsp;复机制，否则游戏所有的巫师都无法进入就闹笑话了。应当将&nbsp;<BR>
&nbsp;&nbsp;被&nbsp;block&nbsp;的账号记录在一个只有&nbsp;ROOT_UID&nbsp;才能写的文件里，&nbsp;<BR>
&nbsp;&nbsp;block&nbsp;管理物件定时根据此文件的内容进行更新，一般&nbsp;30&nbsp;分&nbsp;<BR>
&nbsp;&nbsp;钟为宜，这样管理者就可以在&nbsp;shell&nbsp;里去除某个账号的封锁&nbsp;<BR>
&nbsp;&nbsp;状态。这种保护应当监视所有的连入手段，包括&nbsp;ftp。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;最好不要在&nbsp;mudlib&nbsp;提供&nbsp;http&nbsp;服务，有的甚至在&nbsp;mudlib&nbsp;提&nbsp;<BR>
&nbsp;&nbsp;供游戏主页的服务，主页制作的丰富多姿，这种情况应该是坚&nbsp;<BR>
&nbsp;&nbsp;决杜绝的！&nbsp;www&nbsp;页面上的每一个元素都要引起一个并发请求，&nbsp;<BR>
&nbsp;&nbsp;对于复杂的页面即使浏览的人不多，瞬间的并发请求也会超出&nbsp;<BR>
&nbsp;&nbsp;一般人的想象，mudos&nbsp;操作是一个大循环，大量的请求会严重&nbsp;<BR>
&nbsp;&nbsp;影响游戏的执行速度和占用大量的带宽，如果实在难以抑制这&nbsp;<BR>
&nbsp;&nbsp;种冲动可以只提供一些反映游戏内部状况的&nbsp;cgi&nbsp;生成一些简&nbsp;<BR>
&nbsp;&nbsp;单的信息页面供你游戏的主页调用嵌入。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;如果想提供网际互连，应当明确的指定几个允许互连的游戏，&nbsp;<BR>
&nbsp;&nbsp;并将其它的屏蔽掉避免过重的端口负担。由于一般网际互连的&nbsp;<BR>
&nbsp;&nbsp;服务程序都以&nbsp;ROOT_UID&nbsp;运行，所以要严格检查这些程序代码&nbsp;<BR>
&nbsp;&nbsp;里是否被人留了一手，最好将此部分移出&nbsp;/adm&nbsp;目录，但这要&nbsp;<BR>
&nbsp;&nbsp;改变很多头文件很麻烦，简便的方法在前面提到的&nbsp;creator_file&nbsp;<BR>
&nbsp;&nbsp;函数里将此目录下的物件设定成一个特殊的&nbsp;ID，例如：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;case&nbsp;&quot;adm&quot;:&nbsp;<BR>
&nbsp;&nbsp;&nbsp;if(&nbsp;sscanf(file,&quot;/adm/daemons/network/services/%*s&quot;))&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;Netservice&quot;;&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;如果你的这些服务代码里有对&nbsp;ROOT_UID&nbsp;的需求，将其移至&nbsp;<BR>
&nbsp;&nbsp;DNS_MASTER&nbsp;或者方便的模块里统一处理。如果你的&nbsp;valid_seteuid()&nbsp;<BR>
&nbsp;&nbsp;函数里允许了&nbsp;/adm&nbsp;目录，请先将这个目录抛除.&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;如果&nbsp;receive&nbsp;函数接受的字串有超过字串最大长度设定（一般为&nbsp;8k）&nbsp;<BR>
&nbsp;&nbsp;的行，有可能会造成当机，应当有适当的措施处理。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;关键部分不要编制晦涩难懂的代码，这只会带来安全和&nbsp;bug&nbsp;隐患，&nbsp;<BR>
&nbsp;&nbsp;代码要尽量的简洁清晰。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;前一段时间听别人谈起过游戏的数据备份问题，沉重的备份（比如&nbsp;<BR>
&nbsp;&nbsp;对整个游戏代码或者所有动态档案的备份）工作应当在&nbsp;shell&nbsp;里&nbsp;<BR>
&nbsp;&nbsp;用&nbsp;crontab&nbsp;编制&nbsp;shell&nbsp;script&nbsp;来完成。由于&nbsp;mudos&nbsp;的工作机制&nbsp;<BR>
&nbsp;&nbsp;做这种事情实在是哪壶不开提哪壶，如果难以避免进行这类沉重的&nbsp;<BR>
&nbsp;&nbsp;工作（比如想提供符合实际的玩家排名就需要对所有的玩家档案进&nbsp;<BR>
&nbsp;&nbsp;行检索），应当采用均衡负担的技巧不对游戏的运行产生可感受的&nbsp;<BR>
&nbsp;&nbsp;影响。要注意的是，这类工作对于&nbsp;mud&nbsp;来说有一件都嫌多。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于一个设置良好的&nbsp;mudlib&nbsp;可以在安全的前提下赋予巫师最大的&nbsp;<BR>
&nbsp;&nbsp;自由度，这对一个游戏的建设应当是必要的。&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;***&nbsp;从外部来说：***&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;首先应该能保证服务器的物理安全，没有这个前提根本谈不上安全&nbsp;<BR>
&nbsp;&nbsp;两个字，试想一个左手拿着锤子右手拿着螺丝刀的人站在你的机器&nbsp;<BR>
&nbsp;&nbsp;面前，你除了表现出一副什么都不在乎的样子，还能作些什么呢。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;选用操作系统，由于&nbsp;MUD&nbsp;一般都是非盈利性的，所以应当选用一个&nbsp;<BR>
&nbsp;&nbsp;免费的低成本操作系统，例如&nbsp;linux、FreeBSD、Solaris&nbsp;8&nbsp;等，&nbsp;<BR>
&nbsp;&nbsp;以大家熟识的&nbsp;linux&nbsp;为例，其它都同理。安装系统时不需要的软件&nbsp;<BR>
&nbsp;&nbsp;包一律不装，如果已经安装了就将其卸掉，linux&nbsp;是&nbsp;rpm&nbsp;-e&nbsp;<BR>
&nbsp;&nbsp;FreeBSD&nbsp;是&nbsp;pkg_delete。保证系统的所有软件都已经升级到了最新&nbsp;<BR>
&nbsp;&nbsp;的稳定版本。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;服务器应当提供尽可能少的服务，应当做到专机专用，只提供&nbsp;mud&nbsp;<BR>
&nbsp;&nbsp;服务，如果提供其它的服务请参考相关的说明，对于一些“臭名昭著”&nbsp;<BR>
&nbsp;&nbsp;的服务，例如&nbsp;rpc&nbsp;netbios&nbsp;等除非你对它有透彻的了解，否则一定&nbsp;<BR>
&nbsp;&nbsp;要关闭。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;首先绝对不要以&nbsp;Root&nbsp;运行游戏，应当单设一个用户作为&nbsp;mud&nbsp;<BR>
&nbsp;&nbsp;管理者。一般用户的主目录都是&nbsp;/home/id&nbsp;，而在游戏中很容易&nbsp;<BR>
&nbsp;&nbsp;得到执行档的路径&nbsp;get_config(__BIN_DIR__)，这样就可以知道&nbsp;<BR>
&nbsp;&nbsp;管理者的&nbsp;id，为攻击明确目标，所以管理者的&nbsp;home&nbsp;目录应当&nbsp;<BR>
&nbsp;&nbsp;设定成一个别的目录，比如&nbsp;/home/mud，使人无法从执行档路径&nbsp;<BR>
&nbsp;&nbsp;得知游戏管理者的&nbsp;id，游戏管理者的&nbsp;ID&nbsp;不要起和游戏有关的&nbsp;<BR>
&nbsp;&nbsp;id&nbsp;,&nbsp;例如&nbsp;game&nbsp;games&nbsp;mud&nbsp;mudadm&nbsp;mudmud&nbsp;tianxia&nbsp;txia&nbsp;tianx&nbsp;<BR>
&nbsp;&nbsp;等等这类的&nbsp;id&nbsp;都是很不好的，甚至是自己在游戏中的&nbsp;id，应该&nbsp;<BR>
&nbsp;&nbsp;是一个另类的&nbsp;ID&nbsp;而且毫无普遍的意义，密码的设定不要使用游&nbsp;<BR>
&nbsp;&nbsp;戏中或电子邮件等其它地方用过的密码，专码专用，设定原则同&nbsp;<BR>
&nbsp;&nbsp;游戏中巫师密码的设定原则。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;使用&nbsp;shadow&nbsp;保存密码，/etc/shadow，FreeBSD&nbsp;里面叫&nbsp;<BR>
&nbsp;&nbsp;/etc/master.passwd&nbsp;这个文件应当是&nbsp;root&nbsp;root&nbsp;400。&nbsp;<BR>
&nbsp;&nbsp;去除所有不需要的账号，一些系统账号设置成不可能登陆。&nbsp;<BR>
&nbsp;&nbsp;一般只保留&nbsp;root&nbsp;和游戏管理者两个可能登陆账号，root&nbsp;<BR>
&nbsp;&nbsp;除了控制台不允许登陆。将&nbsp;home&nbsp;目录的权限设定为&nbsp;700，&nbsp;<BR>
&nbsp;&nbsp;umask&nbsp;设定为&nbsp;077。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;为了便于远程维护需要&nbsp;telnet&nbsp;ftp&nbsp;的服务，不要启动&nbsp;inetd&nbsp;<BR>
&nbsp;&nbsp;服务，而代之以&nbsp;sshd2&nbsp;这种加密方式的连接，其设置有几点要&nbsp;<BR>
&nbsp;&nbsp;注意：&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;PermitEmptyPasswords&nbsp;一定要是&nbsp;no&nbsp;<BR>
&nbsp;&nbsp;PasswordGuesses&nbsp;&nbsp;设成&nbsp;2&nbsp;足以&nbsp;<BR>
&nbsp;&nbsp;PermitRootLogin&nbsp;&nbsp;不用说&nbsp;no&nbsp;<BR>
&nbsp;&nbsp;Ssh1Compatibility&nbsp;no&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;AllowedAuthentications&nbsp;&nbsp;publickey,password&nbsp;<BR>
&nbsp;&nbsp;RequiredAuthentications&nbsp;&nbsp;publickey,password&nbsp;<BR>
&nbsp;&nbsp;必须通过&nbsp;publickey&nbsp;和&nbsp;password&nbsp;的双重验证&nbsp;<BR>
&nbsp;&nbsp;其它的请查询相关的手册&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;一个干净的系统应当只提供&nbsp;sshd2&nbsp;和游戏这两个服务。&nbsp;<BR>
&nbsp;&nbsp;尽量减少此账号的使用人数，定期更换密码&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;经常用&nbsp;ifconfig&nbsp;-a&nbsp;检查你的网卡是否处于混杂模式。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;经常阅读记录档，并打包下载备份。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;定期察看自己系统所使用的程序升级版本信息以确定是否要&nbsp;<BR>
&nbsp;&nbsp;升级。定期察看安全公报看自己所使用的系统是否出现了对&nbsp;<BR>
&nbsp;&nbsp;你产生影响的漏洞，及相关的安全补丁。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;发现了新的安全工具，拿来先搞明白原理，然后不用考虑，先&nbsp;<BR>
&nbsp;&nbsp;照着自己的系统来一通。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;其它的一些安全问题请参考相应的文章。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于一个&nbsp;mud&nbsp;服务器很难有条件再架一台服务器作为专门的&nbsp;<BR>
&nbsp;&nbsp;防火墙，所以只能自己保护自己，一般采用&nbsp;ipfilter&nbsp;类型的&nbsp;<BR>
&nbsp;&nbsp;防火墙，对于包过滤类的防火墙的具体配置由于各系统的方法&nbsp;<BR>
&nbsp;&nbsp;不同，所以只谈原则。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;一般是两个网络设备，lo&nbsp;本地环路，eth0&nbsp;网卡（外部通道）&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;不信任任何源地址&nbsp;<BR>
&nbsp;&nbsp;禁止&nbsp;forward&nbsp;<BR>
&nbsp;&nbsp;禁止任何来自&nbsp;eth0&nbsp;的包声称自己来自本地（ip&nbsp;欺骗）&nbsp;<BR>
&nbsp;&nbsp;对于源地址进行核对&nbsp;<BR>
&nbsp;&nbsp;提供&nbsp;SYN&nbsp;cookies&nbsp;保护&nbsp;<BR>
&nbsp;&nbsp;禁止任何来自外部的广播包&nbsp;<BR>
&nbsp;&nbsp;对于本地设备&nbsp;lo&nbsp;都放行,&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于&nbsp;ICMP&nbsp;：&nbsp;<BR>
&nbsp;&nbsp;应当只允许&nbsp;destination-unreachable(网络不可到达)、&nbsp;<BR>
&nbsp;&nbsp;echo-request(ping)&nbsp;和&nbsp;echo-reply&nbsp;(ping&nbsp;回应，如果&nbsp;<BR>
&nbsp;&nbsp;不需要尽可过滤掉)这三个进入，其它一律过滤掉。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于&nbsp;UDP：&nbsp;<BR>
&nbsp;&nbsp;一个是需要一个外部&nbsp;dns_server&nbsp;帮你进行解析，比如&nbsp;<BR>
&nbsp;&nbsp;它的&nbsp;ip&nbsp;地址为&nbsp;a.b.c.d&nbsp;，所以对于来源于&nbsp;a.b.c.d&nbsp;53&nbsp;<BR>
&nbsp;&nbsp;的目的地为本地高端端口(1023-65535)的包放行，&nbsp;<BR>
&nbsp;&nbsp;如果你提供&nbsp;mud&nbsp;互连，对于目的地为这个端口的包也应当&nbsp;<BR>
&nbsp;&nbsp;放行，如果你只和有限的几个&nbsp;mud&nbsp;互相，也可以将其定义&nbsp;<BR>
&nbsp;&nbsp;在防火墙里，对于来源于这几个互连端口目的地正确的才&nbsp;<BR>
&nbsp;&nbsp;放行。&nbsp;<BR>
&nbsp;&nbsp;其它一律过滤掉。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于&nbsp;tcp:&nbsp;<BR>
&nbsp;&nbsp;对于你的&nbsp;ssh&nbsp;端口，如果你是固定&nbsp;isp&nbsp;拨号上网应当对源&nbsp;<BR>
&nbsp;&nbsp;地址进行判断，比如你的&nbsp;isp&nbsp;的动态&nbsp;ip&nbsp;分配的都是&nbsp;<BR>
&nbsp;&nbsp;a.b.xxx.xxx，你可以设定源地址为&nbsp;a.b.0.0/16&nbsp;的才放行。&nbsp;<BR>
&nbsp;&nbsp;如果你是固定&nbsp;ip&nbsp;，可以指定&nbsp;a.b.c.d/32&nbsp;放行。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;对于提供游戏服务的端口，目的地为本地此端口的包一律放行。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;Mudlib&nbsp;一般为了巫师的工作都要提供&nbsp;ftp&nbsp;服务，这部分代码&nbsp;<BR>
&nbsp;&nbsp;要注意绝对不要提供被动模式的&nbsp;ftp&nbsp;连接，也就是&nbsp;passive&nbsp;<BR>
&nbsp;&nbsp;命令是不可执行的，只能采用主动模式。规则应当这样：&nbsp;<BR>
&nbsp;&nbsp;对于目的地为这个&nbsp;ftp&nbsp;端口的包放行，ftp&nbsp;还要建立第二条&nbsp;<BR>
&nbsp;&nbsp;数据连接，由于&nbsp;port&nbsp;方式这个连接是由&nbsp;ftp&nbsp;server&nbsp;发起的，&nbsp;<BR>
&nbsp;&nbsp;tcp&nbsp;的连接过程是一个三次握手的过程，发起连接的包的控制&nbsp;<BR>
&nbsp;&nbsp;位需要置&nbsp;SYN，所以只要是包的控制位没有置&nbsp;SYN&nbsp;，目的地为&nbsp;<BR>
&nbsp;&nbsp;本地高端端口的才放行。&nbsp;<BR>
&nbsp;&nbsp;其它的包一律过滤掉。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;要注意的是&nbsp;防火墙不等于安全！！！&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;一个安全牢靠的系统环境是游戏成功的基本保障&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;由于安全部分是很早以前作的，难免有一些细节被遗忘疏漏，&nbsp;<BR>
&nbsp;&nbsp;再加上本人水平有限，只是作为一个参考。而且所说的不保&nbsp;<BR>
&nbsp;&nbsp;证&nbsp;100%&nbsp;正确，如果你按照本文设置造成系统崩溃、机器爆&nbsp;<BR>
&nbsp;&nbsp;炸等灾难后果，本人概不负责。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;绝对不要给自己留任何后门，也许会有暂时的欣喜感和某种&nbsp;<BR>
&nbsp;&nbsp;心理上的满足，但这是要以长期的痛苦甚至不可逆转的恶果&nbsp;<BR>
&nbsp;&nbsp;作代价的！！&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;总之，安全不是代码，安全是意识，只要你时时想着安全，&nbsp;<BR>
&nbsp;&nbsp;你所处的环境就会越来越安全。否则原有的问题不能解决，&nbsp;<BR>
&nbsp;&nbsp;而且还会由于你的粗疏不断产生新的问题，最后只能无奈&nbsp;<BR>
&nbsp;&nbsp;的说：es2&nbsp;类的&nbsp;mudlib&nbsp;是全世界最不安全的&nbsp;mudlib。&nbsp;<BR>
&nbsp;&nbsp;绝对的安全是不存在的！&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;如果你觉得这篇文章对你有所启发，我将会感到荣幸，如果大多&nbsp;<BR>
&nbsp;&nbsp;数人都认为毫无用处我也会很欣慰，因为游戏的安全状况比我的&nbsp;<BR>
&nbsp;&nbsp;想象要好得多。&nbsp;<BR>
&nbsp;&nbsp;如有缺失欢迎来信指正，<A HREF="mailto:jytong@263.net，如有人愿意以次为">jytong@263.net，如有人愿意以次为</A>&nbsp;<BR>
&nbsp;&nbsp;基础共同来维护一个&nbsp;MUD&nbsp;安全&nbsp;FAQ&nbsp;之类的东西，本人愿意在&nbsp;<BR>
&nbsp;&nbsp;精力允许的情况下积极参与。&nbsp;<BR>
&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《天下》mud.263.net&nbsp;6666&nbsp;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现号(Find)&nbsp;<BR>
&nbsp;<BR>
&nbsp;<BR>
--&nbsp;<BR>
※&nbsp;来源:・BBS&nbsp;水木清华站&nbsp;smth.org・[FROM:&nbsp;202.195.240.33]&nbsp;<BR>
<A HREF="00000002.htm">上一篇</A>
<A HREF='javascript:history.go(-1)'>返回上一页</A>
<A HREF="index.htm">回到目录</A>
<A HREF="#top">回到页首</A>
</CENTER>
<CENTER><H1>BBS水木清华站∶精华区</H1></CENTER>
</BODY></HTML>