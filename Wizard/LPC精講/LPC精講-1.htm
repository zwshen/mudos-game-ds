
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>網蟲樂園--泥潭風雲</TITLE>
<META content="MSHTML 5.00.2919.6307" name=GENERATOR>
<META content=TLT name=Author>
<META content=text/html;charset=big5 http-equiv=content-type>
<style>
<!--      
A:link {text-decoration: none;color:blue}       
.105V         {font-size: 10.5pt; font-family: 宋體;}
TD          {font-size: 9pt; font-family: 宋體;}
.90V         {font-size: 9pt; font-family: 宋體;}
.90VE         {font-size: 9pt; font-family: arial;}
A:hover      {text-decoration: none;color:red;}
A:visited  {text-decoration: none;}
A:active     {text-decoration: none;color:#ff0000}
-->
</style>


<script>
<!--
lstart=50
loop=true
speed=350 
pr_step=5 

function makeObj(obj,nest){
nest=(!nest) ? '':'document.'+nest+'.'
this.css=(document.layers) ? eval(nest+'document.'+obj):eval(obj+'.style')
    this.scrollHeight=document.layers?this.css.document.height:eval(obj+'.offsetHeight')
    this.up=goUp
this.obj = obj + "Object"
eval(this.obj + "=this")
return this
}
function goUp(speed){
    if(parseInt(this.css.top)>-this.scrollHeight){
        this.css.top=parseInt(this.css.top)-pr_step
        setTimeout(this.obj+".up("+speed+")",speed)
    }else if(loop) {
        this.css.top=lstart
        eval(this.obj+".up("+speed+")")
    }
}
function slideInit(){
    oSlide=makeObj('divNews','divCont')
    oSlide.css.top=lstart
    oSlide.up(speed)
}
onload=slideInit
//-->
</script></head>

<body aLink="#660033" bgColor="#ffffff" leftMargin="0" text=darkgreen link="#000066" vLink="#000066"
topMargin="0" >
<div align="center"><center>
   <table border="1" width="776" borderColor=#ffffff borderColorLight=#ab9c36  align="center" bgColor=#f0f3dc cellPadding=0 cellSpacing=0 >
      <tr>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/home.gif width=15 height=15><a href=http://202.114.98.14/>網蟲樂園首頁</a></td> 
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/soft.gif height=15 width=15 border=0><a href="http://202.114.98.12/softroom/">軟件大觀園</a></td>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/mud.gif height=15 width=15 border=0><a href="http://202.114.98.14/mud/">泥潭風雲</font></a></td>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/freeweb.gif height=15 width=15 border=0><a href="http://202.114.98.14/freeweb/">個人主頁空間</a></td>  
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/bbs.gif height=15 width=15 border=0><a href=http://202.114.98.14/bbs/>網蟲社區</a></td>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/webresource.gif height=15 width=15 border=0><a href="http://202.114.98.14/webresource/">Web資源角</a></td>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/show.gif height=15 width=15 border=0><a href="#" onclick="window.open('http://202.114.98.14/show/','','menubar=no,toolbar=no,location=no,directories=no,status=no,resizable=1,scrollbars=1,width=800,height=600,top=0,left=0');">秀網珍藏</a></td>
        <td align="center" width="97"><P align=center><img src=http://202.114.98.14/images/links1.gif height=15 width=15 border=0><a href=http://202.114.98.14/links/>友情鏈接</a></td>
      </tr>
    </table></center>

<table bgcolor=white width=770 border=1 borderColor=#ffffff borderColorLight=#ab9c36   cellpadding=0 cellspacing=0>
   <tr><td><table bgcolor=white width=770 border=0 cellpadding=0 cellspacing=0>
   <tr><td width=180 height=60><img src=http://202.114.98.14/images/netbugs1.gif width=180 height=60></td>
   <td align=center width=468 valign=center  bgcolor=white><script src="http://202.114.98.14/ad1.js" width=468 height=60 border=0></script></td>
   <td width=112 bgcolor=white><div id="divCont"
style="position:absolute; width:110; height:60; top:25; left:660; clip:rect(0,110,60,0)"><div
id="divNews" style="position:absolute; top:0; left:0">

<p>歡迎光臨網蟲樂園！<a href=http://202.114.98.14/>首頁</a>有網站各子站最新變動介紹和
教育網酷站連接。<p><a href=http://202.114.98.12/softroom/>軟件大觀園</a>每日更新；收藏3G軟件，均為最新版本。
<p><a href=http://202.114.98.14/mud>泥潭風雲</a>是教育網內最大的mud站點；<a href=http://202.114.98.14/webresource>Web資源角</a>有三千多動畫和背景為你網頁增添色彩。
<p><a href=http://202.114.98.14/freeweb/>10M免費個人主頁空間</a>，ftp維護；申請三日內批准。<p><a href=http://202.114.98.14/show>秀網珍藏</a>圖片近2G，欄目眾多，包羅萬像，每日都有大量圖片增加。
<p>對我們網站的建設的建議歡迎<a href=mailto:softroom@wuhee.edu.cn>來信</a>或寫在<a href=http://202.114.98.14/bbs>社區</a>內。</p>
</div></div>
</td>
   </tr>
   </table>
</td></tr></table>

<center>
   <table border="1" width="770" borderColor=#ffffff borderColorLight=#ab9c36  align="center" bgColor=#f0f3dc cellPadding=0 cellSpacing=0 >
      <tr>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/index.htm">首頁</A></td> 
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/newcomer/">泥巴入門</A></td>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/player/">泥巴進階</A></td>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/source/">泥巴資源</A></td>  
        <td align="center" width="96"><P align=center><A 
        href="http://202.114.98.14/mud/pmud/">圖形泥巴</A></td>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/mudlife/">泥巴人生</A></td>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/wiz/">巫師樂園</FONT></A></td>
        <td align="center" width="96"><P align=center><A href="http://202.114.98.14/mud/download/">軟件下載</A>            <SCRIPT>
   document.write("<a href=http://webpub.au.tsinghua.edu.cn/count/count.dll?Type=Basic&id=2138&ReferID=2138 target=_blank>");
   document.write("<img src=http://webpub.au.tsinghua.edu.cn/count/count.dll?Type=Img2&add=1&id=2138&refer="+escape(top.document.referrer)+" border=0 alt=酷站今日訪問 width=12 height=12>");
   </SCRIPT></td>

      </tr>
    </table></center>
    

<table border="0" width="100%" style="color: rgb(255,255,0)" cellspacing="0" cellpadding="0">
  <tr>
    <td width="8%" rowspan="4"></td>
    <td width="83%"><p align="center"><font color="#000000">LPC語言<br>
    –––––––––––––––––––––<br>
    <font size="2">綜合地介紹MUD編程語言（LPC）<br>
    –––––––––––––––––––––––––</font></font></td>
    <td width="9%" rowspan="4"></td>
  </tr>
  <tr>
    <td width="83%"><p align="center"><font color="#000000">LPC精講（1）</td>
  </tr>
  <tr>
    <td width="83%"><font color="#000000">以下文章轉自XO，特此聲明：<br>
    嗯，下面是我給6666的新巫師們的一篇入門讀物，大家可以看看。是我從清華BBS巫師版弄來的，是台灣人寫的，有些詞語我改成大家比較熟悉的，很多地方加了注，可能更好懂一些。<br>
    這篇說明是為了新上任的巫師所寫的, 
    我假設讀著這篇說明文件的新巫師已經讀過 help new_wiz 中的內容, 
    並對巫師專有的指令如 clone,update, cd, ls, cp... 等能熟練地加以使用, 
    但對如何開始寫作自己的區域感到茫然, 不知所措的新進巫師　<br>
    [在開始制作之前]<br>
    讓我們大略看一下在 LP MUD 中, 世界的構成方式　這個世界是由(目前大陸上玩的 
    mud ，包括 xkx,fy,es2 都是 lp mud<br>
    即所謂戰鬥 mud。---lnwm 注。)一個個的對像 (object) 所組成, 
    每個對像有一個對應的程序來描(比如你在mud裡見到的每個房間，每個npc，每個物品，甚至你自己，都是一個 
    object，都是一段程序。----lnwm 注。)述它的特性　我們可以藉由寫作一段程序來創造出一個全新的對像, 
    可以利用update來更新對像所屬的程序, 用 clone 來實際造出一個可<br>
    (比如你敲 update here，就是將你現在所在的房間更新，這裡需要強調的是，所謂更新，就是將硬盤裡這個文件編譯後形成一段代碼，這段代碼是存在在內存中的。因此當你修改了一個房間，那只表明你在硬盤上改動了這個文件，你必須做一下 
    update ，將它編譯放入內存，你的修改才正式生效。hehe，當然，編譯有錯誤例外。----lnwm 
    注。)用的對像　.(clone其實就是 update，只不過它update的是一個物品或npc，這個物品<br>
    或npc還需要有地方放，所以clone就是 update+move---lnwm注。)<br>
    在這裡, 我們有各式各樣的對像, 但是可以將之區分為三大類: 房間 
    (ROOM), 物品 (OBJECT), 與生物 (LIVING)　 在我們制作區域的慣(這個OBJECT不過是個名詞以和ROOM 
    LIVING區分，和我們mud的object是兩碼事。---lnwm 注。)<br>
    例上, 我們習慣將房間的檔案直接擺在區域的目錄下, 
    生物與物品則擺(區域的習慣放置位置是根目錄下的 /d 
    目錄。特別是大陸的，你可以在 /d下找到所有的房間和npc-------lnwm注.)<br>
    在這個區域中名為 npc 及 obj (也有人喜歡用 object 或item為名, 
    看個人習慣　) 的子目錄中　。<br>
    以下我將以這三大類對像來分別說明該如何實作出區域<br>
    [如何制作房間]<br>
    一個房間必定繼承了 ROOM (inherit ROOM), 這是在(對，如果你要寫一個房間，那麼首先要做的就是在這個程序的開頭寫上<br>
    inherit ROOM;在有些時候，比如在xkx裡，你可能還要加上一句#include因為房間的門是定義在那裡的。---lnwm注。)<br>
    mudlib.h中被 #define 好的一個檔案, 它表示一個特別的檔案, 
    所有的房間都必須繼承它. 才能擁有屬於房間的一切特性!<br>
    一個房間有三個非常重要的函數: create(), init(), 與 refresh()這三個函數會在某些特定的時機被系統所呼叫, 
    並且可以由你自行改寫,以達成千變萬化的效果。<br>
    [create 函數]<br>
    create() 是房間在一被創造出來時必定要呼叫的一個函數, 通常我(如果你學過C語言，那麼在lpc中，void 
    create()就相當於 void main()，即主函數。---lnwm注。)們都在裡面做一大堆設定初值的動作　隨便找一個房間來看, 
    我們可以發現 create() 函數中總是有一大堆的 
    set(&quot;something&quot;,somevalue);這些 set 的意義在此不詳述, 
    你可以自己猜, 也可以問問較資深的巫師.(在我們這個mud中，你可以敲help 
    STD_ROOM來看看這些設置是幹什麼的。---lnwm注。)<br>
    有時你的房間並不直接繼承 ROOM　而是繼承了一個有繼承 ROOM 
    的特別房間, 像是商店或是公會房間什麼的　這時候你所寫的 create()(在我們的mud中，錢莊就是個典型的例子，在錢莊的前面，你必須inherit 
    SHOP;這個SHOP就是在ROOM的基礎上加了錢莊的公用功能。---lnwm注。)<br>
    [init 函數]<br>
    init() 函數被呼叫的時機在於有生物 (npc及玩家) 進入這個房(這裡的意思是，當有玩家或npc等活物進入房間時，可以是走進來，扔進來，或clone進來，房間中的這個init()函數就被觸發，函數實現的功能就被實現。----lnwm注。)間的時候　這時有個常用的函數 
    this_player() 會傳回走進房間的這個人, 或是npc。　this_player() 
    的概念容後再談, 
    你現在只要記住這個函數在每個生物走進來時都會被呼叫一次就可以了(這裡的意思是，如果你要對進入房間的玩家做一些動作，比如弄暈他<br>
    或給他中毒等時，那麼就在init()函數里對 this_player()作操作就可以了，this_player()就是觸發init()函數的玩家。---lnwm注。)<br>
    在 init() 中最常見的的函數莫過於 add_action&quot;function&quot;, 
    &quot;action&quot;);了　它的作用是在進來的生物身上添加上一個指令 (注意, 
    系統只認指令的第一個字), 並在玩家下達這個指令時去呼叫 
    &quot;function&quot; 中所給定名稱的函數　舉例而言, 
    如果我們寫了這樣的 init():<br>
    init()<br>
    {<br>
    add_action(&quot;do_climb&quot;, &quot;climb&quot;);<br>
    }<br>
    當玩家走進這個房間時, 系統會幫他多出 climb 這個指令　當他下達(如果這個指令不是cmds，那麼在沒有add_action的房間裡就不會存在。)了 
    climb tree 這個指令時, 系統會去尋找 do_climb() 這個函數, 並(do_clone()這個函數當然是你去寫了---lnwm注。)加以執行。　同時, 
    系統會將玩家所輸入的 &quot;climb&quot; 
    這個指令後的所有文字以字串類型的變量傳給do_climb()　 你可以將 
    do_climb 這個函數宣告為int do_climb(string arg)(注意，這個帶函數類型和參數類型的函數才是完整寫法。---lnwm注。)這樣一來, 
    當玩家下達 climb tree, 或是 climb the red wall 這種指令時,&quot;tree&quot; 
    或是 &quot;the red wall&quot; 就會被存進字串變量 arg 之中供你處理　。<br>
    由 add_action() 所宣告的函數必定要是一個整數類型的函數, 
    因為系統會根據這個函數的傳回值採取不同的動作　如果你傳回的是 
    0,那麼系統會認定這個命令與你這個處理函數無關, 而對其他也有 
    climb命令的函數一個一個嘗試著去執行, 直到所有的 climb 命令都傳回 
    0。(這段話很重要，當你要玩家在使用某個cmds時出現其他的用處，比如你要玩家eat一個果子不僅僅漲食物，而且漲別的東西，那麼你就要在果子上用 
    add_action來給eat賦予更多的內容，然後在你處理eat的那個函數最後 
    return 0;這就是告訴系統，我這個指令並沒有完，系統就會尋找本來的那個 
    eat 命令的功能函數，也就是加上食物。這稱為重載。----lnwm注。)<br>
    若你的函數傳回值為 1, 表示這個指令已經由你所寫的函數處理掉了, 
    系統不會再嘗試著往下面繼續尋找其他的 climb 指令　(給出一個例子。<br>
    void init()<br>
    {<br>
    add_action(&quot;do_eat&quot;,&quot;eat&quot;);<br>
    }<br>
    int do_eat( string arg )<br>
    {<br>
    object me;<br>
    me=this_player();//觸發指令的玩家。<br>
    if (arg!=&quot;果子&quot;)<br>
    return notify_fail(&quot;你要吃什麼？\n&quot;);<br>
    //notify_fail() 就是 return 0<br>
    me-&gt;set(&quot;str&quot;,1000); //這裡是你要使這個果子與眾不同的地方。<br>
    return 0; //這裡使這個果子和其他食物一樣仍然可以漲<br>
    //食物，你可以試試 return 1<br>
    //那樣你發現你的果子吃了不漲食物。<br>
    }<br>
    ----lnwm 注。)<br>
    在你的函數偵測到玩家輸入的變量有問題時 (例如你要他們 climb tree, 
    但他們卻輸入了一些錯誤的指令如 climb three 之類的)　 
    想給他們一些特別的錯誤訊息時, 你可以用notify_fail(string errormsg)來寫這個訊息, 
    如notify_fail(&quot;climb what?\n&quot;); notify_fail()這個函數也是 int 類型, 
    固定會傳回 0, 所以我們最常用的寫法是:<br>
    if (條件不合)<br>
    return notify_fail(錯誤訊息);<br>
    if (另一個條件不合)<br>
    return notify_fail(另一個錯誤訊息);<br>
    .............................<br>
    &lt;所有可能導致錯誤的輸入都過濾光了&gt;<br>
    開始真正幹活的部份....<br>
    return 1;<br>
    (可以參考一下上面的例子。---lnwm注。)<br>
    [refresh() 函數]<br>
    refresh 呼叫的時機是系統定時 (約每半個小時一次) 呼叫主<br>
    要的用途在於房間中npc　物品的再生　如果你改寫了 refresh()函數, 
    千萬記得要串接 ::refresh(), 否則可能導致嚴重的後果 (門一打開就不會自動關上, 
    npc打死後也不會再生...由於有 set(&quot;objects&quot;, ([&quot;name1&quot; : 
    &quot;file1&quot;, &quot;name2&quot; :&quot;file2&quot;,... ]) ); 這種寫法的存在 (在 
    create() 裡面這麼寫) 所(set(&quot;objects&quot;,([]))用來在房間裡放東西，比如npc或物品什麼的。---lnwm注。)以 
    refresh() 被用到的機會不多了　 (因為 set(&quot;objects&quot;, ) 
    這個寫法可以幫你作出自動定時refresh npc　物品) 
    但是在制作一些必須定時回復原始狀態的小機關時, 
    仍然有必要用到這個函數( refresh 
    函數用到的地方並不是很多，因為它太僵硬，要十分固定的半個小時(準確的是24分鐘)才被調用一次，可以用在一些周期較長的秘密中。---lnwm注。)<br>
    有關房間的部份就寫到這裡, 接下來是物品　<br>
    [ 物品的製造]<br>
    要制作物品, 首先必須 inherit OBJECT;　理由與做房間時必須inherit ROOM 
    一樣　OBJECT 是最基本的物品, 
    如果你要做的東西是武器　防具　地圖等, 你必須 inherit WEAPON, ARMOR, 
    MAP 等等才能獲得這種類別的物品所擁有的特性<br>
    物品的重要函數只有 create() 與 init(), 作用與 ROOM 
    中的同名函數大致相同　<br>
    [create() 函數]<br>
    要寫 create() 函數, 
    最好的方法是拿現成的同類物品來修改　因為不同類的物品往往可以 
    set 不同的屬性, 而且特性極多, 有重量價格　攻擊力(武器)　防禦能力(防具)　使用壽命(火把)等等　很難記得完整, 
    所以我勸你找一個較完整檔案來修改　<br>
    [init() 函數]<br>
    與 ROOM 中的 init 函數類似, 但是被呼叫的時機多了許多, 
    共有下列的幾種情況:<br>
    1. 物品擺在房間中, 有一個玩家走進來　<br>
    2. 一個物品突然出現在某個玩家所在的房間中　<br>
    3. 一個物品突然出現在某個玩家的物品欄中　<br>
    物品的 init 函數大多還是用在寫 add_action 上面, 這些 action 會<br>
    生效的場合歸結起來很簡單, 就是:<br>
    「玩家用 l 或是 i 指令看得到這個物品的時候」<br>
    同一個房間中他人或npc身上的東西時不算, 
    裝在袋子的東西不算　這點要注意一下(其實既然都是object，那麼實際上房間和物品並沒有本質的不同，因此在房間上的 
    create() init()函數用法和房間相同，正如前面說的，可能有一點區別的就是物品的init()函數被觸發的機會多一些而已。---lnwm注。)<br>
    [npc]<br>
    簡單的npc很好做, 連 init 都不用寫, 只需要寫 create(), 
    唯一的問題是屬性太多了, 要一一理解得花上相當的時間才行　<br>
    會做複雜動作的npc則需要相當的技巧, 
    並且了解有哪些變量可以被攔截下來改寫利用　等你有一定的程度時, 
    再來找個npc參考參考較好　<br>
    npc要 inherit NPC 也沒有 refresh() 這個函數　<br>
    [程序必須的概念]<br>
    你必須了解, 在 LPC 中最重要的一個概念是對像(object) 
    當你想做任何動作時, 都要考慮到這個動作是哪一個 object 所做的, 
    不然很容易導致錯誤　LPC 的語法並不嚴謹, 
    有些場合為了省事可以將函數是由哪個對像所作的省略掉, 
    例如我們在 create() 函數中最常看到的set(), 事實上最嚴謹的寫法應為 
    this_object()-&gt;set()　write() 則為 this_player()-&gt;write()(對，我們必須弄清楚，object 
    的概念是整個lpc的核心。往深一點說，每個object無非是一個包含了數據結構和內部外部函數的對像，他的數據結構決定了它的屬性，比如房間的<br>
    名稱，玩家的skills等等，而他的外部函數提供了修改這些數據結構的方法，比如 
    set_skill(&quot;xkx&quot;,1000)比如 set(&quot;title&quot;,&quot;大俠&quot;)這裡set_skill()和set()函數就是object和外部的接口。數據結構和接口函數就拼出了一個object。---lnwm注。)<br>
    說這麼多只是為了強調一件事: 你能抓出一個物品的 object 
    變量就能讓他幹一切他所能做的事　<br>
    [this_object() 與 this_player()]<br>
    這兩個函數是系統所提供的函數, 
    也是最最好用的兩個函數　在你寫作一個對像 (房間　物品...etc.)時, 
    this_object() 表示自己這個對像(講清object的結構後，你必須清楚object的所謂封閉性。當我們在程序裡寫 
    set(&quot;name&quot;,&quot;長劍&quot;)時，實際上是this_object()-&gt;set(&quot;name&quot;,&quot;長劍&quot;)的簡略寫法。這樣set(&quot;name&quot;)的不是其他的東西，每一個object有自己獨立的數據結構，它能與其他object嚴格區分開來。即使是同一個長劍程序，當你clone了兩把時，在內存中就有兩個完全獨立的長劍object，你對其中一把做的任何處理如改名，改威力完全不影響另一把的數據，這就是object的封閉性。---lnwm注。)<br>
    this_player() 則比較複雜, 
    它會傳回一個屬於玩家類型的對像這個玩家在 init 中就是觸發 init 
    的那個玩家this_player() 會跟著函數呼叫一直傳遞給所有被 init 
    呼叫的函數, 包括 add_action 中所定義出來的函數, 在這些函數中, 
    this_player() 就是表示做動作的那個人　<br>
    [present() 函數]<br>
    常常, 我們只知道一個對像的名字, 卻不能用個 object 
    類型的變量指向它　 object=present(string &quot;id&quot;,object env)<br>
    函數在此時就可以派上用場, 你給定你要找的對像的名字,與它的所在地 
    (某個房間或某個人), 函數就會傳回他所找到的對　<br>
    簡單的想, present 
    函數其實就是在一個房間裡找出某個名字的物品的函數　它是同類型找物品的函數中最有用的一個, 
    其餘的函數還有find_player(), find_living() 等等(這裡再強調一次，名字不過是一個object的數據結構中的一個部分，單單一個名字沒有任何意義。present,find_living,find_player函數就是從名字(id)找到這個object，有了這個object才好對它做操作。在mud裡你 
    help present；help find_living；hrlp find_player能看到這幾個函數的詳細用法。 
    ---lnwm注。)<br>
    [environment(), first_inventory(), next_inventory(), all_inventory()]<br>
    這一組函數跟對像所處在的位置有關　 environment(object ob)傳回了對像 
    ob 所處在的地點, 例如 ob 是個玩家或生物, 那麼這個函數會傳回 ob 
    所在的房間; 如果 ob 是個物品, 那麼傳回的就是攜帶著ob 的生物, 
    或是 ob 所在的房間 (如果沒有任何人帶著它)<br>
    first_inventory(object ob) 所傳回的是 ob 中的第一個對像,如果 ob 是房間, 
    則傳回第一個物品或是生物, 如果 ob 是生物, 
    則傳回他身上所帶的第一個物品<br>
    next_inventory(object ob) 通常跟著 first_inventory() 
    一起使用　它的功用是傳回 ob 的下一個物品, 在同一個environment 中　<br>
    all_inventory(object ob) 類似於 first_inventory(), 
    但是它所傳回的是包含了所有物品的一整個陣列(上面談的是環境問題，一個object(除房間外)都要有自己的環境，所謂環境就是這個object在什麼地方放著，是一間房間還是一口箱子還是一個人身上，環境通常是另一個object。比如物品A和B放在一個人M身上，那麼上面的函數就給出了它們的關係<br>
    M=environment(A);<br>
    M=environment(B);<br>
    A=first_inventory(M);<br>
    B=next_inventory(M);<br>
    A=all_inventory(M)[0];<br>
    B=all_inventory(M)[1];<br>
    ---lnwm注。)<br>
    [更進一步的提示]<br>
    LPC 的函數群有三個, efun, lfun, simul_efun　它們提供了絕大部分的功能。<br>
    [關於輸出輸入訊息的各個函數的提示]<br>
    can_read_chinese<br>
    printf, sprintf<br>
    scanf, sscanf<br>
    write, say, shout<br>
    tell_object, tell_room<br>
    [關於對像操作的函數]<br>
    clone, new (變出新object )<br>
    destruct, remove (摧毀object )<br>
    move, move_player, move_around (移動object ---lnwm注。)<br>
    (這些函數不可能一一講解了，你可以在mud裡用help &lt;函數名&gt;<br>
    來看(英文呦)，然後再放到程序裡自己試試。 ---lnwm 注。)</font></td>
  </tr>
  <tr>
    <td width="83%"><font size="2"><p align="center"><a href="lpc_2.asp">下一篇</a></font></td>
  </tr>
</table>
   <TABLE border=0 cellPadding=0 cellSpacing=0 width=730>
  <TBODY>
  <TR>
    <TD bgColor=#000033 colSpan=3 height=2>
    </TD>
  </TR>
  </TBODY>
</TABLE>
<P>
<CENTER><FONT color=#919191 face=ARIAL,HELVETICA size=-1>對我們網站的建議和合作請與<A 
href="mailto:softroom@wuhee.edu.cn">mailto:softroom@wuhee.edu.cn</A>聯繫.<BR><BR>Copyright 
(C) 2000 網蟲樂園工作室.<script src="http://202.114.98.14/count.js" width=468 height=60 border=0></script></FONT>
<P></P></CENTER></CENTER></CENTER></DIV></BODY></HTML>
